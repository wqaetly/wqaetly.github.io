<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>（译）快速入门Unity编辑器拓展（IMGUI） | 登峰造极者，殊途亦同归。</title><meta name="author" content="烟雨迷离半世殇"><meta name="copyright" content="烟雨迷离半世殇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 我的技能编辑器马上就要和大家见面了，正好最近几天编辑器拓展接触的比较多一点，就想着趁热打铁优化一下架构并且重置一波UI，因为本来的样子雀食丑的一，期间遇到了许多问题，在搜索Control IDs相关内容的找到了Bunny大神的这篇文章，他将编辑器拓展里一些十分晦涩的概念以及一些事件的运行流程都清晰的解读了，故翻译出来分享给大家。 本文翻译自：https://github.com/Bunny8">
<meta property="og:type" content="article">
<meta property="og:title" content="（译）快速入门Unity编辑器拓展（IMGUI）">
<meta property="og:url" content="https://www.lfzxb.top/unity-editor-crash-course/index.html">
<meta property="og:site_name" content="登峰造极者，殊途亦同归。">
<meta property="og:description" content="前言 我的技能编辑器马上就要和大家见面了，正好最近几天编辑器拓展接触的比较多一点，就想着趁热打铁优化一下架构并且重置一波UI，因为本来的样子雀食丑的一，期间遇到了许多问题，在搜索Control IDs相关内容的找到了Bunny大神的这篇文章，他将编辑器拓展里一些十分晦涩的概念以及一些事件的运行流程都清晰的解读了，故翻译出来分享给大家。 本文翻译自：https://github.com/Bunny8">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/202509232351560.webp">
<meta property="article:published_time" content="2021-04-18T00:00:00.000Z">
<meta property="article:modified_time" content="2021-04-18T00:00:00.000Z">
<meta property="article:author" content="烟雨迷离半世殇">
<meta property="article:tag" content="Unity技术">
<meta property="article:tag" content="编辑器拓展">
<meta property="article:tag" content="工具开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/202509232351560.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "（译）快速入门Unity编辑器拓展（IMGUI）",
  "url": "https://www.lfzxb.top/unity-editor-crash-course/",
  "image": "https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/202509232351560.webp",
  "datePublished": "2021-04-18T00:00:00.000Z",
  "dateModified": "2021-04-18T00:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "烟雨迷离半世殇",
      "url": "https://www.lfzxb.top/www.lfzxb.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp"><link rel="canonical" href="https://www.lfzxb.top/unity-editor-crash-course/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="AhlEJ91V_L12bkwRF1ZS0BbytGCfsjqCX4GXztUluC8"><meta name="baidu-site-verification" content="iRRtEBalDiujISsN"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 8
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-7235595771604497',
  enable_page_level_ads: 'true'
});</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-XSL6D8K8G2"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-XSL6D8K8G2')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-XSL6D8K8G2', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":800,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '（译）快速入门Unity编辑器拓展（IMGUI）',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/CustomIcons/iconfontformaliyun.css"><meta name="referrer" content="no-referrer-when-downgrade"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar" loading='lazy'></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">243</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">186</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-torii-gate"></i><span> 蓬莱仙境</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-stream"></i><span> 白驹过隙</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 包罗万象</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分朋引类</span></a></div><div class="menus_item"><a class="site-page" href="/self/"><i class="fa-fw fas fa-id-card"></i><span> 择交而友</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 一见如故</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/202509232351560.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/202507052331881.png!webp" alt="Logo" loading='lazy'></a><a class="nav-page-title" href="/"><span class="site-name">（译）快速入门Unity编辑器拓展（IMGUI）</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-torii-gate"></i><span> 蓬莱仙境</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-stream"></i><span> 白驹过隙</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 包罗万象</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分朋引类</span></a></div><div class="menus_item"><a class="site-page" href="/self/"><i class="fa-fw fas fa-id-card"></i><span> 择交而友</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 一见如故</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">（译）快速入门Unity编辑器拓展（IMGUI）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-04-18T00:00:00.000Z" title="发表于 2021-04-18 00:00:00">2021-04-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-18T00:00:00.000Z" title="更新于 2021-04-18 00:00:00">2021-04-18</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">游戏引擎</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B7%A5%E5%85%B7%E6%B5%81/">工具流</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">5.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>16分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/unity-editor-crash-course/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;这篇文章已经&quot;,&quot;messageNext&quot;:&quot;天没维护了，相关内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2021-04-18 00:00:00&quot;}" hidden=""></div><div id="postchat_postcontent"><h1>前言</h1>
<p>我的技能编辑器马上就要和大家见面了，正好最近几天编辑器拓展接触的比较多一点，就想着趁热打铁优化一下架构并且重置一波UI，因为本来的样子雀食丑的一，期间遇到了许多问题，在搜索Control IDs相关内容的找到了Bunny大神的这篇文章，他将编辑器拓展里一些十分晦涩的概念以及一些事件的运行流程都清晰的解读了，故翻译出来分享给大家。</p>
<p>本文翻译自：<a target="_blank" rel="noopener" href="https://github.com/Bunny83/Unity-Articles/blob/master/IMGUI%20crash%20course.md">https://github.com/Bunny83/Unity-Articles/blob/master/IMGUI%20crash%20course.md</a></p>
<p>Unity的IMGUI系统非常简单，但功能非常强大。主要部分有：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour.OnGUI.html">OnGUI callback</a>。此回调用于处理与GUI有关的所有事情。</li>
<li>与OnGUI关系密切的<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/Event.html">Event class</a>。</li>
<li><a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUIStyle.html">GUIStyle class</a>定义一个控件的外观。它实际上负责任何GUI的绘制工作。</li>
<li><a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUISkin.html">GUISkin class</a>这基本上只是一个预定义的控件样式集合，并且拥有一个自定义style数组，可以自由拓展。</li>
<li><a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUIUtility.html">GUIUtility</a>与<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/EditorGUIUtility.html">EditorGUIUtility</a>。当使用GUILayout class时，不要忘记不起眼但依旧重要的<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUILayoutUtility.html">GUILayoutUtility class</a>。</li>
</ul>
<h1>OnGUI</h1>
<p>OnGUI是一个回调，引擎会出于多种目的自动调用它。它通常每帧至少调用两次，但是当一些事件发生时可能会调用更多次。</p>
<p>我认为OnGUI是一个坏名字。当然，它的主要目的是“绘制GUI”，但这实际上是事件处理器的回调。我将在下一节中对此进行解释。</p>
<h1>The Event class</h1>
<p>Event Class保存有关OnGUI中当前正在处理的事件的信息。即其静态成员<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/Event-current.html">current</a>。它保存Event类的实例，并且仅在OnGUI中有效。</p>
<p>该<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/Event-type.html">type property</a>持有当前被处理的<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/Event-type.html">EventType</a>。</p>
<p>以下是不同事件的概述：</p>
<ul>
<li><strong>Mouse events</strong> 例如MouseDown，MouseUp，MouseMove（<strong>仅限Editor</strong>），MouseDrag，ScrollWheel。我应该补充一点，Unity将在移动触摸设备上模拟这些事件。它通过获取所有触摸的算术平均值来计算鼠标位置。</li>
<li><strong>Keyboard events</strong> 例如KeyDown和KeyUp。注意：与Input.GetKeyDown/Up不同，这些事件映射操作系统的键盘事件。因此，当您按住某个键时，系统将一直触发按键事件。对于文本编辑类的GUI，这很重要。</li>
<li><strong>Layout event</strong> 这是一个特殊事件，始终在所有其他事件之前执行，并用于确定自动布局控件的大小和位置。注意：可以使用<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/MonoBehaviour-useGUILayout.html">useGUILayout</a>禁用此事件，但请记住，在这种情况下，所有GUILayout内容均无法使用。</li>
<li><strong>Repaint event</strong> 该事件实际上将绘制GUI元素。</li>
<li><strong>Used event</strong> 任何在处理事件时不希望其他人获得此事件的控件都可以使用<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/Event.Use.html">Use function</a>来“吃掉”该事件。调用Use时，事件类型将设置为Used，并且每个控件都应该忽略此事件。</li>
</ul>
<p>除了事件类型之外，它还包含事件的其他信息。</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/Event-mousePosition.html">mousePosition</a> <strong>GUI坐标系中</strong>的鼠标位置。GUI坐标系不同于屏幕坐标。该GUI的原点在<strong>左上角</strong>，屏幕坐标的原点在<strong>左下角</strong>。<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUIUtility.html">GUIUtility class</a>提供这些坐标转换的功能。</li>
<li><a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/Event-button.html">button</a> 仅对鼠标事件有效，并包含鼠标按钮索引（0-左按钮，1-右按钮，2-中间按钮）</li>
<li><a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/Event-modifiers.html">modifier</a> 有关Shift，Alt和Ctrl键的信息</li>
<li><a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/Event-keyCode.html">keyCode</a> 仅对键盘事件有效。持有按下/释放的键的<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/KeyCode.html">KeyCode</a>。</li>
<li>其他，例如修饰键的快捷键。</li>
</ul>
<h1>GUIStyle</h1>
<p>如前所述，该类负责向屏幕渲染控件。当“检测到”repaint事件时，GUI控件函数将调用<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUIStyle.Draw.html">Draw functions</a>之一。一个GUIStyle可以包含3个<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUIStyleState.html">GUIStyleStates</a>（截至Unity 2020.3 LTS），但在同一时间，只有一个是“有效的”。使用哪种状态取决于调用什么Draw函数，传递哪些参数以及控件当前是否具有<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUIUtility-keyboardControl.html">keyboard focus</a>。</p>
<p>绘制单个GUIStyle时，它可以产生0到3个draw call。这就是为什么非常复杂的GUI被认为不利于移动开发的原因，但是我们在Android和iOS上大量使用了GUI系统，在很多的现代设备上也没有太多问题。</p>
<p>GUIStyle可以绘制的内容是：</p>
<ul>
<li>GUIStyleState的background。通常用于定义按钮/文本字段/ …的大致外观。如果设置了background，则始终先绘制background。</li>
<li>在GUIContent class中定义的内容图像。</li>
<li>在GUIContent class中定义的内容文本。</li>
</ul>
<p>在GUIStyle中定义的<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/ImagePosition.html">ImagePosition</a>，可以用于标识图片相对于文本的位置，或者只绘制图片而忽略文本。</p>
<p>GUIStyle具有8个<a target="_blank" rel="noopener" href="http://docs.unity3d.com/ScriptReference/GUIStyleState.html">GUIStyleState</a>，其中每个状态都允许您指定background以及textcolor。注意：仅当状态具有background时，才能使用该State。因此，不幸的是，仅设置没有background的textcolor是不可能的。</p>
<p>不同的状态是：</p>
<ul>
<li>normal</li>
<li>hover</li>
<li>active</li>
<li>focused</li>
<li>onNormal</li>
<li>onHover</li>
<li>onActive</li>
<li>onFocused</li>
</ul>
<p><strong>normal</strong> 是大多数情况下使用的样式状态。例如，Label将仅使用此状态。<br>
<strong>hover</strong> 可被buttons，toggles以及绝大多数可以互动的控件，当你将鼠标悬停在控件上时会使用此State<br>
<strong>active</strong> 这是按下按钮的状态。当你鼠标单击并按住元素时就会使用此State<br>
<strong>focused</strong> 当编辑器处于活动状态时并且您可以编辑文本时，TextFields和TextAreas将使用此State</p>
<p>所有的<strong>onXXX</strong>状态与上面的其他4个功能具有相同的功能，但他们时用于具有“on”状态的控件（如Toggle）的。如果Toggle处于未选中状态，然后单击它，您将看到<em>active</em>状态。当Toggle已被选中时，您将看到<em>onActive</em>状态。</p>
<p>如上所述，没有background的state将被忽略。因此，如果您的按钮样式具有带有纹理的“normal”和“active”状态，但没有hover状态，则当您将鼠标悬停在按钮上时，Unity将使用normal状态。如果只想在悬停时更改textcolor，则必须为“hover”使用与“normal”相同的background，否则hover state将被忽略。</p>
<p>最后一点：Unity实现了一个隐式转换运算符，它将使用当前GUISkin的<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUISkin.GetStyle.html">GetStyle</a>函数自动将字符串转换为GUIStyle。</p>
<h1>GUISkin</h1>
<p>如上所述，GUISkin只是GUIStyles的集合。与GUIStyles不同，GUISkin可以<em>轻松</em>地作为资产存储在项目中。您可以在“Assets/Create”菜单中创建一个。</p>
<p>要使用GUISkin，只需在绘制控件之前将其赋值给GUI.skin。通常的方法是将赋值放在OnGUI的顶部。每次调用OnGUI时都必须对它赋值。该赋值仅对OnGUI的当前执行有效。如果还要在其他脚本中使用这个skin，则也必须将赋值也放置在这些脚本中。</p>
<p>大多数控件都有可选参数来指定应用于绘制控件的GUIStyle。在这里，您可以简单地使用一个字符串（由于隐式转换），并使用要使用的样式的名称。如果未传递任何样式，则每个内置控件均具有其自己的默认样式。</p>
<h1>Control functions</h1>
<p>上述类定义了GUI系统的基础。它们可以用于创建自定义控件，也可以以某种方式直接使用。</p>
<p>但是，Unity提供了预制的<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUI.html">控制功能</a>，大大简化了用法。例如<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUI.Button.html">button</a>功能。它使用默认样式“button”将其自身绘制到屏幕上。此函数还处理MouseDown和MouseUp事件。它使用控件Rect来确定鼠标的位置是否在Rect内，并使其自身成为<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUIUtility-hotControl.html">hotControl</a>。该函数返回一个布尔值，该值始终为false，除了在MouseUp事件中其作为hotControl并且鼠标在其Rect范围中释放的时候。</p>
<p>这就是将click事件传递回调用方的方式。</p>
<p>某些控件（例如，scrollbars和sliders）使用多个GUIStyle。它们通常具有一个主要样式和其他“子样式”，这些样式是通过在主要样式的名称中添加一些内容来确定的。horizontalScrollbar实际上是在内部执行此操作：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GUI.skin.GetStyle(style.name + <span class="string">"thumb"</span>)</span><br><span class="line">GUI.skin.GetStyle(style.name + <span class="string">"leftbutton"</span>)</span><br><span class="line">GUI.skin.GetStyle(style.name + <span class="string">"rightbutton"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>获得其他样式。这是次优的方式，因为您没有scrollbars功能（或<a target="_blank" rel="noopener" href="http://ilspy.net/">反射器</a>）的源代码。</p>
<h1>GUI与GUILayout</h1>
<p>有些讨厌GUILayout，有些喜欢它。就个人而言，即使有时候有些棘手，我还是非常喜欢它，从长远来看，它要容易得多。</p>
<p>基本上，GUILayout只是GUI控件的扩展。大多数GUILayout函数仅调用等效的GUI函数，但在其周围添加layout。“正常” GUI功能完全忽略Layout事件。GUILayout函数使用内部系统来构建布局组，这些布局组在Layout事件期间以及调用Repaint事件之前将所有控件收集到一个组中，Unity根据每个控件所请求的空间来分配可用空间。</p>
<p>以下是有关GUILayout的基本信息：</p>
<ul>
<li>基本上，GUI中存在的所有控件的确也存在于GUILayout中，但是它们缺少通常在其中指定其位置和大小的position参数。</li>
<li>所有内置的GUILayout控件只是使用了许多<a target="_blank" rel="noopener" href="http://docs.unity3d.com/ScriptReference/GUILayoutUtility.GetRect.html">GUILayoutUtility.GetRect</a>的重载来为控件保留一个Rect。layout控件只是从layout系统中获取一个rect，<a target="_blank" rel="noopener" href="http://xn--rectGUI-cx3k295bf45bwo1al5jpnem2ufy2dwna.XXX">然后调用与该rect等效的GUI.XXX</a>。</li>
<li>GUI的position对位GUILayout函数末尾的变长参数数组，可让您添加一个或多个“<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUILayoutOption.html">GUILayoutOptions</a>”。这些选项“对象”不能直接创建。Unity已实现了初始化此类实例并返回它的函数。这些“选项”用于覆盖某些GUIStyle设置，例如拉伸，固定尺寸，最小和最大尺寸。</li>
<li>GUI的<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUI.BeginGroup.html">GUI Groups</a>对位GUILayout的<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUILayout.BeginArea.html">Areas</a>。这是唯一必须指定Rect的东西。areas无法嵌套（比如两个Area嵌套，则只渲染第一个Area的内容），因此它的Rect始终相对于屏幕。当您在一个area内时，整个布局将同样限于该屏幕区域。</li>
<li>最重要的两个函数对是<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUILayout.BeginHorizontal.html">Begin/EndHorizontal</a>和<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUILayout.BeginVertical.html">Begin/EndVertical</a> 这些<strong>可以</strong>嵌套。因此，实际布局将通过将这些组嵌套在一起来定义。</li>
<li>接下来的两个助手是<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUILayout.Space.html">Space</a>和<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUILayout.FlexibleSpace.html">FlexibleSpace</a>。空间就像控件一样，但无需绘制任何内容。它只是在当前组中保留固定数量的像素。FlexibleSpace吞噬了所有剩余的空间。通常有两种控件，“固定大小”和“<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Documentation/ScriptReference/GUIStyle-stretchWidth.html">拉伸</a>”控件。Fixedsize并不意味着他们无法更改大小。他们只是占用所需的空间。所有拉伸控件（如FlexibleSpace）将共享剩余空间并根据其内容大小进行分配。</li>
</ul>
<p>一些注意事项：<br>
horizontal和vertical布局组通常没有GUIStyle，而是纯分组元素，但是您只需在参数中指定一种样式即可将其绘制为box/button/customstyle。</p>
<p>您可以通过指定其他样式来更改元素的外观。这将显示一个类似于普通按钮的toggle：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">togglestate = GUILayout.Toggle(togglestate, <span class="string">"Toggle Text"</span>, <span class="string">"button"</span>);</span><br></pre></td></tr></tbody></table></figure>
<p><em><strong>更新（2016.02.18）</strong></em></p>
<h1>GUI（Layout）vs EditorGUI（Layout）</h1>
<p><a target="_blank" rel="noopener" href="http://docs.unity3d.com/ScriptReference/EditorGUI.html">EditorGUI</a>和<a target="_blank" rel="noopener" href="http://docs.unity3d.com/ScriptReference/EditorGUILayout.html">EditorGUILayout</a>只是GUI和GUILayout类的“扩展”，它们仅在editor脚本中可用，因为它们位于“ UnityEditor.dll”中。这两个类不能替代GUI和GUILayout。它们只是提供了其他控件，这些控件在编辑器脚本（如<a target="_blank" rel="noopener" href="http://docs.unity3d.com/ScriptReference/Editor.html">custom inspector</a>或<a target="_blank" rel="noopener" href="http://docs.unity3d.com/ScriptReference/EditorWindow.html">EditorWindows）中很有用</a>。在编辑器脚本中，普通的GUI和GUILayout控件也可以正常工作。</p>
<p><code>您无法在运行时使用EditorGUI或EditorGUILayout中的任何控件，因为它们在引擎中不存在。它们属于编辑器。</code></p>
<h3 id="Event更新">Event更新</h3>
<p>自从<a target="_blank" rel="noopener" href="http://docs.unity3d.com/Manual/UISystem.html">新的UGUI系统</a>发布以来，Event类现在具有两个附加的静态方法：</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://docs.unity3d.com/ScriptReference/Event.GetEventCount.html">Event.GetEventCount</a></li>
<li><a target="_blank" rel="noopener" href="http://docs.unity3d.com/ScriptReference/Event.PopEvent.html">Event.PopEvent</a></li>
</ul>
<p>这些与旧的GUI系统并没有真正的关系，但是一些新的GUI行为脚本使用它们来处理输入事件。这些方法使您可以处理事件队列中等待当前帧的所有事件。它将返回与发送到OnGUI的事件相同的事件，只是它仅返回输入事件。因此，不会生成布局或重绘事件。</p>
<p>您自己使用它们时必须小心。一旦从队列中“弹出”事件，该事件就消失了。每个事件在队列中仅存在一次。因此，如果两个脚本试图以这种方式读取事件，则它将无法正常工作，因为第一个脚本会将事件从队列中删除。</p>
<p><em><strong>更新（2016.11.28）</strong></em></p>
<h1>幕后花絮</h1>
<h3 id="Control-IDs">Control IDs</h3>
<p>即使不是每个GUI控件都需要它们，但是它们中的大多数在内部分配了一个所谓的“Control ID”。此ID用于在多个OnGUI/OnInspectorGUI调用之间标识某个控件。控件可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/GUIUtility.GetControlID.html">GUIUtility.GetControlID</a>为其自身分配一个或多个Control ID 。该方法采用一些应该有帮助的参数，以便每个控件始终获得相同的ID。为此，可以传递一个任意的“Hash”值（和int值），该值应表示控件的“类型”。通常，大多数控件使用基于某些字符串常量的缓存的哈希码：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">int</span> m_MyControlHash = <span class="string">"MyControlTypeNameHere"</span>.GetHashCode();</span><br></pre></td></tr></tbody></table></figure>
<p>使用此方法标识控件可以让我们几乎不会意外的选择到另一个控件。在过去的GUI.Button中，此哈希存储在内部静态“ buttonHash”变量中：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GUI.buttonHash = <span class="string">"Button"</span>.GetHashCode();</span><br></pre></td></tr></tbody></table></figure>
<p>这些ID的实际目的是跟踪控件的状态（如果需要）。</p>
<p>注意：虽然可以有条件地调用某些控件，但<strong>不要</strong>在Layout事件和后续事件之间更改控件的数量和顺序非常重要。如上所述，OnGUI处理的每个事件始终与一直在实际事件之前出现的Layout事件配对。如果您在两者之间进行更改，则会使布局系统混乱，并可能“破坏”controlID堆栈。请记住，controlID是在每个OnGUI调用中生成的。因此，每次调用OnGUI时，Unity都会从一个空堆栈开始，它会根据已传递的不同“hints”，尝试将生成的ID与旧堆栈中的ID进行匹配。</p>
<h3 id="hotControl和keyboardControl">hotControl和keyboardControl</h3>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/GUIUtility-hotControl.html">GUIUtility.hotControl</a>和<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/GUIUtility-keyboardControl.html">GUIUtility.keyboardControl</a>可以标记控件的特殊状态。两者都是公共静态int字段，任何控件都可以读取或写入。两者都用于保存当前“hot”或当前具有键盘焦点的控件的controlID。大多数按钮，textField等可点击控件都使用hotControl。该过程通常如下：</p>
<ul>
<li>当收到MouseDown事件，并且hotControl当前为“0”时，控件可能要检查鼠标是否在其Rect/clickable区域上方，如果是这种情况，它将hotControl为它的ControlID。这样可以防止其他控件对某些事件做出反应，因为它们还会根据hotControl变量检查它们的ControlID。</li>
<li>稍后收到MouseUp事件时，控件将检查自身当前是否为hotControl。在这种情况下，它将把hotControl重置为“0”。这很重要，因为仅当hotControl为0时才“允许”控件将hotControl值设置为自身的ControlID（译者注，也就是说允许自身或其他控件成为hotControl）。按钮通常会重复进行区域检查，并且如果两者都为true，则按钮为hotControl的并且鼠标仍位于按钮上方，控件将返回“true”，这将导致执行使用按钮的if块。</li>
</ul>
<p>类似的过程用于keyboardControl。虽然通常不会在MouseUp上重置它，但是当鼠标不再位于控件区域内时在MouseDown上重置它。</p>
<h3 id="GetTypeForControl">GetTypeForControl</h3>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Event.GetTypeForControl.html">Event.GetTypeForControl</a>基本上与<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Event-type.html">Event.type</a>属性相同，但是会基于实际发生的事件以及hotControl和keyboardControl的状态应用一些过滤。如果没有控件处于hotControl，则它基本上返回未经过滤的当前事件。这使每个控件都有机会使其首先变为hotControl。设置hotControl后，“GetTypeForControl”仅在传递的控件ID当前为hotControl或具有键盘焦点时才返回事件。hotControl主要过滤鼠标事件，而KeyboardControl过滤按键事件。好吧，这很明显，对^^。</p>
<h3 id="GetStateObject">GetStateObject</h3>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/GUIUtility.GetStateObject.html">GUIUtility.GetStateObject</a>方法的工作方式有点奇怪。尚不清楚Unity如何真正跟踪所涉及的对象以及是否在一段时间后将其删除，但是在某些情况下它还是很有用的。</p>
<p>那么它是做什么的。此方法能够为您创建一个任意的类实例，并将该对象链接到给定的控件ID。该类实例将继续存在。请注意，该类必须是普通类，即不是MonoBehaviour或ScriptableObject派生类。它还需要有一个无参数的构造函数，以便GetStateObject可以创建一个实例。您可能还记得，只要不声明任何参数化的构造函数，每个类默认都会自动具有一个无参数的构造函数。</p>
<p>这些“状态类”用于保存每个控制实例的自定义状态信息，这些信息需要传递到下一个OnGUI调用。在示例中，我记得是GUI.DragWindow控件。是的，它也是一个控件并分配控件ID，即使它不是“可视”控件也是如此。过去，DragWindow使用一个小的内部类（GUI.DragWindowState）来保存初始窗口rect和一个偏移量Vector2，以便可以正确计算拖动运动。</p>
<p>TextField还使用TextEditor类的实例，该实例比状态类仅多一点。实际上，TextEditor类内部实现了很多内容，比如我们输入的文本，编辑位置等。因此，它可以处理按键，使用箭头键移动光标，处理文本选择，…</p>
<h3 id="SceneView">SceneView</h3>
<p>对于编辑器编程，SceneView是功能最强大的工具之一，但是正确处理它也有些棘手。通常，有两种方法可以在SceneView中绘制或处理GUI事件：</p>
<ul>
<li>活动的CustomEditor（custom inspector）可以实现一种称为<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Editor.OnSceneGUI.html">OnSceneGUI</a>的方法。</li>
<li>任何其他编辑器类（例如EditorWindows或标记有InitializeOnLoad的类）都可以将方法委托给静态<code>SceneView.onSceneGUIDelegate</code>。</li>
</ul>
<p>Unity编辑器的每个实际window都有其自己的图形上下文，并且所有内容都由IMGUI系统驱动。Unity主编辑器窗口中只有很少的内容是用native代码（例如主菜单）实现的。</p>
<p>因此，一旦有了SceneView的实际回调，您就可以做任何您想做的事情。与普通的EditorWindows（inspector, hierarchy, project面板）不同，SceneView通常使用3d投影并使用相机绘制大多数内容。由于这种2d /3d混合状态，因此场景视图中的工作方式与其他EditorWindows有所不同。</p>
<p>通常，您在SceneView内部处理3d坐标，因此对于大多数事情而言，所有GUI控件都非常无用。这就是为什么有<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Handles.html">Handles class</a>的原因。SceneView和Handles类属于彼此（译者注，难听点叫耦合）。它提供了一些3d控件，例如PositionHandle，FreeMoveHandle，ScaleSlider和RadiusHandle等。</p>
<p>即使场景视图主要是3d上下文，您仍然可以在场景视图中使用普通的2d GUI，但是您必须在Handles.BeginGUI（）和Handles.EndGUI（）之间包装2d gui内容。这使您可以直接在SceneView内部显示和GUI控件。一个非常重要的方法位于HandleUtility类中，称为WorldToGUIPoint。它一次完成所有讨厌的转换（3d-&gt; screenspace-&gt; guispace-&gt;当前cliparea）。GUIPointToWorldRay与之相反。那里还有许多其他有用的方法，但这当然取决于需求。即使绘制2d控件也是可能的，您也应该尽量避免使用它。设置和选项应显示在inpector中或单独的EditorWindow中。</p>
<h3 id="Tools">Tools</h3>
<p>当您想实现自己的工具以某种方式编辑场景时，这是一个非常重要的小类。它提供的功能不多，但控制着一项重要功能。静态<code>Tools.current</code>属性是类型为“工具”的枚举。工具目前定义了这些值：<code>View, Move, Rotate, Scale, Rect, None</code>。这些应该是熟悉的，因为它们是编辑器中的标准工具，可以使用左上方的工具按钮进行切换。对我们而言，唯一真正重要的价值是“None”。将Tools.current设置为Tool.None会禁用所有默认工具，使您可以实施自己的工具。地形Inspector也是如此。当您在Inspector中选择一种“painting mode”时，您可能会注意到，左上方的所有工具按钮都将被切换为“关闭”。这意味着当前工具为“None”。</p>
<p>实现自己的工具时，您最可能需要的另一重要事项是防止取消选择当前对象。这是通过分配一个被动控件id并将其传递给 <code>HandleUtility.AddDefaultControl</code>：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> myID = GUIUtility.GetControlID(FocusType.Passive);</span><br><span class="line">HandleUtility.AddDefaultControl(myID);</span><br></pre></td></tr></tbody></table></figure>
<p>待续 …</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="www.lfzxb.top">烟雨迷离半世殇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.lfzxb.top/unity-editor-crash-course/">https://www.lfzxb.top/unity-editor-crash-course/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.lfzxb.top" target="_blank">登峰造极者，殊途亦同归。</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity%E6%8A%80%E6%9C%AF/">Unity技术</a><a class="post-meta__tags" href="/tags/%E7%BC%96%E8%BE%91%E5%99%A8%E6%8B%93%E5%B1%95/">编辑器拓展</a><a class="post-meta__tags" href="/tags/%E5%B7%A5%E5%85%B7%E5%BC%80%E5%8F%91/">工具开发</a></div><div class="post-share"><div class="social-share" data-image="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/202509232351560.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>想吃fvcking crazy thrusday</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175314.png!webp" target="_blank"><img class="post-qr-code-img" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175314.png!webp" alt="微信" loading='lazy'></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175304.png!webp" target="_blank"><img class="post-qr-code-img" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175304.png!webp" alt="支付宝" loading='lazy'></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><div class="ads-wrap"><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7235595771604497" data-ad-slot="9104433828"></ins><script> (adsbygoogle = window.adsbygoogle || []).push({});</script></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/screen-space-plana-reflection-in-urp-study/" title="URP下屏幕空间平面反射（ScreenSpacePlanarReflection）学习笔记"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210907132640.jpg!webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post" loading='lazy'><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">URP下屏幕空间平面反射（ScreenSpacePlanarReflection）学习笔记</div></div><div class="info-2"><div class="info-item-1">前言 继续学习Colin大神的渲染示例库，这次学习的是屏幕空间平面反射（ScreenSpacePlanarReflection），一个可以用在移动端的平面反射库，但是对图形API有要求，PC/console/vulkan android/Metal iOS，OSX，因为其中用到了Compute Shader加速计算。项目还对不同平台做了差异化处理，干货很多。 学习过程中我也有很多疑问，有一些是百度谷歌看PPT解决的，有一些就实在不知道怎么办了，在文中有说明，望知道的大佬能不吝赐教。 正文 Compute Shader 简单来说Compute Shader是运行在GPU中的计算管线中的程序，其与渲染管线相互独立，旨在将任务切分成一个个运行单元，然后充分利用GPU的并行计算能力来提高目标的运行效率，也是现代GPGPU（General Purpose Computing on GPU）的基石。 其应用起来的相关概念用一张图即可概括（有一说一这张图感觉比NVIDIA的好看和明了多了，AMD YES！）：  有关Compute Shader的更多内容参见：知乎文章：Compute Shad...</div></div></div></a><a class="pagination-related" href="/unity-editor-expand-wiki-open-sources/" title="Unity编辑器拓展Wiki开源项目，装得下，世界都是你的"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210908115020.png!webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post" loading='lazy'><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Unity编辑器拓展Wiki开源项目，装得下，世界都是你的</div></div><div class="info-2"><div class="info-item-1">前言 在座的各位，凡是做过Unity编辑器拓展的都知道其知识十分零散和细碎，如果平时没有积累和记录的话，制作一个工具往往需要百度谷歌很多次去查找某个实现，可以说异常折磨，我之前有写过一篇比较宏观的编辑器拓展总结：https://www.lfzxb.top/unity-editor-extension-base/ ，但也只是提供了一个大致的方向，涉及更加详细的实现却没有提及，这也不是我不想写，编辑器UI千变万化，雀食是没有办法用一篇文章全写下来。 我们仔细思考开发编辑器UI这个过程，我们得到了什么？ 不，我们什么都没有得到，这种知识可以说不具备任何的迁移运用特性，雀食是这样的，我在学校写了一年的Unity编辑器拓展，在实习的时候写UE4的Slate直接麻了（当然也不排除是Slate过于博大精深导致的，懂得都懂，不懂的说了也不懂，利益相关，写完文章再匿了）。 凑巧，前几天一位朋友 @马三小伙儿 做了一次技术分享，就是将常用的编辑器拓展功能全部整合在一个仓库了，随用随取。仓库地址：https://github.com/XINCGer/UnityToolchainsTrick ，目前这个...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/odin-usualuse/" title="Odin常用功能整理"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210916151901.png!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-08-18</div><div class="info-item-2">Odin常用功能整理</div></div><div class="info-2"><div class="info-item-1">视频：   正文 特性效果预览 新版本Odin提供一个AttributeOverView EditorWindow，专门用于预览各个特性的效果 通过Tools-Odin Inspector-Attribute Overview即可打开：  PropertyTree 一个超级厉害的属性树，可以支持任意类型（如果一些字段类型无法绘制，则需要添加ShowOdinSerializedPropertiesInInspector字段到根class上）在任意位置上的序列化显示，例如 123TargetData targetData = new TargetData();PropertyTree tree =  PropertyTree.Create(targetData);tree.Draw(false); 另外也可以参考xNode的EditorWindow中的节点，也是这样实现的：  需要注意的是，这个PropertyTree并不会帮我们永久化数据，虽然他内部使用了SO实现，但是仅仅是内存中的，并不会保存到文件，所以临时的绘制可以用任意类，要求持久化的就必须是继承自SO的类。 如果想要针对每...</div></div></div></a><a class="pagination-related" href="/unity-editor-expand-wiki-open-sources/" title="Unity编辑器拓展Wiki开源项目，装得下，世界都是你的"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20210908115020.png!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-04-20</div><div class="info-item-2">Unity编辑器拓展Wiki开源项目，装得下，世界都是你的</div></div><div class="info-2"><div class="info-item-1">前言 在座的各位，凡是做过Unity编辑器拓展的都知道其知识十分零散和细碎，如果平时没有积累和记录的话，制作一个工具往往需要百度谷歌很多次去查找某个实现，可以说异常折磨，我之前有写过一篇比较宏观的编辑器拓展总结：https://www.lfzxb.top/unity-editor-extension-base/ ，但也只是提供了一个大致的方向，涉及更加详细的实现却没有提及，这也不是我不想写，编辑器UI千变万化，雀食是没有办法用一篇文章全写下来。 我们仔细思考开发编辑器UI这个过程，我们得到了什么？ 不，我们什么都没有得到，这种知识可以说不具备任何的迁移运用特性，雀食是这样的，我在学校写了一年的Unity编辑器拓展，在实习的时候写UE4的Slate直接麻了（当然也不排除是Slate过于博大精深导致的，懂得都懂，不懂的说了也不懂，利益相关，写完文章再匿了）。 凑巧，前几天一位朋友 @马三小伙儿 做了一次技术分享，就是将常用的编辑器拓展功能全部整合在一个仓库了，随用随取。仓库地址：https://github.com/XINCGer/UnityToolchainsTrick ，目前这个...</div></div></div></a><a class="pagination-related" href="/unity-editor-extension-base/" title="Unity编辑器拓展基础总结"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages/20200925144255.png!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-04-18</div><div class="info-item-2">Unity编辑器拓展基础总结</div></div><div class="info-2"><div class="info-item-1">前言 从事Unity编辑器拓展也有一段时间了，该记录一下常见的知识点了，也方便自己日后查阅 结构 Unity编辑器拓展主要分为3大类  UnityEngine.GUI：可用于编辑器和运行时，需要自行计算Rect UnityEditor.EditorGUI：只可用于编辑器，需要自行计算Rect UnityEditor.EditorGUILayout：只可用于编辑器，自动计算Rect  其中UnityEditor.EditorGUILayout基于UnityEditor.EditorGUI实现 常见类 Rect 这个类型在编辑器拓展中十分常见，官方解释为  A 2D Rectangle defined by X and Y position, width and height. 一个由X，Y坐标，width，height宽高定义的2D矩形  其以左上角为坐标原点，X往右递增，Y往下递增 更加详细介绍可参照：Unity Rect官方文档 GUIContent GUIContent定义了一个GUI Item内容，最完整的构造函数如下 12//构建同时包含文本，图片和定义的tooltip的...</div></div></div></a><a class="pagination-related" href="/unity-resource-batch-editor-expansion-technology-summary/" title="Unity资源批处理编辑器工具技术概要"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/202509232351560.webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2020-06-19</div><div class="info-item-2">Unity资源批处理编辑器工具技术概要</div></div><div class="info-2"><div class="info-item-1">前言 我们在项目中往往有大量的美术资源，包括但不限于，贴图，模型，动画等，而我们基本上很多资源都是应用的同一套导入配置，如果人为来进行配置的话会非常麻烦，还很容易出错，所以需要一个工具来处理他们导入时的配置，以及已经存在于项目中的资源进行批量配置。 正文 每个资源的AssetImporter面板设置下文统称为规则 技术概要  首先是应用规则匹配机制的制定，一般有文件夹，文件夹+文件部分关键字两种匹配机制。 Unity提供了一个AssetPostprocessor类支持我们进行资源导入的预处理和后处理操作。 我们的每个规则必须对应一个临时文件，用于存储规则来进行批处理。 对于导入资源的规则赋值我们采用反射的方式，但是请注意剔除引用类型和保留部分枚举类型。 对于贴图类型，比较特殊，他有对每个平台的差异化配置，而这一类型又是引用类型，所以对此只能单独处理，采用GetPlatformTextureSettings方法来对不同平台设置进行获取，通过SetPlatformTextureSettings来对不同平台进行设置。 配置好之后请务必调用assetImporter.SaveAndRei...</div></div></div></a><a class="pagination-related" href="/a-visual-tool-for-npbahave/" title="为NPBehave而生的可视化编辑器介绍"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/01/QQ截图20200125144426.png!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-01-01</div><div class="info-item-2">为NPBehave而生的可视化编辑器介绍</div></div><div class="info-2"><div class="info-item-1">介绍 什么是NPBehave？https://www.lfzxb.top/npbehave_doc/ 使用到的库 ET：一个基于C#的游戏客户端，服务端框架！ Node_Editor_Framework：一个强大的可视化工具！ Odin：Unity编辑器拓展神器！ 编辑器截图 这是一个官方例子的可视化版本  支持导出配置文件，供客户端或者服务端读取  运行结果与官方示例一致  使用方法 1.在Unity编辑器的菜单栏，选择Tools/其他实用工具/多功能可视化编辑器即可进入编辑界面 2.然后这样可以创建一个Canvas  3.随便找个空地进行右击  4.鼠标左键点击某一个数据结点即可在Inspector面板显示其包含的数据  5.然后按照自己想要的结果把他们连接起来 6.鼠标左键点击一个空地，即可调出导出配置界面，然后即可进行导出工作。 7.最后在代码里创建自己想要的行为树，Start即可，其中的ID即为我们导出配置时上面显示的根节点ID！ 12NP_RuntimeTree npRuntimeTree = NP_RuntimeTreeFactory.CreateNpRuntime...</div></div></div></a><a class="pagination-related" href="/box2d-collisionrelationvisualeditor/" title="Box2D篇：碰撞关系可视化编辑器"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ截图20190801215422.png!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2019-08-01</div><div class="info-item-2">Box2D篇：碰撞关系可视化编辑器</div></div><div class="info-2"><div class="info-item-1">前言 我们在游戏中难免会有碰撞检测然后进行处理这一需求，那么，错综复杂的碰撞关系无疑就成了一大设计难点，规模和数量少点还好说，直接写在代码即可，规模一大，就需要借助excel的帮助下，但是也免不了使用true/false作为标识，在修改，拓展的时候麻烦，在读取数据的时候会造成不必要的空间浪费。（我明明没可能和这个东西碰撞，为什么还要单独给他一个bool字段呢？）。所以我就想着，能不能做个东西，稍微缓解一下这个问题，于是就有了今天这篇文章。 相关知识点  Node_Editor_Framework，开源地址:https://github.com/Seneral/Node_Editor_Framework Odin相关特性 Bson序列化反序列化数据  正文 先放一张编辑器图片  这就是使用了Node_Editor_Framework的编辑器，我们可以看到，在里面对不同的碰撞体进行了分组（分类）操作，然后根据需求进行连线即可。 至于数据的处理，我提供了很多一键傻瓜式按钮，只需要点一下就行。 创建数据  首先是Create Group，此操作将会创建一个Group，所有在此Group中...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">2.</span> <span class="toc-text">OnGUI</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">3.</span> <span class="toc-text">The Event class</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">4.</span> <span class="toc-text">GUIStyle</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">5.</span> <span class="toc-text">GUISkin</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">6.</span> <span class="toc-text">Control functions</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">7.</span> <span class="toc-text">GUI与GUILayout</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">8.</span> <span class="toc-text">GUI（Layout）vs EditorGUI（Layout）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Event%E6%9B%B4%E6%96%B0"><span class="toc-number">8.0.1.</span> <span class="toc-text">Event更新</span></a></li></ol></li></ol><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">9.</span> <span class="toc-text">幕后花絮</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Control-IDs"><span class="toc-number">9.0.1.</span> <span class="toc-text">Control IDs</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hotControl%E5%92%8CkeyboardControl"><span class="toc-number">9.0.2.</span> <span class="toc-text">hotControl和keyboardControl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetTypeForControl"><span class="toc-number">9.0.3.</span> <span class="toc-text">GetTypeForControl</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GetStateObject"><span class="toc-number">9.0.4.</span> <span class="toc-text">GetStateObject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SceneView"><span class="toc-number">9.0.5.</span> <span class="toc-text">SceneView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tools"><span class="toc-number">9.0.6.</span> <span class="toc-text">Tools</span></a></li></ol></li></div></div></div></div></main><footer id="footer" style="background-image: url(https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/20210912135042.png!webp);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">©&nbsp;2025 By 烟雨迷离半世殇</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">2018-2025 lfzxb.top版权所有<br><span id="realtime_duration"></span><br><a href="https://beian.miit.gov.cn" target="_blank">苏ICP备19003389号-1</a><br><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/20210912135040.png!webp" alt="公网安备字" loading='lazy'><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=32032102000159" target="_blank">苏公网安备 32032102000159号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="fluid-control-btn" type="button" title="流体模拟控制台"><i class="fas fa-water"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '508db6cacf197b7363d1',
      clientSecret: '2882a0b135eaa72b3ab256e37249c50733ce9e91',
      repo: 'wqaetly',
      owner: 'wqaetly',
      admin: ['wqaetly'],
      updateCountCallback: commentCount,
      proxy: "https://strong-caramel-969805.netlify.app/github_access_token",
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '336ebbb8452b2ac7df047eaf9b15a72c'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/dayjs/dayjs.min.js"></script><script src="https://cdn.jsdelivr.net/npm/dayjs/plugin/duration.min.js"></script><script src="/js/realtime.js"></script><script>window.FLUID_CONFIG={enable:true,mobile:false,z_index:-1,SIM_RESOLUTION:128,DYE_RESOLUTION:1024,DENSITY_DISSIPATION:1,VELOCITY_DISSIPATION:0.2,PRESSURE:0.8,PRESSURE_ITERATIONS:20,CURL:30,SPLAT_RADIUS:0.25,SPLAT_FORCE:6000,SHADING:true,COLORFUL:true,COLOR_UPDATE_SPEED:10,PAUSED:false,BACK_COLOR:{r:0,g:0,b:0},TRANSPARENT:false,BLOOM:true,BLOOM_ITERATIONS:8,BLOOM_RESOLUTION:256,BLOOM_INTENSITY:0.8,BLOOM_THRESHOLD:0.6,BLOOM_SOFT_KNEE:0.7,SUNRAYS:true,SUNRAYS_RESOLUTION:196,SUNRAYS_WEIGHT:1.0,interaction:{enable:true}};</script><script src="/js/fluid-simulation/dat.gui.min.js"></script><script src="/js/fluid-simulation/fluid-core.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'D3U85CARGJ',
    apiKey: '3edfc5bada9a140d5a4126085596f99c',
    indexName: 'blogsearch',
    container: '#docsearch',
    placeholder: '搜索文章',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div>
    <link rel="stylesheet" href="https://ai.tianli0.top/static/public/postChatUser_summary.min.css">
    <script>
        let tianliGPT_key = 'S-TY6LYYCZMYV6UADE';
        let tianliGPT_postSelector = '#article-container';
        let tianliGPT_Title = '烟雨迷离半世殇（人机版）为您总结文章';
        let tianliGPT_postURL = 'https://www.lfzxb.top/*/';
        let tianliGPT_blacklist = '';
        let tianliGPT_wordLimit = '50000';
        let tianliGPT_typingAnimate = false;
        let tianliGPT_theme = 'menghuan';
        var postChatConfig = {
          backgroundColor: "#3e86f6",
          bottom: "16px",
          left: "16px",
          fill: "#FFFFFF",
          width: "44px",
          frameWidth: "375px",
          frameHeight: "600px",
          defaultInput: false,
          upLoadWeb: true,
          showInviteLink: true,
          userTitle: "烟雨迷离半世殇（人机版）为您服务",
          userDesc: "在下定知无不言",
          addButton: true,
          beginningText: "这篇文章介绍了",
          userIcon: "https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp",
          userMode: "magic",
          defaultChatQuestions: ["你好","你是谁"],
          defaultSearchQuestions: ["视频压缩","设计"]
        };
    </script>
    <script data-postchat_key="S-TY6LYYCZMYV6UADE" src="https://ai.tianli0.top/static/public/postChatUser_summary.min.js"></script>
  </body></html>