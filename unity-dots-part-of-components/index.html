<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity DOTS：Components部分 | 登峰造极者，殊途亦同归。</title><meta name="author" content="烟雨迷离半世殇"><meta name="copyright" content="烟雨迷离半世殇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="组件 Components是ECS体系结构的三个主要元素之一。它们代表您的游戏或应用程序的数据。Entities是索引您的components集合的标识符，而systems提供了行为。 ECS中的Components是具有以下“标记接口”之一的结构体类型：  IComponentData —用于通用和[chunk components]。 IBufferElementData —将[动态缓冲区（d">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity DOTS：Components部分">
<meta property="og:url" content="https://www.lfzxb.top/unity-dots-part-of-components/index.html">
<meta property="og:site_name" content="登峰造极者，殊途亦同归。">
<meta property="og:description" content="组件 Components是ECS体系结构的三个主要元素之一。它们代表您的游戏或应用程序的数据。Entities是索引您的components集合的标识符，而systems提供了行为。 ECS中的Components是具有以下“标记接口”之一的结构体类型：  IComponentData —用于通用和[chunk components]。 IBufferElementData —将[动态缓冲区（d">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp">
<meta property="article:published_time" content="2021-02-04T00:00:00.000Z">
<meta property="article:modified_time" content="2021-02-04T00:00:00.000Z">
<meta property="article:author" content="烟雨迷离半世殇">
<meta property="article:tag" content="Unity技术">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="ECS">
<meta property="article:tag" content="Unity DOTS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Unity DOTS：Components部分",
  "url": "https://www.lfzxb.top/unity-dots-part-of-components/",
  "image": "https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp",
  "datePublished": "2021-02-04T00:00:00.000Z",
  "dateModified": "2021-02-04T00:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "烟雨迷离半世殇",
      "url": "https://www.lfzxb.top/www.lfzxb.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp"><link rel="canonical" href="https://www.lfzxb.top/unity-dots-part-of-components/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="AhlEJ91V_L12bkwRF1ZS0BbytGCfsjqCX4GXztUluC8"><meta name="baidu-site-verification" content="iRRtEBalDiujISsN"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 8
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-7235595771604497',
  enable_page_level_ads: 'true'
});</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-XSL6D8K8G2"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-XSL6D8K8G2')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-XSL6D8K8G2', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":800,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity DOTS：Components部分',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/CustomIcons/iconfontformaliyun.css"><meta name="referrer" content="no-referrer-when-downgrade"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar" loading='lazy'></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">243</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">186</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-torii-gate"></i><span> 蓬莱仙境</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-stream"></i><span> 白驹过隙</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 包罗万象</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分朋引类</span></a></div><div class="menus_item"><a class="site-page" href="/self/"><i class="fa-fw fas fa-id-card"></i><span> 择交而友</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 一见如故</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/202507052331881.png!webp" alt="Logo" loading='lazy'></a><a class="nav-page-title" href="/"><span class="site-name">Unity DOTS：Components部分</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-torii-gate"></i><span> 蓬莱仙境</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-stream"></i><span> 白驹过隙</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 包罗万象</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分朋引类</span></a></div><div class="menus_item"><a class="site-page" href="/self/"><i class="fa-fw fas fa-id-card"></i><span> 择交而友</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 一见如故</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Unity DOTS：Components部分</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-04T00:00:00.000Z" title="发表于 2021-02-04 00:00:00">2021-02-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-02-04T00:00:00.000Z" title="更新于 2021-02-04 00:00:00">2021-02-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/GamePlay/">GamePlay</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">游戏引擎</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/">Unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/GamePlay/ECS/">ECS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">7.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>30分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/unity-dots-part-of-components/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;这篇文章已经&quot;,&quot;messageNext&quot;:&quot;天没维护了，相关内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2021-02-04 00:00:00&quot;}" hidden=""></div><div id="postchat_postcontent"><h1>组件</h1>
<p>Components是ECS体系结构的三个主要元素之一。它们代表您的游戏或应用程序的数据。<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/ecs_entities.html">Entities</a>是索引您的components集合的标识符，而systems提供了行为。</p>
<p>ECS中的Components是具有以下“标记接口”之一的结构体类型：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.IComponentData.html">IComponentData</a> —用于<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/component_data.html">通用</a>和[chunk components]。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.IBufferElementData.html">IBufferElementData</a> —将[动态缓冲区（dynamic buffers）]与entities相关联。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ISharedComponentData.html">ISharedComponentData</a> —按archetype中的值对entities进行分类或分组。有关更多信息，请参见[Shared Component Data]。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ISystemStateComponentData.html">ISystemStateComponentData</a> —将特定system的状态与entity相关联，并检测何时创建或销毁单个实体。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/system_state_components.html">System State Component</a>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ISystemStateSharedComponentData.html">ISharedSystemStateComponentData</a> —共享状态和System状态 数据的组合。请参阅<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/system_state_components.html">System State Component</a>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.BlobBuilder.html">Blob assets</a> –从技术上讲，它不是“component”，但您可以使用Blob assets来存储数据。Blob assets可以由一个或多个component使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.BlobAssetReference-1.html">BlobAssetReference</a>进行引用，并且他是不可变的。您可以使用Blob assets在资产之间共享数据并访问C＃ jobs中的数据。</li>
</ul>
<p>EntityManager将components的独特组合组织到<strong>archetypes</strong>。archetypes将归属相同的archetypes的的components一起存储在称为<em>chunks</em>的内存块中。给定chunk中的entities均具有相同的components archetypes。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages/image-20200811174536423.png!webp" alt="image-20200811174536423" loading='lazy'></p>
<p>该图说明了ECS如何通过存archetypes存储components数据的chunk。<em>shared components和chunk components是例外</em>，因为ECS将它们存储在chunk外部。这些component类型的单个实例适用于他所适用的chunks中的所有entities。另外，您可以选择将dynamic buffers存储在chunk之外。即使ECS不在chunk内存储这些类型的components，您在查询entities时通常也可以将它们与其他components类型相同对待。</p>
<h1>通用组件</h1>
<p><code>ComponentData</code>在标准ECS术语中称为组件数据，是仅包含<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/ecs_entities.html">entities</a>的实例数据的结构。<code>ComponentData</code>不应包含除Utility（来访问结构中的数据的方法）功能之外的方法。您应该在systems中实现所有游戏逻辑和行为。用面向对象的Unity系统来讲，这有点类似于Component（经典挂载MonoBehaviour）类，但是<strong>只包含变量，不包含逻辑</strong>。</p>
<p>Unity ECS API提供了一个名为<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.IComponentData.html">IComponentData的接口</a>，您可以在代码中实现该接口以表示他是general components类型。</p>
<h2 id="IComponentData">IComponentData</h2>
<p>传统的Unity Component是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Object-oriented_programming">面向对象的</a>类，其中包含数据和方法。<code>IComponentData</code>是纯ECS的组件，这意味着它没有定义任何行为，仅定义了数据。您应该实现<code>IComponentData</code>为struct而不是class，这意味着默认情况下，它是<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/373419/whats-the-difference-between-passing-by-reference-vs-passing-by-value?answertab=votes#tab-top">通过值而不是通过引用</a>复制的。通常，您需要使用以下模式来修改数据：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> transform = <span class="keyword">group</span>.transform[index]; <span class="comment">// 读</span></span><br><span class="line"></span><br><span class="line">transform.heading = playerInput.move; <span class="comment">// 改</span></span><br><span class="line">transform.position += deltaTime * playerInput.move * settings.playerMoveSpeed;</span><br><span class="line"></span><br><span class="line"><span class="keyword">group</span>.transform[index] = transform; <span class="comment">// 写</span></span><br></pre></td></tr></tbody></table></figure>
<p>*<code>IComponentData</code>不得包含对托管对象的引用。*这是因为<code>ComponentData</code>存在于在没有被GC跟踪的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/chunk_iteration.html">块内存中</a>，所以具有许多性能优势。</p>
<h3 id="托管的IComponentData">托管的IComponentData</h3>
<p>使用托管形式的<code>IComponentData</code>（即，<code>IComponentData</code>声明为<code>class</code>而不是声明为<code>struct</code>）有助于将现有代码以一把梭的方式移植到ECS，<code>ISharedComponentData</code>不适合与托管数据进行交互操作或为数据布局提供原型。</p>
<p>这些托管的组件的使用方式与值类型的<code>IComponentData</code>相同。但是，ECS在内部以完全不同（且较慢）的方式来处理它们。如果不需要托管组件支持，请在应用程序的<strong>Player Settings</strong> (菜单: <strong>Edit &gt; Project Settings &gt; Player &gt; Scripting Define Symbols</strong>)）添加<code>UNITY_DISABLE_MANAGED_COMPONENTS</code>宏，以防止意外使用。</p>
<p>因为托管<code>IComponentData</code>是托管类型，所以与值类型的<code>IComponentData</code>相比，它具有以下性能缺点：</p>
<ul>
<li>不能与Burst编译器一起使用</li>
<li>不能在job结构中使用</li>
<li>它不能使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/chunk_iteration.html">chunk memory</a></li>
<li>需要被GC</li>
</ul>
<p>您应该尽量限制托管组件的数目，并且尽可能使用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/framework/interop/blittable-and-non-blittable-types">blittable</a>类型</p>
<p>托管对象<code>IComponentData</code>必须实现<code>IEquatable&lt;T&gt;</code>接口并重写<code>Object.GetHashCode()</code>。此外，出于序列化的目的，托管组件必须是默认可构造的。</p>
<p>您必须在主线程上设置托管component的值。为此，请使用 <code>EntityManager</code>或<code>EntityCommandBuffer</code>。由于托管component是引用类型，因此与<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ISharedComponentData.html">ISharedComponentData</a>不同，您可以更改组件的值而无需在chunk之间移动entities。但是这不会创建同步点。</p>
<p>但是，尽管在逻辑上将托管组件与值类型的组件分开存储，但它们仍然依托于实体的<code>EntityArchetype</code>定义。这样，向实体添加新的托管组件仍然会导致ECS创建新的archetype（如果尚不存在匹配的archetype），并将实体移至新的Chunk。</p>
<p>有关示例，请参见文件：<code>/Packages/com.unity.entities/Unity.Entities/IComponentData.cs</code>。</p>
<h1>Shared component data</h1>
<p>shared components是一种特殊的数据组件，您可以根据shared components中的特定值（但不包括他们archetype的）对entities进行细分。将shared component添加到一个entity时，EntityManager会将具有相同shared component的（struct意义上的相等）所有entities放入同一chunk中。</p>
<p>shared components使您的systems可以像entities一样一起处理。例如，shared components的<code>Rendering.RenderMesh</code>是Hybrid.rendering包的一部分，它定义了几个字段，包括<strong>mesh</strong>，<strong>material</strong>和<strong>receiveShadows</strong>。当您的应用程序渲染时，最有效的方法是一起处理所有具有相同字段值的3D对象。因为shared components指定了这些属性，所以EntityManager将与其匹配的所有entities放置在内存中，以便渲染系统可以高效地对其进行迭代。</p>
<p>**注意：**如果您过度使用共享组件，则可能导致不佳的chunk利用率。这是因为当您使用shared components时，它将触发基于archetype和每个shared components的特定字段的组合扩张。因此，请避免添加任何将实体分类到shared components中不需要的字段。要查看chunk块利用率情况，请使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/ecs_debugging.html">Entity Debugger</a>。</p>
<p>如果您从entity中添加或删除component，或更改shared component的值，则EntityManager会将entity移至其他chunk，并在必要时创建新chunk（但是和这个entity同chunk的其余entities不会变动）。</p>
<p>您应该将<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.IComponentData.html">IComponentData</a>用于存储分类不同entities的数据，例如存储世界位置，对象生命值或粒子生存时间。当许多entities共享某些共同点时，应使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ISharedComponentData.html">ISharedComponentData</a>。例如，在DOTS软件包的Boids演示中，许多entities都从同一<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/Prefabs.html">Prefab</a>实例化，结果，许多<code>Boid</code>实体之间<code>RenderMesh</code>完全相同。</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">System.Serializable</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> RenderMesh : ISharedComponentData</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> Mesh                 mesh;</span><br><span class="line">    <span class="keyword">public</span> Material             material;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ShadowCastingMode    castShadows;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">bool</span>                 receiveShadows;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>ISharedComponentData</code>在每个entity的内存成本为零（因为他是凌驾于chunk外的）。您可以使用<code>ISharedComponentData</code>将具有相同<code>InstanceRenderer</code>数据的所有entities分组在一起，然后高效地提取所有矩阵以进行渲染。代码简单有效，因为在ECS访问数据时对数据进行了布局。</p>
<p>有关此示例，请参阅<code>RenderMeshSystemV2</code>文件<code>Packages/com.unity.entities/Unity.Rendering.Hybrid/RenderMeshSystemV2.cs</code>。</p>
<h2 id="有关SharedComponentData的重要说明：">有关SharedComponentData的重要说明：</h2>
<ul>
<li>ECS将具有相同<code>SharedComponentData</code>的entities按相同的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/chunk_iteration.html">chunk</a>分组在一起。它将<code>SharedComponentData</code>的索引存储到每个chunk，而不是每个entity一次。结果就是，<code>SharedComponentData</code>对于每个entity的内存开销为零。</li>
<li>您可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityQuery.html">EntityQuery</a>遍历相同类型（components）的所有entities。您还可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityQuery.html#Unity_Entities_EntityQuery_SetSharedComponentFilter_">EntityQuery.SetFilter（）</a>专门对具有特定<code>SharedComponentData</code>值的entities进行迭代。由于数据布局的原因，这种迭代的开销很低。</li>
<li>您可以用<code>EntityManager.GetAllUniqueSharedComponents</code>用来检索<code>SharedComponentData</code>添加到任何活动实体的所有唯一性。</li>
<li>ECS会对<code>SharedComponentData</code>进行自动<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reference_counting">引用计数</a> 。</li>
<li><code>SharedComponentData</code>应该很少被改变。如果更改一个entity的<code>SharedComponentData</code>，则需要使用<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/aa246468(v=vs.60).aspx">memcpy</a>将该entity的所有<code>ComponentData</code>内容复制到另一个chunk中（或者新建的一个chunk中）。</li>
</ul>
<p>更加详细的细节，可以参照：<a target="_blank" rel="noopener" href="https://gametorrahod.com/everything-about-isharedcomponentdata/">https://gametorrahod.com/everything-about-isharedcomponentdata/</a></p>
<h1>System State Components</h1>
<p>您可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ISystemStateComponentData.html">SystemStateComponentData</a>跟踪一个system内部的资源，并根据需要创建和销毁这些资源，而无需依赖各个回调。</p>
<p><code>SystemStateComponentData</code>和<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ISystemStateSharedComponentData.html">SystemStateSharedComponentData</a>与<code>ComponentData</code>和<code>SharedComponentData</code>相似，但是ECS在销毁实体时不会删除<code>SystemStateComponentData</code>。</p>
<p>当entity被销毁时，ECS通常：</p>
<ol>
<li>查找引用特定entity的ID的所有components。</li>
<li>删除那些components。</li>
<li>回收entity的ID以供重用。</li>
</ol>
<p>但是，如果<code>SystemStateComponentData</code>存在，则ECS不会回收ID。这使system有机会清理与entity的ID相关联的任何资源或状态。ECS仅在<code>SystemStateComponentData</code>被移除后才复用实体ID。</p>
<h2 id="何时使用System-State-Components">何时使用System State Components</h2>
<p>systems可能需要保持一个基于<code>ComponentData</code>的内部状态。例如，可以分配的资源们。</p>
<p>systems还需要能够将状态作为值进行管理，其他systems可能会进行状态的更改。例如，当components中的值更改，或添加或删除相关components时。</p>
<p><code>No callbacks</code>是ECS设计规则的重要组成部分。</p>
<p><code>SystemStateComponentData</code>设计初衷是 对应一个用户组件，从而提供其内部状态。</p>
<p>例如，给定：</p>
<ul>
<li>FooComponent（<code>ComponentData</code>，用户指定）</li>
<li>FooStateComponent（<code>SystemComponentData</code>，system指定）</li>
</ul>
<h3 id="当一个component被添加时检测">当一个component被添加时检测</h3>
<p>创建一个component时，system state component并不存在。system更新查询components（并没有system state component），并可以推断components已被添加的时刻。此时，system将添加system state component和任何所需的内部状态。</p>
<h3 id="当一个component被移除时检测">当一个component被移除时检测</h3>
<p>移除component时，system state component仍然存在。system更新查询system state component（并没有components），并可以推断components已被删除的时刻。此时，system将移除system state component并修正任何需要的内部状态。</p>
<h3 id="当一个entity被销毁时检测">当一个entity被销毁时检测</h3>
<p><code>DestroyEntity</code> 是以下用途的简写程序：</p>
<ul>
<li>查找引用了指定entity ID的components。</li>
<li>删除找到的components。</li>
<li>回收entity ID。</li>
</ul>
<p>但是，在<code>DestroyEntity</code>移除最后一个component之前，都不会删除<code>SystemStateComponentData</code>，并且不会回收entity ID。这使system有机会用移除component完全相同的方式清理内部状态。</p>
<h2 id="SystemStateComponent">SystemStateComponent</h2>
<p>一个 <code>SystemStateComponentData</code>与<code>ComponentData</code>相似。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> FooStateComponent : ISystemStateComponentData</span><br><span class="line">{</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>一个<code>SystemStateComponentData</code>对于创建它的system之外的都是<code>只读的</code>。</p>
<h2 id="SystemStateSharedComponent">SystemStateSharedComponent</h2>
<p>一个 <code>SystemStateSharedComponentData</code>与<code>SharedComponentData</code>相似。</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> FooStateSharedComponent : ISystemStateSharedComponentData</span><br><span class="line">{</span><br><span class="line">  <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="一个使用state-components的示例">一个使用state components的示例</h2>
<p>以下示例展示了一个简单地system，该system说明了如何使用system state components来管理entities。该示例定义了通用IComponentData实例和系统状态ISystemStateComponentData实例。它还基于这些实体定义了三个queries：</p>
<ul>
<li><code>m_newEntities</code>会选择具有一般的component但不具有system state component的entities。该query查找system之前未见过的新enitites（因为新加了component嘛，所以就是新entity了）。system会运行一个job会对查询到的entitites添加system state component。</li>
<li><code>m_activeEntities</code>选择同时具有一般component和system state component的entities。在实际的应用程序中，其内容可能是处理或销毁entities。</li>
<li><code>m_destroyedEntities</code>选择具有system state component但不具有一般component的entities。由于system state component永远不会单独添加到entity，因此此system或其他system必须删除此query选择的entities。system重用销毁的entities query以运行job并从entities中删除system state component件，这使ECS可以回收entity ID。</li>
</ul>
<p>**注意：**此简化示例不维护系统内的任何状态。系统状态组件的目的之一是跟踪何时需要分配或清除持久性资源。</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"><span class="keyword">using</span> Unity.Collections;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> GeneralPurposeComponentA : IComponentData</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Lifetime;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> StateComponentB : ISystemStateComponentData</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> State;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StatefulSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> EntityCommandBufferSystem ecbSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        ecbSource = World.GetExistingSystem&lt;EndSimulationEntityCommandBufferSystem&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建测试用的entities</span></span><br><span class="line">        <span class="comment">// 这跑在主线程，但因为使用一个了命令缓冲区，所以还是很快</span></span><br><span class="line">        <span class="comment">// This runs on the main thread, but it is still faster to use a command buffer</span></span><br><span class="line">        EntityCommandBuffer creationBuffer = <span class="keyword">new</span> EntityCommandBuffer(Allocator.Temp);</span><br><span class="line">        EntityArchetype archetype = EntityManager.CreateArchetype(<span class="keyword">typeof</span>(GeneralPurposeComponentA));</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">        {</span><br><span class="line">            Entity newEntity = creationBuffer.CreateEntity(archetype);</span><br><span class="line">            creationBuffer.SetComponent&lt;GeneralPurposeComponentA&gt;</span><br><span class="line">            (</span><br><span class="line">                newEntity,</span><br><span class="line">                <span class="keyword">new</span> GeneralPurposeComponentA() { Lifetime = i }</span><br><span class="line">            );</span><br><span class="line">        }</span><br><span class="line">        <span class="comment">//执行命令缓冲区内容</span></span><br><span class="line">        creationBuffer.Playback(EntityManager);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        EntityCommandBuffer.ParallelWriter parallelWriterECB = ecbSource.CreateCommandBuffer().AsParallelWriter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有GeneralPurposeComponentA但没有StateComponentB的Entities</span></span><br><span class="line">        <span class="comment">// Entities with GeneralPurposeComponentA but not StateComponentB</span></span><br><span class="line">        Entities</span><br><span class="line">            .WithNone&lt;StateComponentB&gt;()</span><br><span class="line">            .ForEach(</span><br><span class="line">                (Entity entity, <span class="built_in">int</span> entityInQueryIndex, <span class="keyword">in</span> GeneralPurposeComponentA gpA) =&gt;</span><br><span class="line">                {</span><br><span class="line">                <span class="comment">// 每个entity添加一个系统状态组件实例</span></span><br><span class="line">                <span class="comment">// Add an ISystemStateComponentData instance</span></span><br><span class="line">                parallelWriterECB.AddComponent&lt;StateComponentB&gt;</span><br><span class="line">                    (</span><br><span class="line">                        entityInQueryIndex,</span><br><span class="line">                        entity,</span><br><span class="line">                        <span class="keyword">new</span> StateComponentB() { State = <span class="number">1</span> }</span><br><span class="line">                    );</span><br><span class="line">                })</span><br><span class="line">            .ScheduleParallel();</span><br><span class="line">        ecbSource.AddJobHandleForProducer(<span class="keyword">this</span>.Dependency);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个新的命令缓冲区</span></span><br><span class="line">        parallelWriterECB = ecbSource.CreateCommandBuffer().AsParallelWriter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同时拥有GeneralPurposeComponentA和StateComponentB的entities</span></span><br><span class="line">        <span class="comment">// Entities with both GeneralPurposeComponentA and StateComponentB</span></span><br><span class="line">        Entities</span><br><span class="line">            .WithAll&lt;StateComponentB&gt;()</span><br><span class="line">            .ForEach(</span><br><span class="line">                (Entity entity,</span><br><span class="line">                 <span class="built_in">int</span> entityInQueryIndex,</span><br><span class="line">                 <span class="keyword">ref</span> GeneralPurposeComponentA gpA) =&gt;</span><br><span class="line">                {</span><br><span class="line">                <span class="comment">// 处理entity，在这个例子里是减少生命时间</span></span><br><span class="line">                <span class="comment">// Process entity, in this case by decrementing the Lifetime count</span></span><br><span class="line">                gpA.Lifetime--;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果超过时间限制，就移除entity</span></span><br><span class="line">                <span class="comment">// If out of time, destroy the entity</span></span><br><span class="line">                <span class="keyword">if</span> (gpA.Lifetime &lt;= <span class="number">0</span>)</span><br><span class="line">                    {</span><br><span class="line">                        parallelWriterECB.DestroyEntity(entityInQueryIndex, entity);</span><br><span class="line">                    }</span><br><span class="line">                })</span><br><span class="line">            .ScheduleParallel();</span><br><span class="line">        ecbSource.AddJobHandleForProducer(<span class="keyword">this</span>.Dependency);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个新的命令缓冲区</span></span><br><span class="line">        <span class="comment">// Create new command buffer</span></span><br><span class="line">        parallelWriterECB = ecbSource.CreateCommandBuffer().AsParallelWriter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 有StateComponentB但没有GeneralPurposeComponentA的entities</span></span><br><span class="line">        <span class="comment">// Entities with StateComponentB but not GeneralPurposeComponentA</span></span><br><span class="line">        Entities</span><br><span class="line">            .WithAll&lt;StateComponentB&gt;()</span><br><span class="line">            .WithNone&lt;GeneralPurposeComponentA&gt;()</span><br><span class="line">            .ForEach(</span><br><span class="line">                (Entity entity, <span class="built_in">int</span> entityInQueryIndex) =&gt;</span><br><span class="line">                {</span><br><span class="line">                <span class="comment">// 这个系统有责任去移除他所添加的ISystemStateComponentData实例，否则这些entity永远不会真正的被销毁</span></span><br><span class="line">                <span class="comment">// This system is responsible for removing any ISystemStateComponentData instances it adds</span></span><br><span class="line">                <span class="comment">// Otherwise, the entity is never truly destroyed.</span></span><br><span class="line">                parallelWriterECB.RemoveComponent&lt;StateComponentB&gt;(entityInQueryIndex, entity);</span><br><span class="line">                })</span><br><span class="line">            .ScheduleParallel();</span><br><span class="line">        ecbSource.AddJobHandleForProducer(<span class="keyword">this</span>.Dependency);</span><br><span class="line"></span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnDestroy</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// 实现OnDestroy来清理被system分配的资源</span></span><br><span class="line">        <span class="comment">// Implement OnDestroy to cleanup any resources allocated by this system.</span></span><br><span class="line">        <span class="comment">// (This simplified example does not allocate any resources, so there is nothing to clean up.)</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1>Dynamic buffer components</h1>
<p>使用dynamic buffer components（动态缓冲区组件）将类似数组的数据与entity相关联。Dynamic buffers是ECS组件，可以容纳可变数量的元素，并根据需要自动调整大小。</p>
<p>要创建Dynamic buffers，请首先声明一个实现<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.IBufferElementData.html">IBufferElementData</a>的结构，并定义存储在缓冲区中的元素。例如，可以对存储整数的dynamic buffer component使用以下结构：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> IntBufferElement : IBufferElementData</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>要将dynamic buffer与entity相关联，请直接向entity添加<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.IBufferElementData.html">IBufferElementData</a>组件，而不要添加<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.DynamicBuffer-1.html">dynamic buffer container</a>本身。</p>
<p>ECS管理container。对于大多数用途，您可以使用声明的<code>IBufferElementData</code>类型将dynamic buffer与其他任何ECS component相同对待。例如，您可以<code>IBufferElementData</code>在<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityQuery.html">entity queries</a>中以及在添加或删除dynamic buffer component时使用该类型。但是，必须使用不同的函数来访问dynamic buffer component，并且这些函数提供了<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.DynamicBuffer-1.html">DynamicBuffer</a>实例，该实例为缓冲区数据提供了类似于数组的接口。</p>
<p>要为dynamic buffer component指定“internal capacity（内部容量）”，请使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.InternalBufferCapacityAttribute.html">InternalBufferCapacity Attribute</a>。内部容量定义了dynamic buffer与entity的其他component一起存储在<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ArchetypeChunk.html">ArchetypeChunk</a>中的元素数。除了内部容量之外，这个缓冲区还会在当chunk块之外分配一个堆内存块，并将所有现有元素移动到其中，ECS自动管理该外部缓冲区内存（Heap memory block），并在移除dynamic buffer component时释放他的内存。</p>
<p>**注意：**如果缓冲区中的数据不是动态的，则可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.BlobBuilder.html">Blob资产</a>代替动态缓冲区。Blob资产可以存储结构化数据，包括数组。多个entities可以共享Blob资产。</p>
<h2 id="声明缓冲区元素类型">声明缓冲区元素类型</h2>
<p>要声明缓冲区，请声明一个结构，该结构定义了要放入缓冲区的元素的类型。该结构必须实现<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.IBufferElementData.html">IBufferElementData</a>，如下所示：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 内部容量表示一个缓冲区在其本身被移出chunk之前可以容纳多少个元素（其实就是原始最大容量）</span></span><br><span class="line"><span class="comment">// InternalBufferCapacity specifies how many elements a buffer can have before</span></span><br><span class="line"><span class="comment">// the buffer storage is moved outside the chunk.</span></span><br><span class="line">[<span class="meta">InternalBufferCapacity(8)</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> MyBufferElement : IBufferElementData</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// Actual value each buffer element will store.</span></span><br><span class="line">    <span class="comment">// 每个缓冲区内的元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The following implicit conversions are optional, but can be convenient.</span></span><br><span class="line">    <span class="comment">// 以下隐式实现可选，但很方便</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">int</span>(<span class="params">MyBufferElement e</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> e.Value;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">implicit</span> <span class="keyword">operator</span> <span class="title">MyBufferElement</span>(<span class="params"><span class="built_in">int</span> e</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyBufferElement { Value = e };</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="向entity添加缓冲区类型">向entity添加缓冲区类型</h2>
<p>要将缓冲区添加到实体，请添加<code>IBufferElementData</code>定义缓冲区元素数据类型的结构，然后将该类型直接添加到entity或<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityArchetype.html">archetype</a>：</p>
<h3 id="使用EntityManager-AddBuffer">使用EntityManager.AddBuffer()</h3>
<p>有关更多信息，请参见<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_AddBuffer_">EntityManager.AddBuffer()</a>上的文档。</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityManager.AddBuffer&lt;MyBufferElement&gt;(entity);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用archetype">使用archetype</h3>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entity e = EntityManager.CreateEntity(<span class="keyword">typeof</span>(MyBufferElement));</span><br></pre></td></tr></tbody></table></figure>
<h3 id="使用-GenerateAuthoringComponent-attribute">使用<code>[GenerateAuthoringComponent]</code>attribute</h3>
<p>您可以用<code>[GenerateAuthoringComponent]</code>标识只包含一个字段的简单得IBufferElementData。设置此属性后，您可以将ECS IBufferElementData组件添加到GameObject，以便可以在编辑器中设置缓冲区元素。</p>
<p>例如，如果声明以下类型，则可以将其直接添加到编辑器中的GameObject中：</p>
<figure class="highlight csharp"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">GenerateAuthoringComponent</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> IntBufferElement: IBufferElementData</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> Value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Unity在幕后生成了一个名为<code>IntBufferElementAuthoring</code>（继承自<code>MonoBehaviour</code>）的类，该类公开了一个公共<code>List&lt;int&gt;</code>类型的字段。将包含此GenerateAuthoringComponent的GameObject转换为entity时，该列表将转换为<code>DynamicBuffer&lt;IntBufferElement&gt;</code>，然后添加到转换后的entity中。</p>
<p>请注意以下限制：</p>
<ul>
<li>单个C＃文件中只能有一个generated authoring component，并且C＃文件中不能包含另一个MonoBehaviour。</li>
<li><code>IBufferElementData</code> 对于包含多个字段的类型，无法自动生成GenerateAuthoringComponent。</li>
<li><code>IBufferElementData</code> 无法为具有显式布局的类型自动生成GenerateAuthoringComponent。</li>
</ul>
<h3 id="使用EntityCommandBuffer">使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityCommandBuffer.html">EntityCommandBuffer</a></h3>
<p>将命令添加到entity command buffer时，可以添加或设置buffer component。</p>
<p>使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityCommandBuffer.html#Unity_Entities_EntityCommandBuffer_AddBuffer__1_Unity_Entities_Entity_">AddBuffer</a>为entity创建一个新的缓冲区，这将更改entity的archetype。使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityCommandBuffer.html#Unity_Entities_EntityCommandBuffer_SetBuffer__1_Unity_Entities_Entity_">SetBuffer</a>清除现有缓冲区（必须是已存在的）并在其位置创建一个新的空缓冲区。这两个函数都返回一个<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.DynamicBuffer-1.html">DynamicBuffer</a>实例，您可以使用该实例来填充新缓冲区。您可以立即将元素添加到缓冲区，但是在执行命令缓冲区时需要将缓冲区添加到entity，否则无法访问它们。</p>
<p>以下job使用command buffer创建一个新entity，然后使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityCommandBuffer.html#Unity_Entities_EntityCommandBuffer_AddBuffer__1_Unity_Entities_Entity_">EntityCommandBuffer.AddBuffer</a>添加一个动态缓冲区组件。job还向动态缓冲区添加了许多元素。</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Unity.Entities;</span><br><span class="line"><span class="keyword">using</span> Unity.Jobs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CreateEntitiesWithBuffers</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// A command buffer system executes command buffers in its own OnUpdate</span></span><br><span class="line">    <span class="comment">// 一个命令缓冲区system执行命令缓冲区在他自己的OnUpdate函数</span></span><br><span class="line">    <span class="keyword">public</span> EntityCommandBufferSystem CommandBufferSystem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Get the command buffer system</span></span><br><span class="line">        <span class="comment">// 获取命令缓冲区system</span></span><br><span class="line">        CommandBufferSystem</span><br><span class="line">            = World.DefaultGameObjectInjectionWorld.GetExistingSystem&lt;EndSimulationEntityCommandBufferSystem&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// The command buffer to record commands,</span></span><br><span class="line">        <span class="comment">// 命令缓冲区，在一帧的晚些时候被command buffer system执行</span></span><br><span class="line">        <span class="comment">// which are executed by the command buffer system later in the frame</span></span><br><span class="line">        EntityCommandBuffer.ParallelWriter commandBuffer</span><br><span class="line">            = CommandBufferSystem.CreateCommandBuffer().AsParallelWriter();</span><br><span class="line">        <span class="comment">//The DataToSpawn component tells us how many entities with buffers to create</span></span><br><span class="line">        <span class="comment">//DataToSpawn component告诉我们在缓冲区有多少entities将会被创建</span></span><br><span class="line">        Entities.ForEach((Entity spawnEntity, <span class="built_in">int</span> entityInQueryIndex, <span class="keyword">in</span> DataToSpawn data) =&gt;</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> e = <span class="number">0</span>; e &lt; data.EntityCount; e++)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//Create a new entity for the command buffer</span></span><br><span class="line">                <span class="comment">//为命令缓冲区创建一个Entity</span></span><br><span class="line">                Entity newEntity = commandBuffer.CreateEntity(entityInQueryIndex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Create the dynamic buffer and add it to the new entity</span></span><br><span class="line">                <span class="comment">//创建动态缓冲区，并把它加入刚刚创建的entity身上</span></span><br><span class="line">                DynamicBuffer&lt;MyBufferElement&gt; buffer =</span><br><span class="line">                    commandBuffer.AddBuffer&lt;MyBufferElement&gt;(entityInQueryIndex, newEntity);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Reinterpret to plain int buffer</span></span><br><span class="line">                <span class="comment">//将动态缓冲区重定义为int元素的缓冲区</span></span><br><span class="line">                DynamicBuffer&lt;<span class="built_in">int</span>&gt; intBuffer = buffer.Reinterpret&lt;<span class="built_in">int</span>&gt;();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//Optionally, populate the dynamic buffer</span></span><br><span class="line">                <span class="comment">//可选的，填充动态缓冲区</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; data.ElementCount; j++)</span><br><span class="line">                {</span><br><span class="line">                    intBuffer.Add(j);</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line"></span><br><span class="line">            <span class="comment">//Destroy the DataToSpawn entity since it has done its job</span></span><br><span class="line">            <span class="comment">//在DataToSpawn entity完成他的job时，销毁他 </span></span><br><span class="line">            commandBuffer.DestroyEntity(entityInQueryIndex, spawnEntity);</span><br><span class="line">        }).ScheduleParallel();</span><br><span class="line"></span><br><span class="line">        CommandBufferSystem.AddJobHandleForProducer(<span class="keyword">this</span>.Dependency);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>**注意：**不需要立即将数据添加到动态缓冲区。但是，直到执行了您正在使用的entity命令缓冲区后，您才能再次访问该缓冲区。</p>
<h2 id="访问缓冲区">访问缓冲区</h2>
<p>您可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html">EntityManager</a>，<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/ecs_systems.html">systems</a>和<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.DynamicBuffer-1.html">job</a>来访问<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.DynamicBuffer-1.html">DynamicBuffer</a>实例，就像访问实体的其他组件类型一样。</p>
<h3 id="EntityManager访问缓冲区">EntityManager访问缓冲区</h3>
<p>您可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html">EntityManager的实例</a>来访问动态缓冲区：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DynamicBuffer&lt;MyBufferElement&gt; dynamicBuffer</span><br><span class="line">    = EntityManager.GetBuffer&lt;MyBufferElement&gt;(entity);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="查找另一个entity的缓冲区">查找另一个entity的缓冲区</h3>
<p>当您需要查找job中另一个entity的缓冲区数据时，可以将<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.BufferFromEntity-1.html">BufferFromEntity</a>变量传递给作业。</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BufferFromEntity&lt;MyBufferElement&gt; lookup = GetBufferFromEntity&lt;MyBufferElement&gt;();</span><br><span class="line"><span class="keyword">var</span> buffer = lookup[entity];</span><br><span class="line">buffer.Add(<span class="number">17</span>);</span><br><span class="line">buffer.RemoveAt(<span class="number">0</span>);</span><br></pre></td></tr></tbody></table></figure>
<h3 id="SystemBase-Entities-ForEach访问缓冲区">SystemBase Entities.ForEach访问缓冲区</h3>
<p>通过将缓冲区作为lambda函数参数之一传递，可以访问与使用Entities.ForEach处理的entity相关联的动态缓冲区。以下示例将所有存储在类型为<code>MyBufferElement</code>缓冲区中的值相加：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicBufferSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Entities.ForEach((DynamicBuffer&lt;MyBufferElement&gt; buffer) =&gt;</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buffer.Length; i++)</span><br><span class="line">            {</span><br><span class="line">                sum += buffer[i].Value;</span><br><span class="line">            }</span><br><span class="line">        }).Run();</span><br><span class="line"></span><br><span class="line">        Debug.Log(<span class="string">"Sum of all buffers: "</span> + sum);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>请注意，在此示例中我们可以直接对<code>sum</code>写入捕获的变量，因为我们使用<code>Run()</code>来执行代码。如果我们将函数安排为在job中运行，那么即使结果为单个值，我们也只能写入本地化的容器（例如NativeArray）。</p>
<h3 id="IJobChunk访问缓冲区">IJobChunk访问缓冲区</h3>
<p>要访问<code>IJobChunk</code>job中的单个缓冲区，请将缓冲区数据类型传递给job，然后使用该数据类型获取<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.BufferAccessor-1.html">BufferAccessor</a>。缓冲区访问器是一种类似于数组的结构，可提供对当前块中所有动态缓冲区的访问。</p>
<p>与前面的示例类似，以下示例将所有包含类型为<code>MyBufferElement</code>的元素的动态缓冲区的内容相加。<code>IJobChunk</code>job还可以在每个chunk上并行运行，因此在示例中，它首先将每个缓冲区的中间和存储在本地化数组中，然后使用第二个job来计算最终和。在这种情况下，中间数组为每个chunk保存一个结果，而不是为每个entity保存一个结果。</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">DynamicBufferJobSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> EntityQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//Create a query to find all entities with a dynamic buffer</span></span><br><span class="line">        <span class="comment">// containing MyBufferElement</span></span><br><span class="line">        <span class="comment">// 创建一个用于查找所有带有一个动态缓冲区组件（包含 MyBufferElement）的entities的query</span></span><br><span class="line">        EntityQueryDesc queryDescription = <span class="keyword">new</span> EntityQueryDesc();</span><br><span class="line">        queryDescription.All = <span class="keyword">new</span>[] {ComponentType.ReadOnly&lt;MyBufferElement&gt;()};</span><br><span class="line">        query = GetEntityQuery(queryDescription);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> BuffersInChunks : IJobChunk</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//The data type and safety object</span></span><br><span class="line">        <span class="comment">//数据类型和安全对象</span></span><br><span class="line">        <span class="keyword">public</span> BufferTypeHandle&lt;MyBufferElement&gt; BufferTypeHandle;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//An array to hold the output, intermediate sums</span></span><br><span class="line">        <span class="comment">//用于保存输出中间结果的数组</span></span><br><span class="line">        <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; sums;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ArchetypeChunk chunk,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="built_in">int</span> chunkIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="built_in">int</span> firstEntityIndex</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">//A buffer accessor is a list of all the buffers in the chunk</span></span><br><span class="line">            <span class="comment">//一个缓冲区的获取者是在一个chunk中的所有缓冲区的列表</span></span><br><span class="line">            BufferAccessor&lt;MyBufferElement&gt; buffers</span><br><span class="line">                = chunk.GetBufferAccessor(BufferTypeHandle);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> c = <span class="number">0</span>; c &lt; chunk.Count; c++)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">//An individual dynamic buffer for a specific entity</span></span><br><span class="line">                <span class="comment">//指定entity的单个动态缓冲区</span></span><br><span class="line">                DynamicBuffer&lt;MyBufferElement&gt; buffer = buffers[c];</span><br><span class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buffer.Length; i++)</span><br><span class="line">                {</span><br><span class="line">                    sums[chunkIndex] += buffer[i].Value;</span><br><span class="line">                }</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Sums the intermediate results into the final total</span></span><br><span class="line">    <span class="comment">//将所有中间结果相加得到最后的总值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">struct</span> SumResult : IJob</span><br><span class="line">    {</span><br><span class="line">        [<span class="meta">DeallocateOnJobCompletion</span>] <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; sums;</span><br><span class="line">        <span class="keyword">public</span> NativeArray&lt;<span class="built_in">int</span>&gt; result;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>()</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span>(<span class="built_in">int</span> i  = <span class="number">0</span>; i &lt; sums.Length; i++)</span><br><span class="line">            {</span><br><span class="line">                result[<span class="number">0</span>] += sums[i];</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//Create a native array to hold the intermediate sums</span></span><br><span class="line">        <span class="comment">//创建一个本地化数组来保存中间值</span></span><br><span class="line">        <span class="built_in">int</span> chunksInQuery = query.CalculateChunkCount();</span><br><span class="line">        NativeArray&lt;<span class="built_in">int</span>&gt; intermediateSums</span><br><span class="line">            = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">int</span>&gt;(chunksInQuery, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Schedule the first job to add all the buffer elements</span></span><br><span class="line">        <span class="comment">//安排第一个job将所有缓冲区元素加起来</span></span><br><span class="line">        BuffersInChunks bufferJob = <span class="keyword">new</span> BuffersInChunks();</span><br><span class="line">        bufferJob.BufferTypeHandle = GetBufferTypeHandle&lt;MyBufferElement&gt;();</span><br><span class="line">        bufferJob.sums = intermediateSums;</span><br><span class="line">        <span class="keyword">this</span>.Dependency = bufferJob.ScheduleParallel(query, <span class="keyword">this</span>.Dependency);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Schedule the second job, which depends on the first</span></span><br><span class="line">        <span class="comment">//安排第二个job，他依赖第一个job，用来得到最终结果</span></span><br><span class="line">        SumResult finalSumJob = <span class="keyword">new</span> SumResult();</span><br><span class="line">        finalSumJob.sums = intermediateSums;</span><br><span class="line">        NativeArray&lt;<span class="built_in">int</span>&gt; finalSum = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">int</span>&gt;(<span class="number">1</span>, Allocator.Temp);</span><br><span class="line">        finalSumJob.result = finalSum;</span><br><span class="line">        <span class="keyword">this</span>.Dependency = finalSumJob.Schedule(<span class="keyword">this</span>.Dependency);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.CompleteDependency();</span><br><span class="line">        Debug.Log(<span class="string">"Sum of all buffers: "</span> + finalSum[<span class="number">0</span>]);</span><br><span class="line">        finalSum.Dispose();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="重新解释缓冲区">重新解释缓冲区</h2>
<p>缓冲区可以重新解释为相同大小的类型。目的是允许进行受控的类型合并，并在转换元素类型时不感到蛋疼。要重新解释，请调用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.DynamicBuffer-1.html#Unity_Entities_DynamicBuffer_1_Reinterpret_">Reinterpret </a>：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DynamicBuffer&lt;<span class="built_in">int</span>&gt; intBuffer</span><br><span class="line">    = EntityManager.GetBuffer&lt;MyBufferElement&gt;(entity).Reinterpret&lt;<span class="built_in">int</span>&gt;();</span><br></pre></td></tr></tbody></table></figure>
<p>重新解释的缓冲区实例保留了原始缓冲区的安全性，并且可以安全使用。<em>重新解释的缓冲区引用原始数据</em>，因此对一个重新解释的缓冲区的修改会立即反映在其他缓冲区中。</p>
<p>**注意：**重新解释函数仅强制所涉及的类型具有相同的长度。例如，您可以为一个<code>uint</code>和<code>float</code>buffer 加上别名而不引起错误，因为这两种类型均为32位长。您必须确保重新解释在逻辑上有意义（别乱搞）。</p>
<h2 id="缓冲区引用无效">缓冲区引用无效</h2>
<p>每次<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/sync_points.html#structural-changes">结构更改都会</a>使对动态缓冲区的所有引用无效。结构变化通常会导致实体从一个chunk移动到另一个chunk。小型动态缓冲区可以引用块内的内存（而不是主内存中的内存），因此，在结构更改后需要重新获取它们。</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entity1 = EntityManager.CreateEntity();</span><br><span class="line"><span class="keyword">var</span> entity2 = EntityManager.CreateEntity();</span><br><span class="line"></span><br><span class="line">DynamicBuffer&lt;MyBufferElement&gt; buffer1</span><br><span class="line">    = EntityManager.AddBuffer&lt;MyBufferElement&gt;(entity1);</span><br><span class="line"><span class="comment">// This line causes a structural change and invalidates</span></span><br><span class="line"><span class="comment">// the previously acquired dynamic buffer</span></span><br><span class="line"><span class="comment">// 这一行会导致一次结构癌变，并且无效化先前的缓冲区</span></span><br><span class="line">DynamicBuffer&lt;MyBufferElement&gt; buffer2</span><br><span class="line">    = EntityManager.AddBuffer&lt;MyBufferElement&gt;(entity1);</span><br><span class="line"><span class="comment">// This line will cause an error:</span></span><br><span class="line"><span class="comment">// 这一行将会导致错误</span></span><br><span class="line">buffer1.Add(<span class="number">17</span>);</span><br></pre></td></tr></tbody></table></figure>
<h1>Chunk component data</h1>
<p>使用chunk components将数据与特定<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ArchetypeChunk.html">chunk</a>关联。</p>
<p>chunk component包含适用于特定chunk中所有entities的数据。例如，如果您有代表紧密排布的3D对象的entities chunks，则可以使用chunk component为它们存储集合边界框。chunk component使用接口类型<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.IComponentData.html">IComponentData</a>。</p>
<h2 id="添加并设置chunk-component的值">添加并设置chunk component的值</h2>
<p>尽管chunk component可以单个块具有唯一的值，但它们仍然是该chunk中entity archetype的一部分。因此，如果您从实体中删除了一个chunk component，ECS会将该entity移动到另一个chunk（可能是一个新的chunk）。同样，如果将chunk component添加到entity，则ECS会将该entity移至其他chunk，因为其archetype会更改；chunk component的添加不会影响原始chunk中的其余entities。</p>
<p>如果您在chunk中使用entity来更改chunk component的值，则它将更改该chunk中所有entities所共有的chunk component的值*(这一点和SCB不一致)<em>。如果更改entity的archetype，以使其移动到具有相同类型的chunk component的新chunk中，那么目标chunk中的现有值将不受影响</em>(这一点和SCB一致)*。**注意：**如果将entity移至新创建的chunk，则ECS会为该chunk创建一个新的chunk component并分配其默认值。</p>
<p>使用chunk component和通用component之间的主要区别在于，您使用不同的功能来添加，设置和删除它们。</p>
<p><strong>相关API</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>目的</strong></th>
<th style="text-align:left"><strong>功能</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">介绍</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.IComponentData.html">IComponentData</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ArchetypeChunk.html">ArchetypeChunk方法</a></strong></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">读</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ArchetypeChunk.html#Unity_Entities_ArchetypeChunk_GetChunkComponentData_">GetChunkComponentData （ArchetypeChunkComponentType ）</a></td>
</tr>
<tr>
<td style="text-align:left">检查</td>
<td style="text-align:left">[HasChunkComponent <t>（ArchetypeChunkComponentType <t>）]</t></t></td>
</tr>
<tr>
<td style="text-align:left">写</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ArchetypeChunk.html#Unity_Entities_ArchetypeChunk_SetChunkComponentData_">SetChunkComponentData （ArchetypeChunkComponentType ，T）</a></td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left"><strong><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html">EntityManager方法</a></strong></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">创建</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_AddChunkComponentData__1_Unity_Entities_Entity_">AddChunkComponentData （Entity）</a></td>
</tr>
<tr>
<td style="text-align:left">创建</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_AddChunkComponentData__1_Unity_Entities_EntityQuery___0_">AddChunkComponentData （EntityQuery，T）</a></td>
</tr>
<tr>
<td style="text-align:left">创建</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_AddComponents_Unity_Entities_Entity_Unity_Entities_ComponentTypes_">AddComponents（Entity，ComponentTypes）</a></td>
</tr>
<tr>
<td style="text-align:left">获取类型信息</td>
<td style="text-align:left">[GetComponentTypeHandle]</td>
</tr>
<tr>
<td style="text-align:left">读</td>
<td style="text-align:left">[GetChunkComponentData <t>（ArchetypeChunk）]</t></td>
</tr>
<tr>
<td style="text-align:left">读</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_GetChunkComponentData__1_Unity_Entities_Entity_">GetChunkComponentData （Entity）</a></td>
</tr>
<tr>
<td style="text-align:left">检查</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_HasChunkComponent_">HasChunkComponent （Entity）</a></td>
</tr>
<tr>
<td style="text-align:left">删除</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_RemoveChunkComponent__1_Unity_Entities_Entity_">RemoveChunkComponent （Entity）</a></td>
</tr>
<tr>
<td style="text-align:left">删除</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_RemoveChunkComponentData_">RemoveChunkComponentData （EntityQuery）</a></td>
</tr>
<tr>
<td style="text-align:left">写</td>
<td style="text-align:left"><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_SetChunkComponentData_">EntityManager.SetChunkComponentData （ArchetypeChunk，T）</a></td>
</tr>
</tbody>
</table>
<h2 id="声明chunk-component">声明chunk component</h2>
<p>chunk component使用接口类型<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.IComponentData.html">IComponentData</a>。</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ChunkComponentA : IComponentData</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Value;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="创建一个chunk-component">创建一个chunk component</h2>
<p>要直接添加chunk component，请确保目标chunk中至少存在一个实体，或使用选择一组目标chunks的entity query。您不能在job内添加chunk component，也不能使用<code>EntityCommandBuffer</code>来添加chunk component。</p>
<p>您还可以将chunk component作为<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityArchetype.html">EntityArchetype</a>的一部分或ECS用于创建entity的[ComponentType]对象列表的一部分。<em>ECS为每个chunk创建chunk component，并存储具有该archetype的实体</em>。</p>
<p>通过这些方法使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentType.html#Unity_Entities_ComponentType_ChunkComponent_">ComponentType.ChunkComponent </a>或[ComponentType.ChunkComponentReadOnly <t>]。否则，ECS将该组件视为通用组件，而不是chunk component。</t></p>
<p><strong>使用在一个chunk里的entity</strong></p>
<p>给定目标chunk中的entity，您可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_AddChunkComponentData__1_Unity_Entities_EntityQuery___0_">EntityManager.AddChunkComponentData （）</a>函数将chunk component添加到块中：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityManager.AddChunkComponentData&lt;ChunkComponentA&gt;(entity);</span><br></pre></td></tr></tbody></table></figure>
<p>使用此方法时，不能立即为chunk component设置值。</p>
<p><strong>使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityQuery.html">EntityQuery</a></strong></p>
<p>给定一个entity query，该query选择了要添加chunk component的所有chunks，您可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_AddChunkComponentData__1_Unity_Entities_EntityQuery___0_">EntityManager.AddChunkComponentData （）</a>函数来添加和设置component：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EntityQueryDesc ChunksWithoutComponentADesc = <span class="keyword">new</span> EntityQueryDesc()</span><br><span class="line">{</span><br><span class="line">    None = <span class="keyword">new</span> ComponentType[] { ComponentType.ChunkComponent&lt;ChunkComponentA&gt;() }</span><br><span class="line">};</span><br><span class="line">EntityQuery ChunksWithoutChunkComponentA = GetEntityQuery(ChunksWithoutComponentADesc);</span><br><span class="line"></span><br><span class="line">EntityManager.AddChunkComponentData&lt;ChunkComponentA&gt;(ChunksWithoutChunkComponentA,</span><br><span class="line">    <span class="keyword">new</span> ChunkComponentA() { Value = <span class="number">4</span> });</span><br></pre></td></tr></tbody></table></figure>
<p>使用此方法时，可以为所有新chunk component设置相同的初始值。</p>
<p><strong>使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityArchetype.html">EntityArchetype</a></strong></p>
<p>当您创建具有archetype或具有多个components类型的entity时，请在archetype中包含chunk component类型：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EntityArchetype ArchetypeWithChunkComponent = EntityManager.CreateArchetype(</span><br><span class="line">    ComponentType.ChunkComponent(<span class="keyword">typeof</span>(ChunkComponentA)),</span><br><span class="line">    ComponentType.ReadWrite&lt;GeneralPurposeComponentA&gt;());</span><br><span class="line">Entity newEntity = EntityManager.CreateEntity(ArchetypeWithChunkComponent);</span><br></pre></td></tr></tbody></table></figure>
<p>或具有多个components：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ComponentType[] compTypes = {ComponentType.ChunkComponent&lt;ChunkComponentA&gt;(),</span><br><span class="line">                             ComponentType.ReadOnly&lt;GeneralPurposeComponentA&gt;()};</span><br><span class="line">Entity entity = EntityManager.CreateEntity(compTypes);</span><br></pre></td></tr></tbody></table></figure>
<p>使用这些方法时，ECS新建的chunks的chunk components作为entity构造的一部分将接收默认结构值。ECS不会更改现有chunk中的chunk component。请参阅<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/ecs_chunk_component.html#update">更新块组件，</a>以了解如何在给定entity引用的情况下设置chunk component值。</p>
<h2 id="读取chunk-component">读取chunk component</h2>
<p>要读取chunk component，可以使用代表chunk的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ArchetypeChunk.html">ArchetypeChunk</a>对象，或在目标chunk中使用entity。</p>
<p><strong>使用ArchetypeChunk实例</strong></p>
<p>给定一个chunk，您可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_GetChunkComponentData__1_Unity_Entities_ArchetypeChunk_">EntityManager.GetChunkComponentData </a>函数读取其chunk component。以下代码遍历与查询匹配的所有chunks，并访问他们的ChunkComponentA`：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">NativeArray&lt;ArchetypeChunk&gt; chunks = ChunksWithChunkComponentA.CreateArchetypeChunkArray(Allocator.TempJob);</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> chunk <span class="keyword">in</span> chunks)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> compValue = EntityManager.GetChunkComponentData&lt;ChunkComponentA&gt;(chunk);</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">}</span><br><span class="line">chunks.Dispose();</span><br></pre></td></tr></tbody></table></figure>
<p><strong>使用在一个chunk里的entity</strong></p>
<p>给定一个entity，您可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_GetChunkComponentData__1_Unity_Entities_ArchetypeChunk_">EntityManager.GetChunkComponentData </a>访问包含该entity的chunk中的chunk component：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (EntityManager.HasChunkComponent&lt;ChunkComponentA&gt;(entity))</span><br><span class="line">{</span><br><span class="line">    ChunkComponentA chunkComponentValue = EntityManager.GetChunkComponentData&lt;ChunkComponentA&gt;(entity);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="更新chunk-component">更新chunk component</h2>
<p>您可以在引用其所属的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ArchetypeChunk.html">chunk</a>情况下更新chunk component。在<code>IJobChunk</code>job中，可以调用[ArchetypeChunk.SetChunkComponentData]。在主线程上，可以使用EntityManager版本：[EntityManager.SetChunkComponentData]。**注意：**您无法使用SystemBase Entities.ForEach访问chunk component，因为您无权访问<code>ArchetypeChunk</code>对象或EntityManager。</p>
<p><strong>使用ArchetypeChunk实例</strong></p>
<p>要在job中更新chunk component，请参阅 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/ecs_chunk_component.html#update">Reading and writing in a system</a>.。</p>
<p>要在主线程上更新块组件，请使用EntityManager：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EntityManager.SetChunkComponentData&lt;ChunkComponentA&gt;(chunk, <span class="keyword">new</span> ChunkComponentA() { Value = <span class="number">7</span> });</span><br></pre></td></tr></tbody></table></figure>
<p><strong>使用entity实例</strong></p>
<p>如果chunk中除本身外有一个entity，则还可以使用EntityManger来获取包含该entity的chunk：</p>
<p>**注意：**如果只想读取chunk component而不写入，则在定义实体查询时应使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentType.html#Unity_Entities_ComponentType_ChunkComponentReadOnly_">ComponentType.ChunkComponentReadOnly</a>，以避免创建不必要的job scheduling 约束。</p>
<h2 id="删除chunk-component">删除chunk component</h2>
<p>使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html#Unity_Entities_EntityManager_RemoveChunkComponent_">EntityManager.RemoveChunkComponent</a>函数删除chunk component。您可以删除目标chunk中给定entity的chunk component，也可以从entity query选择的所有chunk中删除给定类型的所有chunk component。</p>
<p>如果从单个entity中删除chunk component，则该entity将移至其他chunk，因为该实体的archetype会更改。只要该chunk中还有其他entities，该chunk就会保留未更改的chunk component。</p>
<h2 id="在query中使用chunk-component">在query中使用chunk component</h2>
<p>要在entity query中使用chunk component，必须使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentType.html#Unity_Entities_ComponentType_ChunkComponent_">ComponentType.ChunkComponent </a>或[ComponentType.ChunkComponentReadOnly <t>]函数来指定类型。否则，ECS将该组件视为通用component，而不是Chunk component。</t></p>
<p><strong>使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityQueryDesc.html">EntityQueryDesc</a></strong></p>
<p>您可以使用以下query描述创建一个entity query，该query选择所有chunks以及这些chunks中具有类型为<em>ChunkComponentA</em>的chunk component的<em>entity</em>：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">EntityQueryDesc ChunksWithChunkComponentADesc = <span class="keyword">new</span> EntityQueryDesc()</span><br><span class="line">{</span><br><span class="line">    All = <span class="keyword">new</span> ComponentType[] { ComponentType.ChunkComponent&lt;ChunkComponentA&gt;() }</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<h2 id="遍历chunk以设置chunk-component">遍历chunk以设置chunk component</h2>
<p>要遍历要为其设置chunk components的所有chunks，可以创建一个entity query，该entity query选择正确的chunk，然后使用EntityQuery对象获取ArchetypeChunk实例的列表作为本地化数组。ArchetypeChunk对象允许您将新值写入组chunk component。</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChunkComponentExamples</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> EntityQuery ChunksWithChunkComponentA;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        EntityQueryDesc ChunksWithComponentADesc = <span class="keyword">new</span> EntityQueryDesc()</span><br><span class="line">        {</span><br><span class="line">            All = <span class="keyword">new</span> ComponentType[] { ComponentType.ChunkComponent&lt;ChunkComponentA&gt;() }</span><br><span class="line">        };</span><br><span class="line">        ChunksWithChunkComponentA = GetEntityQuery(ChunksWithComponentADesc);</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    [<span class="meta">BurstCompile</span>]</span><br><span class="line">    <span class="keyword">struct</span> ChunkComponentCheckerJob : IJobChunk</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">public</span> ComponentTypeHandle&lt;ChunkComponentA&gt; ChunkComponentATypeHandle;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ArchetypeChunk chunk, <span class="built_in">int</span> chunkIndex, <span class="built_in">int</span> firstEntityIndex</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">var</span> compValue = chunk.GetChunkComponentData(ChunkComponentATypeHandle);</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="keyword">var</span> squared = compValue.Value * compValue.Value;</span><br><span class="line">            chunk.SetChunkComponentData(ChunkComponentATypeHandle,</span><br><span class="line">                <span class="keyword">new</span> ChunkComponentA() { Value = squared });</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">var</span> job = <span class="keyword">new</span> ChunkComponentCheckerJob()</span><br><span class="line">        {</span><br><span class="line">            ChunkComponentATypeHandle = GetComponentTypeHandle&lt;ChunkComponentA&gt;()</span><br><span class="line">        };</span><br><span class="line">        <span class="keyword">this</span>.Dependency = job.Schedule(ChunksWithChunkComponentA, <span class="keyword">this</span>.Dependency);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>请注意，如果需要读取chunk中的component以确定chunk component的正确值，则应使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.IJobEntityBatch.html">IJobEntityBatch</a>。例如，以下代码为包含具有LocalToWorld组件的实体的所有块计算出与轴对齐的边界框：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> ChunkAABB : IComponentData</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> AABB Value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">[<span class="meta">UpdateInGroup(typeof(PresentationSystemGroup))</span>]</span><br><span class="line">[<span class="meta">UpdateBefore(typeof(UpdateAABBSystem))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AddAABBSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    EntityQuery queryWithoutChunkComponent;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        queryWithoutChunkComponent = GetEntityQuery(<span class="keyword">new</span> EntityQueryDesc()</span><br><span class="line">        {</span><br><span class="line">            All = <span class="keyword">new</span> ComponentType[]  { ComponentType.ReadOnly&lt;LocalToWorld&gt;() },</span><br><span class="line">            None = <span class="keyword">new</span> ComponentType[] { ComponentType.ChunkComponent&lt;ChunkAABB&gt;() }</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// This is a structural change and a sync point</span></span><br><span class="line">        <span class="comment">// 这是一个结构改变和一个同步点</span></span><br><span class="line">        EntityManager.AddChunkComponentData&lt;ChunkAABB&gt;(queryWithoutChunkComponent, <span class="keyword">new</span> ChunkAABB());</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">[<span class="meta">UpdateInGroup(typeof(PresentationSystemGroup))</span>]</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UpdateAABBSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    EntityQuery queryWithChunkComponent;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        queryWithChunkComponent = GetEntityQuery(<span class="keyword">new</span> EntityQueryDesc()</span><br><span class="line">        {</span><br><span class="line">            All = <span class="keyword">new</span> ComponentType[] { ComponentType.ReadOnly&lt;LocalToWorld&gt;(),</span><br><span class="line">                                        ComponentType.ChunkComponent&lt;ChunkAABB&gt;()}</span><br><span class="line">        });</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    [<span class="meta">BurstCompile</span>]</span><br><span class="line">    <span class="keyword">struct</span> AABBJob : IJobChunk</span><br><span class="line">    {</span><br><span class="line">        [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> ComponentTypeHandle&lt;LocalToWorld&gt; LocalToWorldTypeHandleInfo;</span><br><span class="line">        <span class="keyword">public</span> ComponentTypeHandle&lt;ChunkAABB&gt; ChunkAabbTypeHandleInfo;</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">uint</span> L2WChangeVersion;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ArchetypeChunk chunk, <span class="built_in">int</span> chunkIndex, <span class="built_in">int</span> firstEntityIndex</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">bool</span> chunkHasChanges = chunk.DidChange(LocalToWorldTypeHandleInfo, L2WChangeVersion);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!chunkHasChanges)</span><br><span class="line">                <span class="keyword">return</span>; <span class="comment">// early out if the chunk transforms haven't changed</span></span><br><span class="line"></span><br><span class="line">            NativeArray&lt;LocalToWorld&gt; transforms = chunk.GetNativeArray&lt;LocalToWorld&gt;(LocalToWorldTypeHandleInfo);</span><br><span class="line">            UnityEngine.Bounds bounds = <span class="keyword">new</span> UnityEngine.Bounds();</span><br><span class="line">            bounds.center = transforms[<span class="number">0</span>].Position;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">1</span>; i &lt; transforms.Length; i++)</span><br><span class="line">            {</span><br><span class="line">                bounds.Encapsulate(transforms[i].Position);</span><br><span class="line">            }</span><br><span class="line">            chunk.SetChunkComponentData(ChunkAabbTypeHandleInfo, <span class="keyword">new</span> ChunkAABB() { Value = bounds.ToAABB() });</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">var</span> job = <span class="keyword">new</span> AABBJob()</span><br><span class="line">        {</span><br><span class="line">            LocalToWorldTypeHandleInfo = GetComponentTypeHandle&lt;LocalToWorld&gt;(<span class="literal">true</span>),</span><br><span class="line">            ChunkAabbTypeHandleInfo = GetComponentTypeHandle&lt;ChunkAABB&gt;(<span class="literal">false</span>),</span><br><span class="line">            L2WChangeVersion = <span class="keyword">this</span>.LastSystemVersion</span><br><span class="line">        };</span><br><span class="line">        <span class="keyword">this</span>.Dependency = job.Schedule(queryWithChunkComponent, <span class="keyword">this</span>.Dependency);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="www.lfzxb.top">烟雨迷离半世殇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.lfzxb.top/unity-dots-part-of-components/">https://www.lfzxb.top/unity-dots-part-of-components/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.lfzxb.top" target="_blank">登峰造极者，殊途亦同归。</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity%E6%8A%80%E6%9C%AF/">Unity技术</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/ECS/">ECS</a><a class="post-meta__tags" href="/tags/Unity-DOTS/">Unity DOTS</a></div><div class="post-share"><div class="social-share" data-image="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>想吃fvcking crazy thrusday</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175314.png!webp" target="_blank"><img class="post-qr-code-img" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175314.png!webp" alt="微信" loading='lazy'></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175304.png!webp" target="_blank"><img class="post-qr-code-img" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175304.png!webp" alt="支付宝" loading='lazy'></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><div class="ads-wrap"><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7235595771604497" data-ad-slot="9104433828"></ins><script> (adsbygoogle = window.adsbygoogle || []).push({});</script></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/unity-dots-part-of-entities/" title="Unity DOTS：Entities部分"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post" loading='lazy'><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Unity DOTS：Entities部分</div></div><div class="info-2"><div class="info-item-1">Entities Entities是实体组件系统体系结构的三个主要元素之一。它们代表游戏或应用程序中的各个“事物”。Entities既没有行为也没有数据；取而代之的是，它担任索引各种数据的职责。Systems提供行为，而Components存储数据。 entity本质上是一个ID。最简单方法是把它作为一个超轻量级GameObject甚至没有名称。实体ID稳定；您可以使用它们来存储对另一个component或entities的引用。例如，Hierarchy中的子entity可能需要引用其父entity。 一个EntityManager管理在一个World中所有的entities。EntityManager维护entities列表并组织与entities相关联的数据以实现最佳性能。 尽管实体没有类型，但是可以按与entities相关联的components的类型对其进行分组。创建entities并向其添加components时，EntityManager会持续跟踪监控entities上components的唯一组合。这种独特的组合称为Archetype（原型）。将components...</div></div></div></a><a class="pagination-related" href="/unity-dots-extension/" title="Unity DOTS：ECS拓展内容"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post" loading='lazy'><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Unity DOTS：ECS拓展内容</div></div><div class="info-2"><div class="info-item-1">Sync points synchronization poin（sync point）是程序执行中的一个点，它等待到目前为止已调度的所有job的完成。同步点会限制您一段时间内使用Job System中所有可用工作线程的能力。因此，通常应避免同步点。 Structural changes(结构变化) 同步点是由 您在任何其他job正在操作components时不能安全执行自己的操作所引起的。ECS中数据的结构更改是引发Sync points的主要原因。以下所有都是结构上的变化：  创建entities 删除entities 向entity添加component 从entity中删除component 更改sharedcomponent的value  广义上讲，任何更改entity archetype或导致chunk中entities顺序更改的操作都是结构性更改。这些结构更改只能在主线程上执行。 结构更改不仅需要Sync points，而且还会使对任何component数据的所有直接引用无效。这包括DynamicBuffer的实例以及提供对component（例如Component...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/dots-anything-about-isharedcomponent/" title="关于ISharedComponent的一切"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2020-02-01</div><div class="info-item-2">关于ISharedComponent的一切</div></div><div class="info-2"><div class="info-item-1">前言 ECS中的ISharedComponent是一个非常重要的概念，但是理解起来却不是这么容易，前阵子找到一篇讲ISharedComponent的文章，感觉例子举的很好，讲的也很透彻，故翻译出来分享给大家。 本文翻译自：https://gametorrahod.com/everything-about-isharedcomponentdata/ 正文 这是ECS最容易被误解的功能之一。当您不知道它是如何设计的时候，通常会出现诸如“如何在工作中获取SCD数据？我不能？那有什么卵用！”这样的问题。因此，让我们开始了解它是如何工作的。 数据共享并不那么ECS 众所周知，ECS会紧密排布entity数据成为chunk。同样，高性能C＃（HPC＃）的限制是得确保您没有通往外界的任何“门户”。static无法使用。禁用别名。分析器无法通过公有字段引入job的引用类型。它也不会让您将指针潜入IComponentData其中。另外，存储器必须是线性的。 “共享”的概念听起来根本不像ECS。在ECS中，可以从chunk中获取任何用来工作的数据。您不会在任何地方跳转，这就是“默认情况下的性能”的来...</div></div></div></a><a class="pagination-related" href="/unity-dots-core-of-ecs/" title="Unity DOTS：ECS的核心部分"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-02-04</div><div class="info-item-2">Unity DOTS：ECS的核心部分</div></div><div class="info-2"><div class="info-item-1">ECS的概念 实体组件系统（ECS）架构将身份（Entities，实体），数据（Components，组件）和行为（Systems，系统）分开。该架构专注于数据。Systems读取Components数据流，然后将数据从输入状态转换为输出状态，然后对这些实体进行索引。 下图说明了这三个基本部分如何协同工作：  在此图中，系统读取Translation和Rotation部分，将它们相乘，然后更新相应的LocalToWorld成分（L2W = T*R）。 实体A和B具有Renderer组件，而实体C则没有，但是这不会影响系统，因为系统并不关心Renderer组件。 您可以设置一个系统，使其需要一个Renderer组件，在这种情况下，系统将忽略实体C的组件。或者，您也可以设置系统以排除具有Renderer组件的实体，然后忽略实体A和B的组件。 Archetypes(原型) 组件类型的组合称为“原型”。例如，一个3D对象可能具有一个用于其世界变换的组件，一个用于其线性运动的组件，一个用于旋转的组件和一个用于渲染的组件。这些3D对象的每个实例都对应一个实体，但是由于它们共享相同的组件集，因...</div></div></div></a><a class="pagination-related" href="/unity-dots-extension/" title="Unity DOTS：ECS拓展内容"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-02-04</div><div class="info-item-2">Unity DOTS：ECS拓展内容</div></div><div class="info-2"><div class="info-item-1">Sync points synchronization poin（sync point）是程序执行中的一个点，它等待到目前为止已调度的所有job的完成。同步点会限制您一段时间内使用Job System中所有可用工作线程的能力。因此，通常应避免同步点。 Structural changes(结构变化) 同步点是由 您在任何其他job正在操作components时不能安全执行自己的操作所引起的。ECS中数据的结构更改是引发Sync points的主要原因。以下所有都是结构上的变化：  创建entities 删除entities 向entity添加component 从entity中删除component 更改sharedcomponent的value  广义上讲，任何更改entity archetype或导致chunk中entities顺序更改的操作都是结构性更改。这些结构更改只能在主线程上执行。 结构更改不仅需要Sync points，而且还会使对任何component数据的所有直接引用无效。这包括DynamicBuffer的实例以及提供对component（例如Component...</div></div></div></a><a class="pagination-related" href="/unity-dots-ecs-burst-complier-jobsystem/" title="Unity DOTS：入门简介（ECS，Burst Complier，JobSystem）"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-04-13</div><div class="info-item-2">Unity DOTS：入门简介（ECS，Burst Complier，JobSystem）</div></div><div class="info-2"><div class="info-item-1">本文章已于2021.4.13更新，修正了当时因为水平不足而导致的一些错误，拓展了部分内容。  前言 近期想从更深层次上学习ECS，之前一直停留在浅层次的编码模式（即ECS意识流），没有真正的去了解ECS的内部原理，Unity目前在维护一套以ECS为架构开发的DOTS技术栈，非常值得学习。 ECS 什么是ECS ECS即实体（Entity），组件（Component），系统（System），其中Entity，Component皆为纯数据向的类，System负责操控他们，这种模式会一定程度上优化我们的代码速度。  Entities：游戏中的事物，但在ECS中他只作为一个Id Components：与Entity相关的数据，但是这些数据应该由Component本身而不是Entity来组织。（这种组织上的差异正是面向对象和面向数据的设计之间的关键差异之一）。 Systems：Systems是把Components的数据从当前状态转换为下一个状态的逻辑，但System本身应当是无状态的。例如，一个system可能会通过他们的速度乘以从前一帧到这一帧的时间间隔来更新所有的移动中的entiti...</div></div></div></a><a class="pagination-related" href="/unity-dots-part-of-entities/" title="Unity DOTS：Entities部分"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-02-04</div><div class="info-item-2">Unity DOTS：Entities部分</div></div><div class="info-2"><div class="info-item-1">Entities Entities是实体组件系统体系结构的三个主要元素之一。它们代表游戏或应用程序中的各个“事物”。Entities既没有行为也没有数据；取而代之的是，它担任索引各种数据的职责。Systems提供行为，而Components存储数据。 entity本质上是一个ID。最简单方法是把它作为一个超轻量级GameObject甚至没有名称。实体ID稳定；您可以使用它们来存储对另一个component或entities的引用。例如，Hierarchy中的子entity可能需要引用其父entity。 一个EntityManager管理在一个World中所有的entities。EntityManager维护entities列表并组织与entities相关联的数据以实现最佳性能。 尽管实体没有类型，但是可以按与entities相关联的components的类型对其进行分组。创建entities并向其添加components时，EntityManager会持续跟踪监控entities上components的唯一组合。这种独特的组合称为Archetype（原型）。将components...</div></div></div></a><a class="pagination-related" href="/unity-dots-systems/" title="Unity DOTS：Systems部分"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-02-04</div><div class="info-item-2">Unity DOTS：Systems部分</div></div><div class="info-2"><div class="info-item-1">Systems 一个system，也就是ECS里的S，提供了将component的数据从其当前状态变换到其下一个状态的逻辑-例如，一个system可以通过velocity乘以Time.deltaime来更新所有可移动entities的位置。  Instantiating systems Unity ECS自动在您的项目中发现system类型，并在运行时实例化它们。它将每个发现的system添加到默认system groups之一中。您可以使用system attributes来指定system的父组以及该system在该group中的顺序。如果未指定父项，则Unity将以确定性的，但并未指定顺序的将system添加到默认世界的Simulation system group中。您也可以使用attribute禁用自动创建。 system的更新循环由其父ComponentSystemGroup驱动。ComponentSystemGroup本身是一种特殊的system，负责更新其child systems。group可以嵌套。system从运行的world获取time数据；time由Up...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">1.</span> <span class="toc-text">组件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">2.</span> <span class="toc-text">通用组件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#IComponentData"><span class="toc-number">2.1.</span> <span class="toc-text">IComponentData</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%98%E7%AE%A1%E7%9A%84IComponentData"><span class="toc-number">2.1.1.</span> <span class="toc-text">托管的IComponentData</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">3.</span> <span class="toc-text">Shared component data</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E5%85%B3SharedComponentData%E7%9A%84%E9%87%8D%E8%A6%81%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">3.1.</span> <span class="toc-text">有关SharedComponentData的重要说明：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">4.</span> <span class="toc-text">System State Components</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8System-State-Components"><span class="toc-number">4.1.</span> <span class="toc-text">何时使用System State Components</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AAcomponent%E8%A2%AB%E6%B7%BB%E5%8A%A0%E6%97%B6%E6%A3%80%E6%B5%8B"><span class="toc-number">4.1.1.</span> <span class="toc-text">当一个component被添加时检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AAcomponent%E8%A2%AB%E7%A7%BB%E9%99%A4%E6%97%B6%E6%A3%80%E6%B5%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">当一个component被移除时检测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%93%E4%B8%80%E4%B8%AAentity%E8%A2%AB%E9%94%80%E6%AF%81%E6%97%B6%E6%A3%80%E6%B5%8B"><span class="toc-number">4.1.3.</span> <span class="toc-text">当一个entity被销毁时检测</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SystemStateComponent"><span class="toc-number">4.2.</span> <span class="toc-text">SystemStateComponent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SystemStateSharedComponent"><span class="toc-number">4.3.</span> <span class="toc-text">SystemStateSharedComponent</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%BD%BF%E7%94%A8state-components%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.4.</span> <span class="toc-text">一个使用state components的示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">5.</span> <span class="toc-text">Dynamic buffer components</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E7%BC%93%E5%86%B2%E5%8C%BA%E5%85%83%E7%B4%A0%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">声明缓冲区元素类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91entity%E6%B7%BB%E5%8A%A0%E7%BC%93%E5%86%B2%E5%8C%BA%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">向entity添加缓冲区类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8EntityManager-AddBuffer"><span class="toc-number">5.2.1.</span> <span class="toc-text">使用EntityManager.AddBuffer()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8archetype"><span class="toc-number">5.2.2.</span> <span class="toc-text">使用archetype</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-GenerateAuthoringComponent-attribute"><span class="toc-number">5.2.3.</span> <span class="toc-text">使用[GenerateAuthoringComponent]attribute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8EntityCommandBuffer"><span class="toc-number">5.2.4.</span> <span class="toc-text">使用EntityCommandBuffer</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BF%E9%97%AE%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.3.</span> <span class="toc-text">访问缓冲区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#EntityManager%E8%AE%BF%E9%97%AE%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.3.1.</span> <span class="toc-text">EntityManager访问缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E5%8F%A6%E4%B8%80%E4%B8%AAentity%E7%9A%84%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.3.2.</span> <span class="toc-text">查找另一个entity的缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SystemBase-Entities-ForEach%E8%AE%BF%E9%97%AE%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.3.3.</span> <span class="toc-text">SystemBase Entities.ForEach访问缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IJobChunk%E8%AE%BF%E9%97%AE%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.3.4.</span> <span class="toc-text">IJobChunk访问缓冲区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E8%A7%A3%E9%87%8A%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">5.4.</span> <span class="toc-text">重新解释缓冲区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA%E5%BC%95%E7%94%A8%E6%97%A0%E6%95%88"><span class="toc-number">5.5.</span> <span class="toc-text">缓冲区引用无效</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">6.</span> <span class="toc-text">Chunk component data</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%B9%B6%E8%AE%BE%E7%BD%AEchunk-component%E7%9A%84%E5%80%BC"><span class="toc-number">6.1.</span> <span class="toc-text">添加并设置chunk component的值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8Echunk-component"><span class="toc-number">6.2.</span> <span class="toc-text">声明chunk component</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAchunk-component"><span class="toc-number">6.3.</span> <span class="toc-text">创建一个chunk component</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96chunk-component"><span class="toc-number">6.4.</span> <span class="toc-text">读取chunk component</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E6%96%B0chunk-component"><span class="toc-number">6.5.</span> <span class="toc-text">更新chunk component</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4chunk-component"><span class="toc-number">6.6.</span> <span class="toc-text">删除chunk component</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8query%E4%B8%AD%E4%BD%BF%E7%94%A8chunk-component"><span class="toc-number">6.7.</span> <span class="toc-text">在query中使用chunk component</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%81%8D%E5%8E%86chunk%E4%BB%A5%E8%AE%BE%E7%BD%AEchunk-component"><span class="toc-number">6.8.</span> <span class="toc-text">遍历chunk以设置chunk component</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/20210912135042.png!webp);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">©&nbsp;2025 By 烟雨迷离半世殇</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">2018-2025 lfzxb.top版权所有<br><span id="realtime_duration"></span><br><a href="https://beian.miit.gov.cn" target="_blank">苏ICP备19003389号-1</a><br><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/20210912135040.png!webp" alt="公网安备字" loading='lazy'><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=32032102000159" target="_blank">苏公网安备 32032102000159号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="fluid-control-btn" type="button" title="流体模拟控制台"><i class="fas fa-water"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '508db6cacf197b7363d1',
      clientSecret: '2882a0b135eaa72b3ab256e37249c50733ce9e91',
      repo: 'wqaetly',
      owner: 'wqaetly',
      admin: ['wqaetly'],
      updateCountCallback: commentCount,
      proxy: "https://strong-caramel-969805.netlify.app/github_access_token",
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'd8d0adf96823dd03f4eeb1ff6e3551d4'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/dayjs/dayjs.min.js"></script><script src="https://cdn.jsdelivr.net/npm/dayjs/plugin/duration.min.js"></script><script src="/js/realtime.js"></script><script>window.FLUID_CONFIG={enable:true,mobile:false,z_index:-1,SIM_RESOLUTION:128,DYE_RESOLUTION:1024,DENSITY_DISSIPATION:1,VELOCITY_DISSIPATION:0.2,PRESSURE:0.8,PRESSURE_ITERATIONS:20,CURL:30,SPLAT_RADIUS:0.25,SPLAT_FORCE:6000,SHADING:true,COLORFUL:true,COLOR_UPDATE_SPEED:10,PAUSED:false,BACK_COLOR:{r:0,g:0,b:0},TRANSPARENT:false,BLOOM:true,BLOOM_ITERATIONS:8,BLOOM_RESOLUTION:256,BLOOM_INTENSITY:0.8,BLOOM_THRESHOLD:0.6,BLOOM_SOFT_KNEE:0.7,SUNRAYS:true,SUNRAYS_RESOLUTION:196,SUNRAYS_WEIGHT:1.0,interaction:{enable:true}};</script><script src="/js/fluid-simulation/dat.gui.min.js"></script><script src="/js/fluid-simulation/fluid-core.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'D3U85CARGJ',
    apiKey: '3edfc5bada9a140d5a4126085596f99c',
    indexName: 'blogsearch',
    container: '#docsearch',
    placeholder: '搜索文章',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div>
    <link rel="stylesheet" href="https://ai.tianli0.top/static/public/postChatUser_summary.min.css">
    <script>
        let tianliGPT_key = 'S-TY6LYYCZMYV6UADE';
        let tianliGPT_postSelector = '#article-container';
        let tianliGPT_Title = '烟雨迷离半世殇（人机版）为您总结文章';
        let tianliGPT_postURL = 'https://www.lfzxb.top/*/';
        let tianliGPT_blacklist = '';
        let tianliGPT_wordLimit = '50000';
        let tianliGPT_typingAnimate = false;
        let tianliGPT_theme = 'menghuan';
        var postChatConfig = {
          backgroundColor: "#3e86f6",
          bottom: "16px",
          left: "16px",
          fill: "#FFFFFF",
          width: "44px",
          frameWidth: "375px",
          frameHeight: "600px",
          defaultInput: false,
          upLoadWeb: true,
          showInviteLink: true,
          userTitle: "烟雨迷离半世殇（人机版）为您服务",
          userDesc: "在下定知无不言",
          addButton: true,
          beginningText: "这篇文章介绍了",
          userIcon: "https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp",
          userMode: "magic",
          defaultChatQuestions: ["你好","你是谁"],
          defaultSearchQuestions: ["视频压缩","设计"]
        };
    </script>
    <script data-postchat_key="S-TY6LYYCZMYV6UADE" src="https://ai.tianli0.top/static/public/postChatUser_summary.min.js"></script>
  </body></html>