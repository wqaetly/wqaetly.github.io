<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity DOTS：Systems部分 | 登峰造极者，殊途亦同归。</title><meta name="author" content="烟雨迷离半世殇"><meta name="copyright" content="烟雨迷离半世殇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Systems 一个system，也就是ECS里的S，提供了将component的数据从其当前状态变换到其下一个状态的逻辑-例如，一个system可以通过velocity乘以Time.deltaime来更新所有可移动entities的位置。  Instantiating systems Unity ECS自动在您的项目中发现system类型，并在运行时实例化它们。它将每个发现的system添加到默">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity DOTS：Systems部分">
<meta property="og:url" content="https://www.lfzxb.top/unity-dots-systems/index.html">
<meta property="og:site_name" content="登峰造极者，殊途亦同归。">
<meta property="og:description" content="Systems 一个system，也就是ECS里的S，提供了将component的数据从其当前状态变换到其下一个状态的逻辑-例如，一个system可以通过velocity乘以Time.deltaime来更新所有可移动entities的位置。  Instantiating systems Unity ECS自动在您的项目中发现system类型，并在运行时实例化它们。它将每个发现的system添加到默">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp">
<meta property="article:published_time" content="2021-02-04T00:00:00.000Z">
<meta property="article:modified_time" content="2021-02-04T00:00:00.000Z">
<meta property="article:author" content="烟雨迷离半世殇">
<meta property="article:tag" content="Unity技术">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="ECS">
<meta property="article:tag" content="Unity DOTS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Unity DOTS：Systems部分",
  "url": "https://www.lfzxb.top/unity-dots-systems/",
  "image": "https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp",
  "datePublished": "2021-02-04T00:00:00.000Z",
  "dateModified": "2021-02-04T00:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "烟雨迷离半世殇",
      "url": "https://www.lfzxb.top/www.lfzxb.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp"><link rel="canonical" href="https://www.lfzxb.top/unity-dots-systems/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="AhlEJ91V_L12bkwRF1ZS0BbytGCfsjqCX4GXztUluC8"><meta name="baidu-site-verification" content="iRRtEBalDiujISsN"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 8
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-7235595771604497',
  enable_page_level_ads: 'true'
});</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-XSL6D8K8G2"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-XSL6D8K8G2')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-XSL6D8K8G2', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":800,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity DOTS：Systems部分',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/CustomIcons/iconfontformaliyun.css"><meta name="referrer" content="no-referrer-when-downgrade"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar" loading='lazy'></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">246</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">188</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-torii-gate"></i><span> 蓬莱仙境</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-stream"></i><span> 白驹过隙</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 包罗万象</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分朋引类</span></a></div><div class="menus_item"><a class="site-page" href="/self/"><i class="fa-fw fas fa-id-card"></i><span> 择交而友</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 一见如故</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/202507052331881.png!webp" alt="Logo" loading='lazy'></a><a class="nav-page-title" href="/"><span class="site-name">Unity DOTS：Systems部分</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-torii-gate"></i><span> 蓬莱仙境</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-stream"></i><span> 白驹过隙</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 包罗万象</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分朋引类</span></a></div><div class="menus_item"><a class="site-page" href="/self/"><i class="fa-fw fas fa-id-card"></i><span> 择交而友</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 一见如故</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Unity DOTS：Systems部分</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-04T00:00:00.000Z" title="发表于 2021-02-04 00:00:00">2021-02-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-02-04T00:00:00.000Z" title="更新于 2021-02-04 00:00:00">2021-02-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/GamePlay/">GamePlay</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">游戏引擎</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/">Unity</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/GamePlay/ECS/">ECS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">12.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/unity-dots-systems/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;这篇文章已经&quot;,&quot;messageNext&quot;:&quot;天没维护了，相关内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2021-02-04 00:00:00&quot;}" hidden=""></div><div id="postchat_postcontent"><h1>Systems</h1>
<p>一个<strong>system</strong>，也就是ECS里的S，提供了将component的数据从其当前状态变换到其下一个状态的逻辑-例如，一个system可以通过velocity乘以Time.deltaime来更新所有可移动entities的位置。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages/image-20200813144636072.png!webp" alt="image-20200813144636072" loading='lazy'></p>
<h2 id="Instantiating-systems">Instantiating systems</h2>
<p>Unity ECS自动在您的项目中发现system类型，并在运行时实例化它们。它将每个发现的system添加到默认system groups之一中。您可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/system_update_order.html#attributes">system attributes</a>来指定system的父组以及该system在该group中的顺序。如果未指定父项，则Unity将以确定性的，但并未指定顺序的将system添加到默认世界的Simulation system group中。您也可以使用attribute禁用自动创建。</p>
<p>system的更新循环由其父<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/system_update_order.html">ComponentSystemGroup</a>驱动。ComponentSystemGroup本身是一种特殊的system，负责更新其child systems。group可以嵌套。system从运行的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.World.html">world</a>获取<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Core.TimeData.html">time</a>数据；time由<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.UpdateWorldTimeSystem.html">UpdateWorldTimeSystem</a>更新。</p>
<p>您可以使用<em>Entity Debugger window</em>（menu: <strong>Window</strong> &gt; <strong>Analysis</strong> &gt; <strong>Entity Debugger</strong>）查看system configuration。</p>
<h2 id="System类型">System类型</h2>
<p>Unity ECS提供了几种类型的systems。通常，为实现游戏行为和数据转换而编写的system将扩展<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html">SystemBase</a>。其他system类具有特殊目的。比如，通常情况下，您使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/entity_command_buffer.html">EntityCommandBufferSystem</a>和<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/system_update_order.html">ComponentSystemGroup</a>类的现有实例，而不是自己再进行拓展。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html">SystemBase-</a>创建自定义system时要实现的基类。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/entity_command_buffer.html">EntityCommandBufferSystem-</a>为其他systems提供<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityCommandBuffer.html">EntityCommandBuffer</a>实例。每个默认system group在其child system列表的开头和结尾都维护一个“ Entity Command Buffer System”。这使您可以对结构更改进行分组，以使它们在框架中产生更少的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/sync_points.html">syncronization points</a>。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/system_update_order.html">ComponentSystemGroup-</a>为其他systems提供嵌套的组织和更新顺序。默认情况下，Unity ECS创建多个Component System Groups。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/gp_overview.html">GameObjectConversionSystem-</a>将游戏的GameObject的转换为高效的entityGame conversion systems在Unity编辑器中运行。</li>
</ul>
<p><strong>重要提示：</strong><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.5/manual/entity_iteration_foreach.html">ComponentSystem</a>和<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.5/manual/entities_job_foreach.html">JobComponentSystem</a>类，以及<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.5/manual/entity_iteration_job.html">IJobForEach</a>，这些都是被淘汰的DOTS API，但是还没有官宣。请改用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html">SystemBase</a>和<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>。</p>
<h2 id="创建一个system">创建一个system</h2>
<p>实现抽象类<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html">SystemBase</a>创建来ECS中的systems。</p>
<p>要创建system，需要实现必要的一些生命周期函数回调。使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_OnUpdate_">SystemBase OnUpdate（）</a>函数执行system必须在每一帧中完成的工作。其他回调函数是可选的。例如，您可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentSystemBase.html#Unity_Entities_ComponentSystemBase_OnCreate_">OnCreate（）</a>来初始化system，但并非每个系统都需要初始化。</p>
<p>system回调函数按以下顺序调用：</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages/image-20200813151442570.png!webp" alt="image-20200813151442570" loading='lazy'></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentSystemBase.html#Unity_Entities_ComponentSystemBase_OnCreate_">OnCreate（）</a> -创建system时调用。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentSystemBase.html#Unity_Entities_ComponentSystemBase_OnStartRunning_">OnStartRunning（）</a> -在第一个<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_OnUpdate_">OnUpdate（）之前</a>以及每当system恢复运行时调用。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_OnUpdate_">OnUpdate（）</a> -system有工作要做的每一帧（请参见<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentSystemBase.html#Unity_Entities_ComponentSystemBase_ShouldRunSystem_">ShouldRunSystem（）</a>）并且系统已<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentSystemBase.html#Unity_Entities_ComponentSystemBase_Enabled">启用</a>时调用。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentSystemBase.html#Unity_Entities_ComponentSystemBase_OnStopRunning_">OnStopRunning（）</a>－每当system停止更新时调用，这可能是由于将<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentSystemBase.html#Unity_Entities_ComponentSystemBase_Enabled">Enabled</a>设置为false或因为找不到与它的query匹配的entities。在<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentSystemBase.html#Unity_Entities_ComponentSystemBase_OnDestroy_">OnDestroy（）</a>之前也会调用。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentSystemBase.html#Unity_Entities_ComponentSystemBase_OnDestroy_">OnDestroy（）</a> -销毁system时调用。</li>
</ul>
<p>system的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_OnUpdate_">OnUpdate（）</a>函数由其<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/system_update_order.html#groups">父系统组</a>自己的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_OnUpdate_">OnUpdate（）</a>函数触发。同样，当group更改状态时，例如，如果您设置了该group的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentSystemBase.html#Unity_Entities_ComponentSystemBase_Enabled">Enabled</a>属性，它也会更改其子systems的状态。但是，子systems也可以独立于parent group而改变状态。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/system_update_order.html">system update order</a>。</p>
<p>所有system生命周期函数都在主线程上运行。理想情况下，您的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_OnUpdate_">OnUpdate（）</a>函数可以schedules jobs以执行大部分工作。要从system schedules jobs，您可以使用以下机制之一：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach-</a>迭代ECS component数据的最简单方法。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Job">Job.WithCode-</a>将lambda函数作为单个后台job执行。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.IJobChunk.html">IJobChunk-</a>一种“底层”机制，用于逐chunk迭代ECS components数据。</li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/JobSystem.html">C＃Job System</a> -创建和规划通用的C＃ Job。</li>
</ul>
<p>以下示例说明了使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>来实现一种system，该system根据一个component来更新另一个component的值：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Position : IComponentData</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> float3 Value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> Velocity : IComponentData</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> float3 Value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ECSSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Local variable captured in ForEach</span></span><br><span class="line">        <span class="comment">// 在ForEach中被使用的本地变量</span></span><br><span class="line">        <span class="built_in">float</span> dT = Time.DeltaTime;</span><br><span class="line"></span><br><span class="line">        Entities</span><br><span class="line">            .WithName(<span class="string">"Update_Displacement"</span>)</span><br><span class="line">            .ForEach(</span><br><span class="line">                (<span class="keyword">ref</span> Position position, <span class="keyword">in</span> Velocity velocity) =&gt;</span><br><span class="line">                {</span><br><span class="line">                    position = <span class="keyword">new</span> Position()</span><br><span class="line">                    {</span><br><span class="line">                        Value = position.Value + velocity.Value * dT</span><br><span class="line">                    };</span><br><span class="line">                }</span><br><span class="line">            )</span><br><span class="line">            .ScheduleParallel();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1>使用Entities.ForEach创建systems</h1>
<p>使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html">SystemBase</a>类提供的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>构造作为在entities及其components上定义和执行算法的简洁方法。<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>在由<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityQuery.html">entity query</a>选择出的的所有<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">entities</a>上执行您定义的lambda函数。</p>
<p>要执行job Lambda函数，您可以使用<code>Schedule()</code>和<code>ScheduleParallel()</code>来schedule job，或者使用<code>Run()</code>来立即执行该job（在<em>主线程</em>上）。您可以使用在<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>上定义的其他方法来设置entity query以及各种job选项。</p>
<p>下面的示例说明了一个简单的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html">SystemBase</a>实现，该实现使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>读取一个entity的component（为Velocity）并写入另一个component（Translation）：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">ApplyVelocitySystem</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        Entities</span><br><span class="line">            .ForEach((<span class="keyword">ref</span> Translation translation,</span><br><span class="line">            <span class="keyword">in</span> Velocity velocity) =&gt;</span><br><span class="line">            {</span><br><span class="line">                translation.Value += velocity.Value;</span><br><span class="line">            })</span><br><span class="line">            .Schedule();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>请注意ForEach lambda函数的参数关键字<code>ref</code>以及<code>in</code>的使用。使用<code>ref</code>修饰的component，可读写，使用<code>in</code>修饰的component，只读。将component标记为只读可帮助job scheduler程序更有效地执行job。</p>
<h2 id="选择entities">选择entities</h2>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>提供了自己的机制，用于定义用于选择要处理的entities的entity query。该query自动包括您符合lambda函数参数的所有components。你也可以使用<code>WithAll</code>，<code>WithAny</code>及<code>WithNone</code>条款，以进一步细化哪些entities被选中。有关query选项的完整内容，请参见<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">SystemBase.Entities</a>。</p>
<p>下面的示例选择具有以下components的entities：Destination，Source和LocalToWorld。并具有Rotation，Translation或Scale中的至少一项；但没有LocalToParent。</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Entities.WithAll&lt;LocalToWorld&gt;()</span><br><span class="line">    .WithAny&lt;Rotation, Translation, Scale&gt;()</span><br><span class="line">    .WithNone&lt;LocalToParent&gt;()</span><br><span class="line">    .ForEach((<span class="keyword">ref</span> Destination outputData, <span class="keyword">in</span> Source inputData) =&gt;</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">/* do some work */</span></span><br><span class="line">    })</span><br><span class="line">    .Schedule();</span><br></pre></td></tr></tbody></table></figure>
<p>在此示例中，在lambda函数内部只能访问目标和源components，因为它们是参数列表中的唯一的components。</p>
<h3 id="访问EntityQuery对象">访问EntityQuery对象</h3>
<p>要访问<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>创建的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityQuery.html">EntityQuery</a>对象，请使用[WithStoreEntityQueryInField（ref query）]和ref参数修饰符。此函数将query的引用分配给您提供的字段。</p>
<p>下面的示例说明如何访问为<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>构造隐式创建的EntityQuery对象。在这种情况下，该示例使用EntityQuery对象调用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityQuery.html#Unity_Entities_EntityQuery_CalculateEntityCount_">CalculateEntityCount（）</a>方法。该示例使用此计数来创建一个本地化数组，该数组具有足够的空间来为query选择的每个entity存储一个值：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EntityQuery query;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="built_in">int</span> dataCount = query.CalculateEntityCount();</span><br><span class="line">    NativeArray&lt;<span class="built_in">float</span>&gt; dataSquared</span><br><span class="line">        = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">float</span>&gt;(dataCount, Allocator.Temp);</span><br><span class="line">    Entities</span><br><span class="line">        .WithStoreEntityQueryInField(<span class="keyword">ref</span> query)</span><br><span class="line">        .ForEach((<span class="built_in">int</span> entityInQueryIndex, <span class="keyword">in</span> Data data) =&gt;</span><br><span class="line">        {</span><br><span class="line">            dataSquared[entityInQueryIndex] = data.Value * data.Value;</span><br><span class="line">        })</span><br><span class="line">        .ScheduleParallel();</span><br><span class="line"></span><br><span class="line">    Job</span><br><span class="line">        .WithCode(() =&gt;</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//Use dataSquared array...</span></span><br><span class="line">        <span class="keyword">var</span> v = dataSquared[dataSquared.Length - <span class="number">1</span>];</span><br><span class="line">    })</span><br><span class="line">        .WithDisposeOnCompletion(dataSquared)</span><br><span class="line">        .Schedule();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="可选components">可选components</h3>
<p>您无法创建指定可选component的query（使用<code>WithAny&lt;T，U&gt;</code>），也无法在lambda函数中访问那些components。如果需要读取或写入可选component，则可以将Entities.ForEach构造拆分为多个job(每个可选components的组合是一个job)。</p>
<p>例如，如果您有两个可选components，有两种方案</p>
<ul>
<li>需要三个ForEach构造：一个包含第一个可选component，一个包含第二个可选component，一个包含两个components</li>
<li>另一种选择是使用IJobChunk逐chunk进行迭代。</li>
</ul>
<h3 id="更改filtering（过滤选项）">更改filtering（过滤选项）</h3>
<p>如果自上次运行当前<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html">SystemBase</a>实例以来，仅想在该component的另一个entity发生更改时处理该entity component，则可以使用<code>WithChangeFilter &lt;T&gt;</code>启用更改filtering。更改filter中使用的component类型必须处于lambda函数参数列表中，或者必须是<code>WithAll &lt;T&gt;</code>语句的一部分。</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Entities</span><br><span class="line">    .WithChangeFilter&lt;Source&gt;()</span><br><span class="line">    .ForEach((<span class="keyword">ref</span> Destination outputData,</span><br><span class="line">        <span class="keyword">in</span> Source inputData) =&gt;</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">/* Do work */</span></span><br><span class="line">        })</span><br><span class="line">    .ScheduleParallel();</span><br></pre></td></tr></tbody></table></figure>
<p>entity query最多支持两种component类型的change filtering。</p>
<p><em>请注意，change filtering应用于chunk级别。如果有任何代码通过写访问权限访问了chunk中的某个component，则该chunk中该component的类型将标记为已更改-即使该代码实际上并未更改任何数据。</em></p>
<h3 id="Shared-component-filtering">Shared component filtering</h3>
<p>具有shared component的entity与其他具有相同shared component值的entities分组在一起。您可以使用WithSharedComponentFilter（）函数选择具有特定shared component值的entities group。</p>
<p>以下示例选择按Cohort ISharedComponentData分组的entities。此示例中的lambda函数根据entity的Cohort设置DisplayColor IComponentData组件：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ColorCycleJob</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        List&lt;Cohort&gt; cohorts = <span class="keyword">new</span> List&lt;Cohort&gt;();</span><br><span class="line">        EntityManager.GetAllUniqueSharedComponentData&lt;Cohort&gt;(cohorts);</span><br><span class="line">        <span class="keyword">foreach</span> (Cohort cohort <span class="keyword">in</span> cohorts)</span><br><span class="line">        {</span><br><span class="line">            DisplayColor newColor = ColorTable.GetNextColor(cohort.Value);</span><br><span class="line">            Entities.WithSharedComponentFilter(cohort)</span><br><span class="line">                .ForEach((<span class="keyword">ref</span> DisplayColor color) =&gt; { color = newColor; })</span><br><span class="line">                .ScheduleParallel();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>该示例使用EntityManager来获取所有不同的的Cohort值。然后，它为每个Cohort调度一个lambda job，将新颜色作为捕获变量传递给lambda函数。</p>
<h2 id="定义ForEach函数">定义ForEach函数</h2>
<p>定义与<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>一起使用的lambda函数时，可以声明参数，<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html">SystemBase</a>类在执行该函数时使用该参数传递有关当前entity的信息。</p>
<p>典型的lambda函数如下所示：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Entities.ForEach(</span><br><span class="line">    (Entity entity,</span><br><span class="line">        <span class="built_in">int</span> entityInQueryIndex,</span><br><span class="line">        <span class="keyword">ref</span> Translation translation,</span><br><span class="line">        <span class="keyword">in</span> Movement move) =&gt; { <span class="comment">/* .. */</span>})</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下，您最多可以将八个参数传递给Entities.ForEach lambda函数。（如果需要传递更多参数，则可以<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/ecs_entities_foreach.html#custom-delegates">定义自定义委托</a>。）使用标准委托时，必须按以下顺序对参数进行分组：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Parameters passed-<span class="keyword">by</span>-<span class="function"><span class="keyword">value</span> <span class="title">first</span>(<span class="params">参数传递的值</span>) (<span class="params">no parameter modifiers(无修饰符</span>))</span></span><br><span class="line"><span class="function">Writable parameters <span class="title">second</span>(<span class="params">可读写参数</span>)(<span class="params">`<span class="keyword">ref</span>` parameter modifier(<span class="keyword">ref</span>修饰符</span>))</span></span><br><span class="line"><span class="function">Read-only parameters <span class="title">last</span> (<span class="params">只读参数</span>)(<span class="params">`<span class="keyword">in</span>` parameter modifier(<span class="keyword">in</span>修饰符</span>))</span></span><br></pre></td></tr></tbody></table></figure>
<p>所有components都应使用<code>ref</code>或<code>in</code>参数修饰符。否则，传递给您的函数的components struct是副本而不是引用。这意味着为只读参数提供了额外的内存副本，并且意味着在函数返回后（复制的结构超出范围时）对要更新的component的任何更改都会被静默丢弃。</p>
<p>如果您的函数不遵守这些规则，并且您尚未创建合适的委托，则编译器将提供类似于以下内容的错误：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error CS1593: Delegate <span class="string">'Invalid_ForEach_Signature_See_ForEach_Documentation_For_Rules_And_Restrictions'</span> does <span class="keyword">not</span> take N argumentscs</span><br></pre></td></tr></tbody></table></figure>
<p>（请注意，即使问题是参数顺序，错误消息也会将会是这个报错。）</p>
<h3 id="自定义委托">自定义委托</h3>
<p>您可以在ForEach lambda函数中使用8个以上的参数。通过声明自己的委托类型和ForEach重载。这使您可以根据需要使用任意数量的参数，并以任意顺序放置ref / in / value参数。</p>
<p>你可以在任何地方声明有三个<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/ecs_entities_foreach.html#named-parameters">特殊，命名参数</a> <code>entity</code>，<code>entityInQueryIndex</code>和<code>nativeThreadIndex</code>参数列表的委托。<strong>但请勿对这些参数使用<code>ref</code>或<code>in</code>修饰符。</strong></p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">BringYourOwnDelegate</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// Declare the delegate that takes 12 parameters. T0 is used for the Entity argument</span></span><br><span class="line">    <span class="comment">// 声明12个参数的委托，T0被用来当做Entity参数</span></span><br><span class="line">    [<span class="meta">Unity.Entities.CodeGeneratedJobForEach.EntitiesForEachCompatible</span>]</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">CustomForEachDelegate</span>&lt;<span class="title">T0</span>, <span class="title">T1</span>, <span class="title">T2</span>, <span class="title">T3</span>, <span class="title">T4</span>, <span class="title">T5</span>, <span class="title">T6</span>, <span class="title">T7</span>, <span class="title">T8</span>, <span class="title">T9</span>, <span class="title">T10</span>, <span class="title">T11</span>&gt;</span></span><br><span class="line"><span class="function">        (<span class="params">T0 t0, <span class="keyword">in</span> T1 t1, <span class="keyword">in</span> T2 t2, <span class="keyword">in</span> T3 t3, <span class="keyword">in</span> T4 t4, <span class="keyword">in</span> T5 t5,</span></span></span><br><span class="line"><span class="params"><span class="function">         <span class="keyword">in</span> T6 t6, <span class="keyword">in</span> T7 t7, <span class="keyword">in</span> T8 t8, <span class="keyword">in</span> T9 t9, <span class="keyword">in</span> T10 t10, <span class="keyword">in</span> T11 t11</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Declare the function overload</span></span><br><span class="line">    <span class="comment">// 声明ForEach重载</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TDescription <span class="title">ForEach</span>&lt;<span class="title">TDescription</span>, <span class="title">T0</span>, <span class="title">T1</span>, <span class="title">T2</span>, <span class="title">T3</span>, <span class="title">T4</span>, <span class="title">T5</span>, <span class="title">T6</span>, <span class="title">T7</span>, <span class="title">T8</span>, <span class="title">T9</span>, <span class="title">T10</span>, <span class="title">T11</span>&gt;</span></span><br><span class="line"><span class="function">        (<span class="params"><span class="keyword">this</span> TDescription description, CustomForEachDelegate&lt;T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11&gt; codeToRun</span>)</span></span><br><span class="line"><span class="function">        <span class="keyword">where</span> TDescription : <span class="keyword">struct</span>, Unity.Entities.CodeGeneratedJobForEach.ISupportForEachWithUniversalDelegate</span> =&gt;</span><br><span class="line">        LambdaForEachDescriptionConstructionMethods.ThrowCodeGenException&lt;TDescription&gt;();</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// A system that uses the custom delegate and overload</span></span><br><span class="line"><span class="comment">// 一个使用自定义委托和重载的示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MayParamsSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        Entities.ForEach(</span><br><span class="line">                (Entity entity0,</span><br><span class="line">                    <span class="keyword">in</span> Data1 d1,</span><br><span class="line">                    <span class="keyword">in</span> Data2 d2,</span><br><span class="line">                    <span class="keyword">in</span> Data3 d3,</span><br><span class="line">                    <span class="keyword">in</span> Data4 d4,</span><br><span class="line">                    <span class="keyword">in</span> Data5 d5,</span><br><span class="line">                    <span class="keyword">in</span> Data6 d6,</span><br><span class="line">                    <span class="keyword">in</span> Data7 d7,</span><br><span class="line">                    <span class="keyword">in</span> Data8 d8,</span><br><span class="line">                    <span class="keyword">in</span> Data9 d9,</span><br><span class="line">                    <span class="keyword">in</span> Data10 d10,</span><br><span class="line">                    <span class="keyword">in</span> Data11 d11</span><br><span class="line">                    ) =&gt; {<span class="comment">/* .. */</span>})</span><br><span class="line">            .Run();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>**注意：**ForEach lambda函数默认八个参数限制，因为声明太多的委托和重载会对IDE性能产生负面影响。ref / in / value和参数数量的每种组合都需要唯一的委托类型和ForEach重载。</p>
<h3 id="Component参数">Component参数</h3>
<p>要访问与entity关联的component，您必须将该component类型的参数传递给lambda函数。编译器会自动将传递给函数的所有components作为必需components添加到entity query中。</p>
<p>要更新component值，必须使用<code>ref</code>参数列表中的关键字通过引用将其传递给lambda函数。（没有<code>ref</code>关键字，将对component的临时副本进行任何修改，因为它将通过值进行传递。）</p>
<p>要将传递给lambda函数的components指定为只读，请在参数列表中使用<code>in</code>关键字。</p>
<p>**注意：**使用<code>ref</code>表示当前chunk中的components被标记为已更改，即使lambda函数实际上并未对其进行修改。为了提高效率，请始终使用<code>in</code>关键字将lambda函数不会修改的components指定为只读。</p>
<p>以下示例将Source component作为只读参数传递给job，并将Destination component作为可写参数传递给作业：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Entities.ForEach(</span><br><span class="line">    (<span class="keyword">ref</span> Destination outputData,</span><br><span class="line">        <span class="keyword">in</span> Source inputData) =&gt;</span><br><span class="line">    {</span><br><span class="line">        outputData.Value = inputData.Value;</span><br><span class="line">    })</span><br><span class="line">    .ScheduleParallel();</span><br></pre></td></tr></tbody></table></figure>
<p>**注意：**当前，您不能将chunk component传递给Entities.ForEach lambda函数。</p>
<p>对于dynamic buffers，请使用<code>DynamicBuffer &lt;T&gt;</code>而不是存储在buffers中的Component类型：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BufferSum</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> EntityQuery query;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Schedules the two jobs with a dependency between them</span></span><br><span class="line">    <span class="comment">//使用一个在两个job之间的一个dependency来规划他们</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">//The query variable can be accessed here because we are</span></span><br><span class="line">        <span class="comment">//using WithStoreEntityQueryInField(query) in the entities.ForEach below</span></span><br><span class="line">        <span class="comment">//这个query的变量可以在这里获取到，是因为我们在这个entities.ForEach中使用了WithStoreEntityQueryInField(query)</span></span><br><span class="line">        <span class="built_in">int</span> entitiesInQuery = query.CalculateEntityCount();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Create a native array to hold the intermediate sums</span></span><br><span class="line">        <span class="comment">//(one element per entity)</span></span><br><span class="line">        <span class="comment">//创建一个本地化的数组来存储中间和（每个entity的元素）</span></span><br><span class="line">        NativeArray&lt;<span class="built_in">int</span>&gt; intermediateSums</span><br><span class="line">            = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">int</span>&gt;(entitiesInQuery, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Schedule the first job to add all the buffer elements</span></span><br><span class="line">        <span class="comment">//规划第一个job来相加所有的缓冲区内元素</span></span><br><span class="line">        Entities</span><br><span class="line">            .ForEach((<span class="built_in">int</span> entityInQueryIndex, <span class="keyword">in</span> DynamicBuffer&lt;IntBufferData&gt; buffer) =&gt;</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; buffer.Length; i++)</span><br><span class="line">            {</span><br><span class="line">                intermediateSums[entityInQueryIndex] += buffer[i].Value;</span><br><span class="line">            }</span><br><span class="line">        })</span><br><span class="line">            .WithStoreEntityQueryInField(<span class="keyword">ref</span> query)</span><br><span class="line">            .WithName(<span class="string">"IntermediateSums"</span>)</span><br><span class="line">            .ScheduleParallel(); <span class="comment">// Execute in parallel for each chunk of entities</span></span><br><span class="line">        <span class="comment">//并行执行每个chunk中的entities</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Schedule the second job, which depends on the first</span></span><br><span class="line">        <span class="comment">//规划第二个job，他依赖第一个job</span></span><br><span class="line">        Job</span><br><span class="line">            .WithCode(() =&gt;</span><br><span class="line">        {</span><br><span class="line">            <span class="built_in">int</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; intermediateSums.Length; i++)</span><br><span class="line">            {</span><br><span class="line">                result += intermediateSums[i];</span><br><span class="line">            }</span><br><span class="line">            <span class="comment">//Not burst compatible:</span></span><br><span class="line">            <span class="comment">//对burst不兼容</span></span><br><span class="line">            Debug.Log(<span class="string">"Final sum is "</span> + result);</span><br><span class="line">        })</span><br><span class="line">            .WithDisposeOnCompletion(intermediateSums)</span><br><span class="line">            .WithoutBurst()</span><br><span class="line">            .WithName(<span class="string">"FinalSum"</span>)</span><br><span class="line">            .Schedule(); <span class="comment">// Execute on a single, background thread</span></span><br><span class="line">        <span class="comment">//执行在一个单一的后台线程</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="特殊的命名参数">特殊的命名参数</h3>
<p>除了component之外，您还可以将以下特殊的命名参数传递给Entities.ForEach lambda函数，这些参数是根据job当前正在处理的entity分配的值：</p>
<ul>
<li><strong><code>Entity entity</code></strong>—当前entity的Entity实例。（参数的名称可以是任何类型，只要类型是Entity。）</li>
<li><strong><code>int entityInQueryIndex</code></strong>—该entity在query选择的所有entities的列表中的索引。当您有一个<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html">本地化数组</a>需要为每个entity填充一个唯一值时，请使用entityInQueryIndex。您可以将entityInQueryIndex用作该数组中的索引。EntityInQueryIndex也应用作<code>sortKey</code>将命令添加到并发<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityCommandBuffer.html">EntityCommandBuffer</a>。</li>
<li><strong><code>int nativeThreadIndex</code></strong>—执行lambda函数当前迭代的线程的唯一索引。使用Run（）执行lambda函数时，nativeThreadIndex始终为零。（不要将<code>nativeThreadIndex</code>用作并发<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityCommandBuffer.html">EntityCommandBuffer</a>的<code>sortKey</code>；请改为使用<code>entityInQueryIndex</code>。）</li>
</ul>
<h2 id="捕获变量">捕获变量</h2>
<p>您可以捕获Entities.ForEach lambda函数的局部变量。使用job执行函数时（通过调用Schedule几个函数之一而不是Run），对捕获的变量及其使用方式有一些限制：</p>
<ul>
<li>只能捕获本地化容器和可漂白类型。</li>
<li>job只能写入类型为本地化容器的捕获变量。（要“返回”单个值，请使用一个元素创建一个<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html">本地化数组</a>。）</li>
</ul>
<p>如果您读取了[本地化容器]，但未写入该容器，请始终使用来指定只读访问权限<code>WithReadOnly(variable)</code>。有关设置捕获变量的属性的更多信息，请参见<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">SystemBase.Entities</a>。您可以指定的属性包括<code>NativeDisableParallelForRestriction</code>及其他。<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>将这些作为函数提供，因为C＃语言不允许在局部变量上使用attribute。</p>
<p>您还可以使用表示要在<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>运行之后Dispose捕获的NativeContainer或包含NativeContainers的类型<code>WithDisposeOnCompletion(variable)</code>。这将在lambda运行之后立即Dispose类型（对于<code>Run()</code>），或者安排它们稍后通过Job进行Dispose并返回JobHandle（对于<code>Schedule()</code>/ <code>ScheduleParallel()</code>）。</p>
<p>**注意：**在通过<code>Run()</code>执行函数时，您可以写入不是本地化容器的捕获变量。但是，您仍应尽可能使用<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/framework/interop/blittable-and-non-blittable-types">blittable</a>类型，以便可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.burst@latest/index.html">Burst</a>编译函数。</p>
<h2 id="支持的功能">支持的功能</h2>
<p>您可以使用在主线程上使用<code>Run()</code>执行lambda函数，在单个后台线程使用<code>Schedule()</code>执行job，或者使用<code>ScheduleParallel()</code>来让多线程并行执行。这些不同的执行方法对访问数据的方式具有不同的约束。另外，<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.burst@latest/index.html">Burst</a>使用C＃语言的受限子集，在此子集之外使用C＃功能（包括访问托管类型）时您需要指定<code>WithoutBurst()</code>。</p>
<p>下表显示了<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>当前支持哪些功能，用于<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html">SystemBase中</a>可用的各种计划方法：</p>
<table>
<thead>
<tr>
<th style="text-align:left">支持功能</th>
<th style="text-align:left">Run</th>
<th style="text-align:left">Schedule</th>
<th style="text-align:left">ScheduleParallel</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">捕获局部值类型</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">捕获局部引用类型</td>
<td style="text-align:left">x（仅不带Burst）</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">写入捕获的变量</td>
<td style="text-align:left">X</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">System命名空间下的字段</td>
<td style="text-align:left">x（仅不带Burst）</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">引用类型的方法</td>
<td style="text-align:left">x（仅不带Burst）</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Shared Components</td>
<td style="text-align:left">x（仅不带Burst）</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">Managed Components</td>
<td style="text-align:left">x（仅不带Burst）</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">结构体变化</td>
<td style="text-align:left">x（仅不带Burst和WithStructuralChanges）</td>
<td style="text-align:left"></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">SystemBase.GetComponent</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">SystemBase.SetComponent</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:left">GetComponentDataFromEntity</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">x（仅作为ReadOnly）</td>
</tr>
<tr>
<td style="text-align:left">HasComponent</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
<tr>
<td style="text-align:left">WithDisposeOnCompletion</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
<td style="text-align:left">X</td>
</tr>
</tbody>
</table>
<p>一个<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>构造使用专门的中间语言（IL）编译后处理你写的代码来转换成正确的ECS的代码。这种自动翻译使您无需包含复杂的样板代码即可表达算法的意图。但是，这可能意味着不允许使用某些常见的代码编写方式。</p>
<p>当前不支持以下功能：</p>
<table>
<thead>
<tr>
<th style="text-align:left">不支持的功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Dynamic code in .With invocations</td>
</tr>
<tr>
<td style="text-align:left">被ref修饰的SharedComponent参数</td>
</tr>
<tr>
<td style="text-align:left">嵌套的Entities.ForEach lambda expressions</td>
</tr>
<tr>
<td style="text-align:left">标有[ExecuteAlways]的系统中的Entities.ForEach（当前已修复）</td>
</tr>
<tr>
<td style="text-align:left">使用存储在变量，字段或方法中的委托进行调用</td>
</tr>
<tr>
<td style="text-align:left">具有lambda参数类型的SetComponent</td>
</tr>
<tr>
<td style="text-align:left">具有可写lambda参数的GetComponent</td>
</tr>
<tr>
<td style="text-align:left">Lambdas中的泛型参数</td>
</tr>
<tr>
<td style="text-align:left">在具有泛型参数的systems中</td>
</tr>
</tbody>
</table>
<h2 id="Dependencies">Dependencies</h2>
<p>默认情况下，系统使用其<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Dependency">Dependency</a>属性管理与ECS相关的依赖<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Dependency">关系</a>。默认情况下，系统将按<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>和[Job.WithCode] 创建的每个job按它们在<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_OnUpdate_">OnUpdate（）</a>函数中出现的顺序添加到<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Dependency">Dependency</a> job句柄中。您还可以通过将[JobHandle]传递给函数来手动管理job依赖关系，然后返回结果依赖关系。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Dependency">依赖性</a>。<code>Schedule</code></p>
<p>有关<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/ecs_job_dependencies.html">job依赖性</a>的更多常规信息，请参见job依赖性。</p>
<h1>使用Job.WithCode创建Systems</h1>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html">SystemBase</a>类提供的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Job">Job.WithCode</a>构造是一种将函数作为单个后台job运行的简便方法。您甚至可以在主线程上运行<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Job">Job.WithCode</a>，并且仍然可以利用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.burst@latest/index.html">Burst</a>编译来加快执行速度。</p>
<p>以下示例使用一个<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Job">Job.WithCode</a> lambda函数用随机数填充<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html">本地化数组</a>，并使用另一个job将这些数字加在一起：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RandomSumJob</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">uint</span> seed = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        Random randomGen = <span class="keyword">new</span> Random(seed++);</span><br><span class="line">        NativeArray&lt;<span class="built_in">float</span>&gt; randomNumbers</span><br><span class="line">            = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">float</span>&gt;(<span class="number">500</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">        Job.WithCode(() =&gt;</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; randomNumbers.Length; i++)</span><br><span class="line">            {</span><br><span class="line">                randomNumbers[i] = randomGen.NextFloat();</span><br><span class="line">            }</span><br><span class="line">        }).Schedule();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To get data out of a job, you must use a NativeArray</span></span><br><span class="line">        <span class="comment">// even if there is only one value</span></span><br><span class="line">        <span class="comment">// 想要在job外获取data，你必须使用一个本地化数组</span></span><br><span class="line">        <span class="comment">// 即使他只有一个值</span></span><br><span class="line">        NativeArray&lt;<span class="built_in">float</span>&gt; result</span><br><span class="line">            = <span class="keyword">new</span> NativeArray&lt;<span class="built_in">float</span>&gt;(<span class="number">1</span>, Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">        Job.WithCode(() =&gt;</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; randomNumbers.Length; i++)</span><br><span class="line">            {</span><br><span class="line">                result[<span class="number">0</span>] += randomNumbers[i];</span><br><span class="line">            }</span><br><span class="line">        }).Schedule();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This completes the scheduled jobs to get the result immediately, but for</span></span><br><span class="line">        <span class="comment">// better efficiency you should schedule jobs early in the frame with one</span></span><br><span class="line">        <span class="comment">// system and get the results late in the frame with a different system.</span></span><br><span class="line">        <span class="comment">// 这个语句会立即完成调度来获取结果，但是为了更好的效率，你应该在这一帧的早些时候使用一个system调度这个job，并且在这一帧的晚些时候使用另一个system获取结果</span></span><br><span class="line">        <span class="keyword">this</span>.CompleteDependency();</span><br><span class="line">        UnityEngine.Debug.Log(<span class="string">"The sum of "</span></span><br><span class="line">            + randomNumbers.Length + <span class="string">" numbers is "</span> + result[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        randomNumbers.Dispose();</span><br><span class="line">        result.Dispose();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>**注意：**要运行并行的job，请实现<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/JobSystemCreatingJobs.html">IJobFor</a>，您可以使用系统<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_OnUpdate_">OnUpdate（）</a>函数中的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobForExtensions.ScheduleParallel.html">ScheduleParallel（）</a>进行<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.IJobForExtensions.ScheduleParallel.html">调度</a>。</p>
<h2 id="变量">变量</h2>
<p>您不能将参数传递给<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Job">Job.WithCode</a> lambda函数或返回一个值。取而代之的是，您可以在<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_OnUpdate_">OnUpdate（）</a>函数中捕获局部变量。</p>
<p>当你在<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/JobSystem.html">C＃Job System</a>中使用<code>Schedule()</code>调度你的job时，还有额外的限制：</p>
<ul>
<li>捕获的变量必须声明为 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html">NativeArray-</a>或其他<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/JobSystemNativeContainer.html">本地化容器</a> -或<a target="_blank" rel="noopener" href="https://docs.microsoft.com/en-us/dotnet/framework/interop/blittable-and-non-blittable-types">blittable</a>类型。</li>
<li>要返回数据，即使数据是单个值，也必须将返回值写入捕获的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html">本地化数组</a>。（请注意，使用<code>Run()</code>时，您可以写入任何捕获的变量。）</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Job">Job.WithCode</a>提供了一组函数，以将只读属性和安全属性应用于捕获的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/JobSystemNativeContainer.html">本地化容器</a>变量。例如，您可以用<code>WithReadOnly</code>来指定您不更新容器，并用<code>WithDisposeOnCompletion</code>在job结束后自动处理容器。（<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>提供相同的功能。）</p>
<p>有关这些修饰符和属性的更多信息，请参见<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Job">Job.WithCode</a>。</p>
<h2 id="执行函数">执行函数</h2>
<p>您有两种选择来执行lambda函数：</p>
<ul>
<li><code>Schedule()</code>-将功能作为单个非并行job执行。调度job在后台线程上运行代码，因此可以更好地利用可用的CPU资源。</li>
<li><code>Run()</code>-在主线程上立即执行功能。在大多数情况下，可以对<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Job">Burst.WithCode</a>进行<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.burst@latest/index.html">Burst</a>编译，因此即使<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Job">Job.WithCode</a>仍在主线程上运行，其执行代码也可以更快。</li>
</ul>
<p>请注意，调用会<code>Run()</code>自动完成<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Job">Job.WithCode</a>构造的所有依赖关系。如果未明确为<code>Run()</code>system传入<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html">JobHandle</a>对象，则假定当前<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Dependency">Dependency</a>属性表示该函数的依赖关系。（如果函数没有依赖关系，请<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html">传入</a>新的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html">JobHandle</a>。）</p>
<h2 id="依存关系">依存关系</h2>
<p>默认情况下，system使用其<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Dependency">Dependency</a>属性管理与ECS相关的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Dependency">依赖关系</a>。system<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Job">将按</a><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>和<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Job">Job.WithCode</a>创建的每个job按它们在<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_OnUpdate_">OnUpdate（）</a>函数中出现的顺序<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Job">添加</a>到<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Dependency">Dependency</a>job句柄中。您还可以通过将<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html">JobHandle</a>传递给<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html">函数</a>来手动管理job依赖性，然后将其返回结果依赖性。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Dependency">依赖性</a>。<code>Schedule</code></p>
<p>有关<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/ecs_job_dependencies.html">作业依赖性</a>的更多常规信息，请参见作业依赖性。</p>
<h1>使用IJobChunk jobs创建System</h1>
<p>您可以在system内部实现<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.IJobChunk.html">IJobChunk</a>，以逐chunk遍历数据。当您在<code>OnUpdate()</code>功能中调度IJobChunk job时，该job为每个能匹配上由entity query传递给job <code>Schedule()</code>的chunk调用<code>Excute()</code>。然后，您可以逐entity地遍历每个chunk内的数据。</p>
<p>与Entities.ForEach相比，使用IJobChunk进行迭代需要更多的代码设置，但是也更明确，并且代表对数据的最直接访问，因为它才是真正被存储的对象。</p>
<p>按chunk进行迭代的另一个好处是，您可以使用<code>Archetype.Has&lt;T&gt;()</code>来检查每个chunk中是否存在可选component，然后相应地处理chunk中的所有entities。</p>
<p>要实现IJobChunk job，请使用以下步骤：</p>
<ol>
<li>创建一个<code>EntityQuery</code>以标识要处理的entities。</li>
<li>定义job结构，并包括<code>ArchetypeChunkComponentType</code>对象的字段，这些字段标识job必须直接访问的components的类型。另外，指定job是读还是写这些component。</li>
<li>实例化job结构并在system<code>OnUpdate()</code>函数中调度job。</li>
<li>在该<code>Execute()</code>函数中，获取job读或写的component的<code>NativeArray</code>实例，然后在当前chunk上进行迭代以执行所需的工作。</li>
</ol>
<p>有关更多信息，<a target="_blank" rel="noopener" href="https://github.com/Unity-Technologies/EntityComponentSystemSamples">ECS samples repository</a>包含一个简单的HelloCube示例，演示了如何使用<code>IJobChunk</code>。</p>
<h2 id="使用EntityQuery查询数据">使用EntityQuery查询数据</h2>
<p>EntityQuery定义了archetype必须包含的一组components类型，system才能处理其关联的chunks和entities。archetype可以具有其他components，但是它必须至少包含EntityQuery定义的component。您还可以排除包含特定类型components的archetype。</p>
<p>对于简单query，可以使用该<code>SystemBase.GetEntityQuery()</code>函数并按如下所示传入component类型：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RotationSpeedSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> EntityQuery m_Query;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        m_Query = GetEntityQuery(ComponentType.ReadOnly&lt;Rotation&gt;(),</span><br><span class="line">            ComponentType.ReadOnly&lt;RotationSpeed&gt;());</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对于更复杂的情况，您可以使用<code>EntityQueryDesc</code>。一个<code>EntityQueryDesc</code>提供了灵活的查询机制，以指定的组件类型：</p>
<ul>
<li><code>All</code>：此数组中的所有components类型必须存在于archetype中</li>
<li><code>Any</code>：archetype中必须存在此数组中的至少一种component类型</li>
<li><code>None</code>：archetype中不能存在此数组中的任何component类型</li>
</ul>
<p>例如，以下查询包括包含<code>RotationQuaternion</code>和<code>RotationSpeed</code>component的archetypes，但不包括包含<code>Frozen</code>component的任何archetype：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> queryDescription = <span class="keyword">new</span> EntityQueryDesc()</span><br><span class="line">    {</span><br><span class="line">        None = <span class="keyword">new</span> ComponentType[]</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">typeof</span>(Static)</span><br><span class="line">        },</span><br><span class="line">        All = <span class="keyword">new</span> ComponentType[]</span><br><span class="line">        {</span><br><span class="line">            ComponentType.ReadWrite&lt;Rotation&gt;(),</span><br><span class="line">            ComponentType.ReadOnly&lt;RotationSpeed&gt;()</span><br><span class="line">        }</span><br><span class="line">    };</span><br><span class="line">    m_Query = GetEntityQuery(queryDescription);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>查询使用<code>ComponentType.ReadOnly&lt;T&gt;</code>而不是更简单的<code>typeof</code>表达式是为了指定system只读<code>RotationSpeed</code>。</p>
<p>您还可以组合多个query。为此，请传递<code>EntityQueryDesc</code>对象数组而不是单个实例。ECS使用<em>逻辑或</em>运算来组合每个query。下面的示例选择包含一个<code>RotationQuaternion</code>或多个<code>RotationSpeed</code>components（或两者都有）的任何archetype：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> queryDescription0 = <span class="keyword">new</span> EntityQueryDesc</span><br><span class="line">    {</span><br><span class="line">        All = <span class="keyword">new</span> ComponentType[] {<span class="keyword">typeof</span>(Rotation)}</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> queryDescription1 = <span class="keyword">new</span> EntityQueryDesc</span><br><span class="line">    {</span><br><span class="line">        All = <span class="keyword">new</span> ComponentType[] {<span class="keyword">typeof</span>(RotationSpeed)}</span><br><span class="line">    };</span><br><span class="line"></span><br><span class="line">    m_Query = GetEntityQuery(<span class="keyword">new</span> EntityQueryDesc[] {queryDescription0, queryDescription1});</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>**注意：**请勿在<code>EntityQueryDesc</code>中完全包含可选components。要处理可选components，请使用在<code>IJobChunk.Execute()</code>中的<code>chunk.Has&lt;T&gt;()</code>方法确定当前ArchetypeChunk是否具有可选components。因为同一chunk中的所有entities具有相同的components，所以您只需要每个chunk检查一个可选component是否存在一次就可以了：而不是每个entity一次。</p>
<p>为了提高效率并避免不必要地创建会有GC的引用类型，应在system<code>OnCreate()</code>方法中为system创建<code>EntityQueries</code>，然后将结果存储在实例变量中。（在以上示例中，<code>m_Query</code>变量正是如此。）</p>
<h2 id="定义IJobChunk结构">定义IJobChunk结构</h2>
<p>IJobChunk结构为job运行时所需的数据以及job的<code>Execute()</code>方法定义字段。</p>
<p>要访问system传递给您的<code>Execute()</code>方法的chunk内的component数组，必须为job读取或写入的每种类型的componnet创建一个<code>ArchetypeChunkComponentType&lt;T&gt;</code>对象。您可以使用这些对象来获取<code>NativeArray</code>实例，这些实例提供对entities components的访问。包括<code>Execute()</code>方法读取或写入的job的EntityQuery中引用的所有components。您还可以为未包含在EntityQuery中的可选component类型提供<code>ArchetypeChunkComponentType</code>变量。</p>
<p>在尝试访问当前chunk之前，必须检查以确保当前chunk具有可选component。例如，HelloCube IJobChunk示例声明了一个job结构，该结构定义了两个components的<code>ArchetypeChunkComponentType&lt;T&gt;</code>变量。分别是<code>RotationQuaternion</code>和<code>RotationSpeed</code>：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="keyword">struct</span> RotationSpeedJob : IJobChunk</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> DeltaTime;</span><br><span class="line">    <span class="keyword">public</span> ComponentTypeHandle&lt;Rotation&gt; RotationTypeHandle;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> ComponentTypeHandle&lt;RotationSpeed&gt; RotationSpeedTypeHandle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ArchetypeChunk chunk, <span class="built_in">int</span> chunkIndex, <span class="built_in">int</span> firstEntityIndex</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>system在<code>OnUpdate()</code>为函数中的这些变量分配值。ECS 在运行job时会使用<code>Execute()</code>方法内部的变量。</p>
<p>该job还使用Unity delta时间为3D对象的旋转设置动画。该示例使用struct字段将此值传递给<code>Execute()</code>方法。</p>
<h2 id="编写Execute方法">编写Execute方法</h2>
<p>IJobChunk <code>Execute()</code>方法的签名为：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ArchetypeChunk chunk, <span class="built_in">int</span> chunkIndex, <span class="built_in">int</span> firstEntityIndex</span>)</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>chunk</code>参数是内存块的句柄，该内存块包含此job的迭代必须处理的entities和components。因为chunk只能包含一个archetype，所以chunk中的所有entities都具有相同的component集。</p>
<p>使用<code>chunk</code>参数获取component的NativeArray实例：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chunkRotations = chunk.GetNativeArray(RotationTypeHandle);</span><br><span class="line"><span class="keyword">var</span> chunkRotationSpeeds = chunk.GetNativeArray(RotationSpeedTypeHandle);</span><br></pre></td></tr></tbody></table></figure>
<p>这些数组是对齐的，以便entities在所有数组中具有相同的索引。然后，您可以使用正常的for循环来遍历components数组。使用<code>chunk.Count</code>得到存储在当前chunk的entities的数量：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> chunkRotations = chunk.GetNativeArray(RotationTypeHandle);</span><br><span class="line"><span class="keyword">var</span> chunkRotationSpeeds = chunk.GetNativeArray(RotationSpeedTypeHandle);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; chunk.Count; i++)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> rotation = chunkRotations[i];</span><br><span class="line">    <span class="keyword">var</span> rotationSpeed = chunkRotationSpeeds[i];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rotate something about its up vector at the speed given by RotationSpeed.</span></span><br><span class="line">    <span class="comment">// 根据RotationSpeed提供的速度围绕一个物体的z轴来旋转它</span></span><br><span class="line">    chunkRotations[i] = <span class="keyword">new</span> Rotation</span><br><span class="line">    {</span><br><span class="line">        Value = math.mul(math.normalize(rotation.Value),</span><br><span class="line">            quaternion.AxisAngle(math.up(), rotationSpeed.RadiansPerSecond * DeltaTime))</span><br><span class="line">    };</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果您在EntityQueryDesc中具有<code>Any</code>过滤器，或是完全没有在query中出现的可选components，则可以在使用之前使用该函数测试当前chunk是否包含这些<code>ArchetypeChunk.Has&lt;T&gt;()</code>组件之一：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (chunk.Has&lt;OptionalComp&gt;(OptionalCompType))</span><br><span class="line">{<span class="comment">//...}</span></span><br></pre></td></tr></tbody></table></figure>
<p>**注意：**如果使用并发形式的entity command buffer，请将<code>chunkIndex</code>参数作为<code>sortKey</code>参数传递给command buffer函数。</p>
<h2 id="跳过那些内容都是未变化的entities的chunk">跳过那些内容都是未变化的entities的chunk</h2>
<p>如果仅在components值更改后才需要更新entities，则可以将该component类型添加到EntityQuery的change filter中。例如，如果您的system读取两个components，并且仅在前两个components中的一个已更改时才需要更新第三个component，则可以按以下方式使用EntityQuery：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> EntityQuery m_Query;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">{</span><br><span class="line">    m_Query = GetEntityQuery(</span><br><span class="line">        ComponentType.ReadWrite&lt;Output&gt;(),</span><br><span class="line">        ComponentType.ReadOnly&lt;InputA&gt;(),</span><br><span class="line">        ComponentType.ReadOnly&lt;InputB&gt;());</span><br><span class="line">    m_Query.SetChangedVersionFilter(</span><br><span class="line">        <span class="keyword">new</span> ComponentType[]</span><br><span class="line">        {</span><br><span class="line">            ComponentType.ReadWrite&lt;InputA&gt;(),</span><br><span class="line">            ComponentType.ReadWrite&lt;InputB&gt;()</span><br><span class="line">        });</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>EntityQuery的change filter最多支持两个componnets。如果您想进行更多检查或不使用EntityQuery，则可以手动进行检查。要进行此检查，请使用<code>ArchetypeChunk.DidChange()</code>函数将component的chunk的change version与system的<code>LastSystemVersion</code>进行比较。如果此函数返回false，则可以完全跳过当前chunk，因为自从上次system运行以来，该类型的component均未更改。</p>
<p>您必须使用一个struct字段将<code>LastSystemVersion</code>从system传递到job中，如下所示：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">BurstCompile</span>]</span><br><span class="line"><span class="keyword">struct</span> UpdateJob : IJobChunk</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> ComponentTypeHandle&lt;InputA&gt; InputATypeHandle;</span><br><span class="line">    <span class="keyword">public</span> ComponentTypeHandle&lt;InputB&gt; InputBTypeHandle;</span><br><span class="line">    [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> ComponentTypeHandle&lt;Output&gt; OutputTypeHandle;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">uint</span> LastSystemVersion;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ArchetypeChunk chunk, <span class="built_in">int</span> chunkIndex, <span class="built_in">int</span> firstEntityIndex</span>)</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">var</span> inputAChanged = chunk.DidChange(InputATypeHandle, LastSystemVersion);</span><br><span class="line">        <span class="keyword">var</span> inputBChanged = chunk.DidChange(InputBTypeHandle, LastSystemVersion);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果没有component变化，就跳过当前chunk</span></span><br><span class="line">        <span class="keyword">if</span> (!(inputAChanged || inputBChanged))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> inputAs = chunk.GetNativeArray(InputATypeHandle);</span><br><span class="line">        <span class="keyword">var</span> inputBs = chunk.GetNativeArray(InputBTypeHandle);</span><br><span class="line">        <span class="keyword">var</span> outputs = chunk.GetNativeArray(OutputTypeHandle);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; outputs.Length; i++)</span><br><span class="line">        {</span><br><span class="line">            outputs[i] = <span class="keyword">new</span> Output { Value = inputAs[i].Value + inputBs[i].Value };</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>与所有job结构字段一样，在调度job之前，必须分配其值：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> job = <span class="keyword">new</span> UpdateJob();</span><br><span class="line"></span><br><span class="line">    job.LastSystemVersion = <span class="keyword">this</span>.LastSystemVersion;</span><br><span class="line"></span><br><span class="line">    job.InputATypeHandle = GetComponentTypeHandle&lt;InputA&gt;(<span class="literal">true</span>);</span><br><span class="line">    job.InputBTypeHandle = GetComponentTypeHandle&lt;InputB&gt;(<span class="literal">true</span>);</span><br><span class="line">    job.OutputTypeHandle = GetComponentTypeHandle&lt;Output&gt;(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.Dependency = job.ScheduleParallel(m_Query, <span class="keyword">this</span>.Dependency);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>**注意：**为了提高效率，change version适用于整个chunk，而不是单个entity。如果另一个具有写入该类型component功能的job访问了chunk，则ECS会对该component的change version进行递增，并且<code>DidChange()</code>函数将返回true。即使声明对component进行写访问的job实际上并未更改component，ECS也会递增change version。</p>
<h2 id="实例化并调度job">实例化并调度job</h2>
<p>若要运行IJobChunk job，必须创建job结构的实例，设置结构字段，然后调度job。在SystemBase的<code>OnUpdate()</code>中执行此操作时，system会将每帧调度job。</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">var</span> job = <span class="keyword">new</span> RotationSpeedJob()</span><br><span class="line">    {</span><br><span class="line">        RotationTypeHandle = GetComponentTypeHandle&lt;Rotation&gt;(<span class="literal">false</span>),</span><br><span class="line">        RotationSpeedTypeHandle = GetComponentTypeHandle&lt;RotationSpeed&gt;(<span class="literal">true</span>),</span><br><span class="line">        DeltaTime = Time.DeltaTime</span><br><span class="line">    };</span><br><span class="line">    <span class="keyword">this</span>.Dependency =  job.ScheduleParallel(m_Query, <span class="keyword">this</span>.Dependency);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>调用<code>GetArchetypeChunkComponentType&lt;T&gt;()</code>函数设置component类型变量时，请确保将job读取但不写入的components的<code>isReadOnly</code>参数设置为true。正确设置这些参数可能会对ECS框架调度job的效率产生重大影响（害怕）。这些访问模式设置必须在结构定义和EntityQuery中都与它们的等效项匹配。</p>
<p>不要在system类的变量中缓存<code>GetArchetypeChunkComponentType&lt;T&gt;()</code>的返回值。您必须在每次system运行时调用该函数，并将更新后的值传递给job。</p>
<h1>通过手动迭代创建Systems</h1>
<p>您可以在NativeArray中显式请求所有chunks，并使用诸如<code>IJobParallelFor</code>的job来处理它们。如果适用于简化迭代EntityQuery中所有chunk的简化模型满足不了您的需求，则应使用此方法。以下是一个示例：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RotationSpeedSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">   [<span class="meta">BurstCompile</span>]</span><br><span class="line">   <span class="keyword">struct</span> RotationSpeedJob : IJobParallelFor</span><br><span class="line">   {</span><br><span class="line">       [<span class="meta">DeallocateOnJobCompletion</span>] <span class="keyword">public</span> NativeArray&lt;ArchetypeChunk&gt; Chunks;</span><br><span class="line">       <span class="keyword">public</span> ArchetypeChunkComponentType&lt;RotationQuaternion&gt; RotationType;</span><br><span class="line">       [<span class="meta">ReadOnly</span>] <span class="keyword">public</span> ArchetypeChunkComponentType&lt;RotationSpeed&gt; RotationSpeedType;</span><br><span class="line">       <span class="keyword">public</span> <span class="built_in">float</span> DeltaTime;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params"><span class="built_in">int</span> chunkIndex</span>)</span></span><br><span class="line">       {</span><br><span class="line">           <span class="keyword">var</span> chunk = Chunks[chunkIndex];</span><br><span class="line">           <span class="keyword">var</span> chunkRotation = chunk.GetNativeArray(RotationType);</span><br><span class="line">           <span class="keyword">var</span> chunkSpeed = chunk.GetNativeArray(RotationSpeedType);</span><br><span class="line">           <span class="keyword">var</span> instanceCount = chunk.Count;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; instanceCount; i++)</span><br><span class="line">           {</span><br><span class="line">               <span class="keyword">var</span> rotation = chunkRotation[i];</span><br><span class="line">               <span class="keyword">var</span> speed = chunkSpeed[i];</span><br><span class="line">               rotation.Value = math.mul(math.normalize(rotation.Value), quaternion.AxisAngle(math.up(), speed.RadiansPerSecond * DeltaTime));</span><br><span class="line">               chunkRotation[i] = rotation;</span><br><span class="line">           }</span><br><span class="line">       }</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   EntityQuery m_Query;   </span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">   {</span><br><span class="line">       <span class="keyword">var</span> queryDesc = <span class="keyword">new</span> EntityQueryDesc</span><br><span class="line">       {</span><br><span class="line">           All = <span class="keyword">new</span> ComponentType[]{ <span class="keyword">typeof</span>(RotationQuaternion), ComponentType.ReadOnly&lt;RotationSpeed&gt;() }</span><br><span class="line">       };</span><br><span class="line"></span><br><span class="line">       m_Query = GetEntityQuery(queryDesc);</span><br><span class="line">   }</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">   {</span><br><span class="line">       <span class="keyword">var</span> rotationType = GetArchetypeChunkComponentType&lt;RotationQuaternion&gt;();</span><br><span class="line">       <span class="keyword">var</span> rotationSpeedType = GetArchetypeChunkComponentType&lt;RotationSpeed&gt;(<span class="literal">true</span>);</span><br><span class="line">       <span class="keyword">var</span> chunks = m_Query.CreateArchetypeChunkArray(Allocator.TempJob);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">var</span> rotationsSpeedJob = <span class="keyword">new</span> RotationSpeedJob</span><br><span class="line">       {</span><br><span class="line">           Chunks = chunks,</span><br><span class="line">           RotationType = rotationType,</span><br><span class="line">           RotationSpeedType = rotationSpeedType,</span><br><span class="line">           DeltaTime = Time.deltaTime</span><br><span class="line">       };</span><br><span class="line">       <span class="keyword">this</span>.Dependency rotationsSpeedJob.Schedule(chunks.Length,<span class="number">32</span>, <span class="keyword">this</span>.Dependency);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="手动迭代">手动迭代</h2>
<p>您可以使用EntityManager类手动遍历entities或chunk，尽管这不是最佳实践。您只应在测试或调试代码中（或仅在进行实验时）或在您拥有完全可控的实体集的独立world中使用这些迭代方法。</p>
<p>例如，以下代码段循环访问活动世界中的所有entities：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entityManager = World.Active.EntityManager;</span><br><span class="line"><span class="keyword">var</span> allEntities = entityManager.GetAllEntities();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> entity <span class="keyword">in</span> allEntities)</span><br><span class="line">{</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">}</span><br><span class="line">allEntities.Dispose();</span><br></pre></td></tr></tbody></table></figure>
<p>此代码段循环遍历活动世界中的所有chunks：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> entityManager = World.Active.EntityManager;</span><br><span class="line"><span class="keyword">var</span> allChunks = entityManager.GetAllChunks();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="keyword">var</span> chunk <span class="keyword">in</span> allChunks)</span><br><span class="line">{</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">}</span><br><span class="line">allChunks.Dispose();</span><br></pre></td></tr></tbody></table></figure>
<h1>Systems更新顺序</h1>
<p>使用Component System Groups来指定system的更新顺序。您可以使用system类声明中的[UpdateInGroup]attribute将system放在group中。然后，您可以使用[UpdateBefore]和[UpdateAfter]attribute来指定其在group中的更新顺序。</p>
<p>ECS框架会创建一组<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/system_update_order.html#default-system-groups">default system groups</a>，可用于在框架的恰当阶段更新systems。您可以将一个group嵌套在另一个group中，以便group中的所有systems在恰当的阶段进行更新，并根据其在group中的顺序进行更新。</p>
<h2 id="Component-System-Groups">Component System Groups</h2>
<p>ComponentSystemGroup类表示应按特定顺序一起更新的相关Component Systems的列表。ComponentSystemGroup是从ComponentSystemBase派生的，因此在所有重要的方面它都像Component System一样工作-可以相对于其他systems进行排序，具有OnUpdate（）方法等。最重要的是，这意味着可以将Component System Group嵌套在其他Component System Group中，形成一个层次结构。</p>
<p>默认情况下，当调用ComponentSystemGroup的<code>Update()</code>方法时，它将在其成员system的排序列表中的每个system上调用Update（）。如果任何成员system本身就是system group，则它们将递归更新自己的成员。这种情况下生成的system顺序遵循树的深度优先遍历规则。</p>
<h2 id="System-Ordering-Attributes">System Ordering Attributes</h2>
<p>现有的system ordering attribute会被保留，但语义和限制稍有不同。</p>
<ul>
<li>[UpdateInGroup]-指定此system应该是其成员的ComponentSystemGroup。如果省略此attribute，system将被自动添加到默认的World’s SimulationSystemGroup（请参见下文）。</li>
<li>[UpdateBefore]和[UpdateAfter]-是相对于其他systems的system ordering。为这些attribute指定的system类型必须是同一组的成员。跨组的排序是在包含两个系统的适当的最深组中进行的：
<ul>
<li>**例如：**如果SystemA在GroupA中，而SystemB在GroupB中，并且GroupA和GroupB都是GroupC的成员，则GroupA和GroupB的顺序将隐式确定SystemA和SystemB的相对顺序；无需对system进行明确排序。</li>
</ul>
</li>
<li>[DisableAutoCreation]-防止在默认World初始化期间创建system。您必须显式创建和更新system。但是，您可以将带有此attribute的system添加到ComponentSystemGroup的更新列表中，然后它将像该列表中的其他systems一样自动进行更新。</li>
</ul>
<h2 id="Default-System-Groups">Default System Groups</h2>
<p>默认的World包含ComponentSystemGroup实例的层次结构。只有三个根级别的system groups被添加到Unity Player循环（以下列表还显示了每个group中的预定义成员systems）：</p>
<ul>
<li>InitializationSystemGroup（在Initialization播放器循环阶段的末尾更新）
<ul>
<li>BeginInitializationEntityCommandBufferSystem</li>
<li>CopyInitialTransformFromGameObjectSystem</li>
<li>SubSceneLiveLinkSystem</li>
<li>SubSceneStreamingSystem</li>
<li>EndInitializationEntityCommandBufferSystem</li>
</ul>
</li>
<li>SimulationSystemGroup（在Update播放器循环阶段的末尾更新）
<ul>
<li>BeginSimulationEntityCommandBufferSystem</li>
<li>TransformSystemGroup
<ul>
<li>EndFrameParentSystem</li>
<li>CopyTransformFromGameObjectSystem</li>
<li>EndFrameTRSToLocalToWorldSystem</li>
<li>EndFrameTRSToLocalToParentSystem</li>
<li>EndFrameLocalToParentSystem</li>
<li>CopyTransformToGameObjectSystem</li>
</ul>
</li>
<li>LateSimulationSystemGroup</li>
<li>EndSimulationEntityCommandBufferSystem</li>
</ul>
</li>
<li>PresentationSystemGroup（在PreLateUpdate播放器循环阶段的末尾更新）
<ul>
<li>BeginPresentationEntityCommandBufferSystem</li>
<li>CreateMissingRenderBoundsFromMeshRenderer</li>
<li>RenderingSystemBootstrap</li>
<li>RenderBoundsUpdateSystem</li>
<li>RenderMeshSystem</li>
<li>LODGroupSystemV1</li>
<li>LodRequirementsUpdateSystem</li>
<li>EndPresentationEntityCommandBufferSystem</li>
</ul>
</li>
</ul>
<p>请注意，此列表的具体内容可能会更改（经典迭代）。</p>
<h2 id="多个Worlds">多个Worlds</h2>
<p>除了（或代替上述）默认World，您可以创建多个World。同一component system类可以在多个world中实例化，并且每个实例可以在更新顺序的不同点以不同的速率进行更新。</p>
<p>当前还无法指定World中的每个system机进行手动更新。但是，您可以控制在哪个World中创建哪些systems，以及应将其添加到哪些现有system groups中。比如，自定义WorldB可以实例化SystemX和SystemY，将SystemX添加到默认的World’s SimulationSystemGroup，并将SystemY添加到默认的World’s PresentationSystemGroup。这些systems可以像往常一样相对于其group同级对其进行排序，并将与相应的groups一起进行更新。</p>
<p>为了支持此种情况，现在提供了新的ICustomBootstrap接口：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICustomBootstrap</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">// Returns the systems which should be handled by the default bootstrap process.</span></span><br><span class="line">    <span class="comment">// If null is returned the default world will not be created at all.</span></span><br><span class="line">    <span class="comment">// Empty list creates default world and entrypoints</span></span><br><span class="line">    <span class="comment">// 返回那些需要被默认启动程序处理的systems</span></span><br><span class="line">    <span class="comment">// 如果为null，默认的world都不会被创建</span></span><br><span class="line">    <span class="comment">// 返回0个元素的list创建默认的world和入口点</span></span><br><span class="line">    <span class="function">List&lt;Type&gt; <span class="title">Initialize</span>(<span class="params">List&lt;Type&gt; systems</span>)</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>当实现此接口时，component system类型的完整列表将在默认世界初始化之前传递给classes <code>Initialize()</code>方法。自定义的引导程序可以遍历此列表，并在所需的任何World中创建systems。您可以从Initialize（）方法返回systems列表，它们将作为常规的默认world初始化的一部分创建。</p>
<p>例如，以下是自定义<code>MyCustomBootstrap.Initialize()</code>实现的典型过程：</p>
<ol>
<li>创建任何其他Worlds及其顶层ComponentSystemGroups。</li>
<li>对于system类型列表中的每个类型：
<ol>
<li>向上遍历ComponentSystemGroup层次结构以找到此system Type的顶级group。</li>
<li>如果它是在步骤1中创建的groups之一，请在该world中创建system，然后使用<code>group.AddSystemToUpdateList()</code>将其添加到层次结构中。</li>
<li>如果不是，请将此类型附加到列表以返回到DefaultWorldInitialization。</li>
</ol>
</li>
<li>在新的顶级组上调用group.SortSystemUpdateList（）。
<ol>
<li>（可选）将它们添加到默认世界组之一</li>
</ol>
</li>
<li>将未处理systems的列表返回给DefaultWorldInitialization。</li>
</ol>
<p><strong>注意：</strong> ECS框架通过反射查找您的ICustomBootstrap实现。</p>
<h2 id="提示和最佳实践">提示和最佳实践</h2>
<ul>
<li>**使用[UpdateInGroup]为您编写的每个system指定system group。**如果未指定，则隐式默认组为SimulationSystemGroup。</li>
<li>**使用手动选定的ComponentSystemGroups来更新Unity播放器循环中其他位置的system。**将[DisableAutoCreation]属性添加到component system（或system group）可防止将其创建或添加到默认system group。您仍然可以使用World.GetOrCreateSystem手动创建system并通过从主线程手动调用MySystem.Update（）进行更新。这是在Unity Player循环中的其他位置插入system的简便方法（例如，如果您的system应在框架中的更早或更晚的时候运行）。</li>
<li>**如果可能的话，请使用现有的EntityCommandBufferSystem而不是添加新的。**An <code>EntityCommandBufferSystem</code>代表一个sync point，在该sync point，主线程在处理任何未完成的<code>EntityCommandBuffer</code>s 之前等待工作线程完成。与创建新的“气泡”（这个东西暂时没想好怎么翻译，应该和冒泡的事件传递机制一个意思）相比，在每个顶级system group中重用预定义的Begin / End system之一不太可能在帧管线中引入新的“气泡”。</li>
<li><strong>避免在<code>ComponentSystemGroup.OnUpdate()</code>中加入自定义逻辑</strong>。由于从<code>ComponentSystemGroup</code>功能上来说本身就是一个component system，因此可能很想在其OnUpdate（）方法中添加自定义处理，执行一些工作，生成一些工作等。我们通常建议不要这样做，因为从外部尚不清楚自定义逻辑是在更新组成员之前或之后执行。最好将system group限制为一种分组机制，并在相对于该组显式排序的单独的component system中实现所需的逻辑。</li>
</ul>
<h1>Job dependencies</h1>
<p>Unity根据system读取和写入的ECS component分析每个system的数据依赖性。如果在框架中较早更新的system读取了较新system写入的数据，或写入了较新system读取的数据，则第二个system将依赖于第一个system。为避免出现<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Race_condition">竞争状况</a>，job调度程序确保在运行system job之前，system所依赖的所有jobs均已完成。</p>
<p>system的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Dependency">Dependency</a>属性是<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html">JobHandle</a>，代表与system的ECS相关的依赖关系。在<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_OnUpdate_">OnUpdate（）</a>之前，<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Dependency">Dependency</a>属性反映了system对先前job的传入依赖关系。默认情况下，system根据您在system中调度job时读取和写入的component来更新<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Dependency">Dependency</a>属性。</p>
<p>要覆盖此默认行为，请使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>和<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Job">Job.WithCode</a>的重载版本，这些重载版本将job依赖项作为参数，并将更新后的依赖项作为<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.html">JobHandle返回</a>。使用这些构造的显式版本时，ECS不会自动将job handles与system的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Dependency">Dependency</a>属性结合在一起。您必须在需要时手动组合它们。</p>
<p>请注意，system的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Dependency">Dependency</a>属性不会跟踪job对通过<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html">NativeArrays</a>或其他类似容器传递的数据可能具有的依赖关系。如果您在一个job中编写NativeArray并在另一个job中读取该数组，则必须手动添加第一个job的JobHandle作为第二个job的依赖项（通常使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.CombineDependencies.html">JobHandle.CombineDependencies</a>）。</p>
<p>当您调用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach.Run（）时</a>，作业调度程序会在开始ForEach迭代之前完成system所依赖的所有调度job。如果您还使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">WithStructuralChanges（）</a>作为构造的一部分，则job调度程序将完成所有正在运行和待调度的jobs。结构更改还会使对component数据的任何直接引用无效。有关更多信息，请参见<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/sync_points.html">Sync Point</a>。</p>
<p>有关更多信息，请参见<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/JobSystemJobDependencies.html">JobHandle和依赖项</a>。</p>
<h1>查找数据</h1>
<p>访问和修改ECS数据的最有效方法是使用带有实体查询和作业的系统。这样可以以最少的内存高速缓存未命中来最佳利用CPU资源。实际上，数据设计的目标之一应该是使用最有效，最快的路径来执行大部分数据转换。但是，有时您需要在程序的任意位置访问任意实体的任意组件。</p>
<p>给定一个Entity对象，您可以在其<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/component_data.html">IComponentData</a>和<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/dynamic_buffers.html">动态缓冲区中</a>查找数据。该方法根据您的代码是在系统中使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>还是使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.IJobChunk.html">IJobChunk</a>作业还是在主线程上的其他位置执行而有所不同。</p>
<h2 id="在Systems中查找entities数据">在Systems中查找entities数据</h2>
<p>使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_GetComponent__1_Unity_Entities_Entity_">GetComponent （Entity）</a>从system的<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_Entities">Entities.ForEach</a>或[Job.WithCode]函数内部查找存储在任意entities components中的数据。</p>
<p>例如，如果您的“目标”component的“实体”字段定义了目标entity，则可以使用以下代码将entity向其目标旋转：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TrackingSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">float</span> deltaTime = <span class="keyword">this</span>.Time.DeltaTime;</span><br><span class="line"></span><br><span class="line">        Entities</span><br><span class="line">            .ForEach((<span class="keyword">ref</span> Rotation orientation,</span><br><span class="line">            <span class="keyword">in</span> LocalToWorld transform,</span><br><span class="line">            <span class="keyword">in</span> Target target) =&gt;</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// Check to make sure the target Entity still exists and has</span></span><br><span class="line">                <span class="comment">// the needed component</span></span><br><span class="line">                <span class="comment">// 确保目标entity仍然存在，并且拥有我们需要的component</span></span><br><span class="line">                <span class="keyword">if</span> (!HasComponent&lt;LocalToWorld&gt;(target.entity))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Look up the entity data</span></span><br><span class="line">               	<span class="comment">// 查找entity数据</span></span><br><span class="line">                LocalToWorld targetTransform</span><br><span class="line">                    = GetComponent&lt;LocalToWorld&gt;(target.entity);</span><br><span class="line">                float3 targetPosition = targetTransform.Position;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Calculate the rotation</span></span><br><span class="line">                <span class="comment">// 计算旋转四元数</span></span><br><span class="line">                float3 displacement = targetPosition - transform.Position;</span><br><span class="line">                float3 upReference = <span class="keyword">new</span> float3(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">                quaternion lookRotation =</span><br><span class="line">                    quaternion.LookRotationSafe(displacement, upReference);</span><br><span class="line"></span><br><span class="line">                orientation.Value =</span><br><span class="line">                    math.slerp(orientation.Value, lookRotation, deltaTime);</span><br><span class="line">            })</span><br><span class="line">            .ScheduleParallel();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>访问存储在<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/dynamic_buffers.html">dynamic buffers</a>中的数据需要额外的步骤。您必须在<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.SystemBase.html#Unity_Entities_SystemBase_OnUpdate_">OnUpdate（）</a>方法中声明<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.BufferFromEntity-1.html">BufferFromEntity</a>类型的局部变量。然后，您可以在lambda函数中“捕获”局部变量。</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">struct</span> BufferData : IBufferElementData</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> Value;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BufferLookupSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        BufferFromEntity&lt;BufferData&gt; buffersOfAllEntities</span><br><span class="line">            = <span class="keyword">this</span>.GetBufferFromEntity&lt;BufferData&gt;(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        Entities</span><br><span class="line">            .ForEach((<span class="keyword">ref</span> Rotation orientation,</span><br><span class="line">            <span class="keyword">in</span> LocalToWorld transform,</span><br><span class="line">            <span class="keyword">in</span> Target target) =&gt;</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// Check to make sure the target Entity with this buffer type still exists</span></span><br><span class="line">                <span class="comment">// 确保缓冲区中的目标entity仍然存在</span></span><br><span class="line">                <span class="keyword">if</span> (!buffersOfAllEntities.HasComponent(target.entity))</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Get a reference to the buffer</span></span><br><span class="line">                <span class="comment">// 获取缓冲区引用</span></span><br><span class="line">                DynamicBuffer&lt;BufferData&gt; bufferOfOneEntity =</span><br><span class="line">                    buffersOfAllEntities[target.entity];</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Use the data in the buffer</span></span><br><span class="line">                <span class="comment">// 使用缓冲区的数据</span></span><br><span class="line">                <span class="built_in">float</span> avg = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; bufferOfOneEntity.Length; i++)</span><br><span class="line">                {</span><br><span class="line">                    avg += bufferOfOneEntity[i].Value;</span><br><span class="line">                }</span><br><span class="line">                <span class="keyword">if</span> (bufferOfOneEntity.Length &gt; <span class="number">0</span>)</span><br><span class="line">                    avg /= bufferOfOneEntity.Length;</span><br><span class="line">            })</span><br><span class="line">            .ScheduleParallel();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="在IJobChunk中查找entity数据">在IJobChunk中查找entity数据</h2>
<p>要随机访问IJobChunk或其他job结构中的component数据，请使用以下类型之一来获取component的类似于数组的接口，并由<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.Entity.html">Entity</a>对象索引：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentDataFromEntity-1.html">ComponentDataFromEntity</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.BufferFromEntity-1.html">BufferFromEntity</a></li>
</ul>
<p>声明类型为<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.ComponentDataFromEntity-1.html">ComponentDataFromEntity</a>或<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.BufferFromEntity-1.html">BufferFromEntity</a>的字段，并在调度job之前设置该字段的值。</p>
<p>例如，如果您的“目标”component的“实体”字段定义了目标entity，则可以将以下字段添加到job结构中以查找目标的世界位置：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">ReadOnly</span>]</span><br><span class="line"><span class="keyword">public</span> ComponentDataFromEntity&lt;LocalToWorld&gt; EntityPositions;</span><br></pre></td></tr></tbody></table></figure>
<p>请注意，此声明使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Collections.ReadOnlyAttribute.html">ReadOnly</a>属性。您应该始终声明ComponentDataFromEntity 除非您确实写入要访问的component，否则对象为只读。</p>
<p>您可以在调度job时按以下方式设置此字段：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> job = <span class="keyword">new</span> ChaserSystemJob();</span><br><span class="line">job.EntityPositions = <span class="keyword">this</span>.GetComponentDataFromEntity&lt;LocalToWorld&gt;(<span class="literal">true</span>);</span><br></pre></td></tr></tbody></table></figure>
<p>在job的<code>Execute()</code>函数内，您可以使用Entity对象查找component的值：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">float3 targetPosition = EntityPositions[targetEntity].Position;</span><br></pre></td></tr></tbody></table></figure>
<p>以下完整示例显示了一个system，该system将具有包含其目标的Entity对象的Target字段的entity移向目标的当前位置：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">MoveTowardsEntitySystem</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">private</span> EntityQuery query;</span><br><span class="line"></span><br><span class="line">    [<span class="meta">BurstCompile</span>]</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">struct</span> MoveTowardsJob : IJobChunk</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Read-write data in the current chunk</span></span><br><span class="line">        <span class="comment">// 当前chunk的可读写数据</span></span><br><span class="line">        <span class="keyword">public</span> ComponentTypeHandle&lt;Translation&gt; PositionTypeHandleAccessor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read-only data in the current chunk</span></span><br><span class="line">        <span class="comment">// 当前chunk的只读数据</span></span><br><span class="line">        [<span class="meta">ReadOnly</span>]</span><br><span class="line">        <span class="keyword">public</span> ComponentTypeHandle&lt;Target&gt; TargetTypeHandleAccessor;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read-only data stored (potentially) in other chunks</span></span><br><span class="line">        <span class="comment">// 被其他chunk存储的只读数据（潜在的）</span></span><br><span class="line">        [<span class="meta">ReadOnly</span>]</span><br><span class="line">        <span class="keyword">public</span> ComponentDataFromEntity&lt;LocalToWorld&gt; EntityPositions;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Non-entity data</span></span><br><span class="line">        <span class="comment">// 非entity数据</span></span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">float</span> deltaTime;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Execute</span>(<span class="params">ArchetypeChunk chunk,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="built_in">int</span> chunkIndex,</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="built_in">int</span> firstEntityIndex</span>)</span></span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Get arrays of the components in chunk</span></span><br><span class="line">            <span class="comment">// 获取chunk中的组件数组</span></span><br><span class="line">            NativeArray&lt;Translation&gt; positions</span><br><span class="line">                = chunk.GetNativeArray&lt;Translation&gt;(PositionTypeHandleAccessor);</span><br><span class="line">            NativeArray&lt;Target&gt; targets</span><br><span class="line">                = chunk.GetNativeArray&lt;Target&gt;(TargetTypeHandleAccessor);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; positions.Length; i++)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// Get the target Entity object</span></span><br><span class="line">                <span class="comment">// 获取目标实体对象</span></span><br><span class="line">                Entity targetEntity = targets[i].entity;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check that the target still exists</span></span><br><span class="line">                <span class="comment">// 检查entity是否存在</span></span><br><span class="line">                <span class="keyword">if</span> (!EntityPositions.HasComponent(targetEntity))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Update translation to move the chasing enitity toward the target</span></span><br><span class="line">                <span class="comment">// 更新transform以将实体移向目标</span></span><br><span class="line">                float3 targetPosition = EntityPositions[targetEntity].Position;</span><br><span class="line">                float3 chaserPosition = positions[i].Value;</span><br><span class="line"></span><br><span class="line">                float3 displacement = targetPosition - chaserPosition;</span><br><span class="line">                positions[i] = <span class="keyword">new</span> Translation</span><br><span class="line">                {</span><br><span class="line">                    Value = chaserPosition + displacement * deltaTime</span><br><span class="line">                };</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Select all entities that have Translation and Target Componentx</span></span><br><span class="line">        <span class="comment">// 一个获取所有拥有transform和componentx entities的query</span></span><br><span class="line">        query = <span class="keyword">this</span>.GetEntityQuery</span><br><span class="line">            (</span><br><span class="line">                <span class="keyword">typeof</span>(Translation),</span><br><span class="line">                ComponentType.ReadOnly&lt;Target&gt;()</span><br><span class="line">            );</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Create the job</span></span><br><span class="line">        <span class="comment">// 创建job</span></span><br><span class="line">        <span class="keyword">var</span> job = <span class="keyword">new</span> MoveTowardsJob();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the chunk data accessors</span></span><br><span class="line">        <span class="comment">// 设置chunk数据获取者</span></span><br><span class="line">        job.PositionTypeHandleAccessor =</span><br><span class="line">            <span class="keyword">this</span>.GetComponentTypeHandle&lt;Translation&gt;(<span class="literal">false</span>);</span><br><span class="line">        job.TargetTypeHandleAccessor =</span><br><span class="line">            <span class="keyword">this</span>.GetComponentTypeHandle&lt;Target&gt;(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set the component data lookup field</span></span><br><span class="line">        <span class="comment">// 设置component data的lookup字段</span></span><br><span class="line">        job.EntityPositions = <span class="keyword">this</span>.GetComponentDataFromEntity&lt;LocalToWorld&gt;(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set non-ECS data fields</span></span><br><span class="line">        <span class="comment">// 设置非ECS数据</span></span><br><span class="line">        job.deltaTime = <span class="keyword">this</span>.Time.DeltaTime;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Schedule the job using Dependency property</span></span><br><span class="line">        <span class="comment">// 使用Dependency property调度job</span></span><br><span class="line">        <span class="keyword">this</span>.Dependency = job.Schedule(query, <span class="keyword">this</span>.Dependency);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="获取数据失败">获取数据失败</h2>
<p>如果您正在查找的数据与您直接在job中读取和写入的数据冲突，则随机访问会导致竞争状况和BUG。如果确定直接在job中读取或写入的特定entity数据与您随机读取或写入的特定entity数据之间没有重叠，则可以使用<a target="_blank" rel="noopener" href="https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeDisableParallelForRestrictionAttribute.html">NativeDisableParallelForRestriction</a> attribute标记访问器对象。</p>
<h1>Entity Command Buffers</h1>
<p><a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityCommandBuffer.html"><code>EntityCommandBuffer</code></a>（ECB）解决两个重要问题：</p>
<ol>
<li>在job中，您无法访问<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/api/Unity.Entities.EntityManager.html"><code>EntityManager</code></a>。</li>
<li>当执行<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/sync_points.html">structural change</a>（如创建entity）时，您将创建一个<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/sync_points.html">Sync Point</a>并且必须等待所有jobs完成。</li>
</ol>
<p><code>EntityCommandBuffer</code>允许你将变动队列化（无论是从job或从主线程），使他们能够在主线程上后生效。</p>
<h2 id="Entity-command-buffer-systems">Entity command buffer systems</h2>
<p>使您可以在一帧中明确定义的位置播放在ECB中排队的命令。这些system通常是使用ECB的最佳方法。您可以从同一entity Entity command buffer systems中获取多个ECB，并且system将按照更新时创建它们的顺序来播放所有ECB。这将在system更新时创建一个Sync Point，而不是每个ECB一个Sync Point，并确保确定性。</p>
<p>默认的World初始化提供了三个system group，分别用于初始化，模拟和执行，并按每帧的顺序进行更新。在一个组中，有一个Entity command buffer system在该组中的任何其他system之前运行，而另一个在该组中的所有其他system之后运行。最好，您应该使用现有的Entity command buffer systemss之一，而不是创建自己的Entity command buffer systems，以最大程度地减少Sync point。有关<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/system_update_order.html">default groups</a>和Entity command buffer systems的内容，请参见<a target="_blank" rel="noopener" href="https://docs.unity3d.com/Packages/com.unity.entities@0.13/manual/system_update_order.html">default system group</a>。</p>
<p>如果要使用并行job中的ECB（例如，<code>Entities.ForEach</code>中的），则必须确保首先通过调用<code>ToConcurrent</code>将其转换为并发ECB 。为确保ECB中命令的顺序不取决于job在job之间的分配方式，还必须将当前query中entities的索引传递给每个操作。</p>
<p>您可以像这样获取和使用ECB：</p>
<figure class="highlight cs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Lifetime : IComponentData</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">byte</span> Value;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">LifetimeSystem</span> : <span class="title">SystemBase</span></span><br><span class="line">{</span><br><span class="line">    EndSimulationEntityCommandBufferSystem m_EndSimulationEcbSystem;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnCreate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">base</span>.OnCreate();</span><br><span class="line">        <span class="comment">// Find the ECB system once and store it for later usage</span></span><br><span class="line">        <span class="comment">// 获取ECB system一次，并保存以供后续使用</span></span><br><span class="line">        m_EndSimulationEcbSystem = World</span><br><span class="line">            .GetOrCreateSystem&lt;EndSimulationEntityCommandBufferSystem&gt;();</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">OnUpdate</span>()</span></span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Acquire an ECB and convert it to a concurrent one to be able</span></span><br><span class="line">        <span class="comment">// to use it from a parallel job.</span></span><br><span class="line">        <span class="comment">// 获取一个ECB，并将其转换成一个并行的来在并行job中使用它</span></span><br><span class="line">        <span class="keyword">var</span> ecb = m_EndSimulationEcbSystem.CreateCommandBuffer().AsParallelWriter();</span><br><span class="line">        Entities</span><br><span class="line">            .ForEach((Entity entity, <span class="built_in">int</span> entityInQueryIndex, <span class="keyword">ref</span> Lifetime lifetime) =&gt;</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Track the lifetime of an entity and destroy it once</span></span><br><span class="line">            <span class="comment">// the lifetime reaches zero</span></span><br><span class="line">            <span class="comment">// 追踪一个entity的生命时长，并在目标时间销毁他</span></span><br><span class="line">            <span class="keyword">if</span> (lifetime.Value == <span class="number">0</span>)</span><br><span class="line">            {</span><br><span class="line">                <span class="comment">// pass the entityInQueryIndex to the operation so</span></span><br><span class="line">                <span class="comment">// the ECB can play back the commands in the right</span></span><br><span class="line">                <span class="comment">// order</span></span><br><span class="line">                <span class="comment">// 将entityInQueryIndex传递给操作，这样ECB可以晚些时候进行调用</span></span><br><span class="line">                ecb.DestroyEntity(entityInQueryIndex, entity);</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                lifetime.Value -= <span class="number">1</span>;</span><br><span class="line">            }</span><br><span class="line">        }).ScheduleParallel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure that the ECB system knows about our job</span></span><br><span class="line">        <span class="comment">// 确保ECB system知道我们这个job</span></span><br><span class="line">        m_EndSimulationEcbSystem.AddJobHandleForProducer(<span class="keyword">this</span>.Dependency);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="www.lfzxb.top">烟雨迷离半世殇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.lfzxb.top/unity-dots-systems/">https://www.lfzxb.top/unity-dots-systems/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.lfzxb.top" target="_blank">登峰造极者，殊途亦同归。</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Unity%E6%8A%80%E6%9C%AF/">Unity技术</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/ECS/">ECS</a><a class="post-meta__tags" href="/tags/Unity-DOTS/">Unity DOTS</a></div><div class="post-share"><div class="social-share" data-image="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175314.png!webp" target="_blank"><img class="post-qr-code-img" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175314.png!webp" alt="微信" loading='lazy'></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175304.png!webp" target="_blank"><img class="post-qr-code-img" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175304.png!webp" alt="支付宝" loading='lazy'></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><div class="ads-wrap"><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7235595771604497" data-ad-slot="9104433828"></ins><script> (adsbygoogle = window.adsbygoogle || []).push({});</script></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/unity-dots-table-of-contents/" title="Unity DOTS：目录"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post" loading='lazy'><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Unity DOTS：目录</div></div><div class="info-2"><div class="info-item-1">前言 本篇博客汇总个人Unity DOTS相关文章，方便好兄弟们查看 目录 Unity DOTS：入门简介：https://www.lfzxb.top/unity-dots-ecs-burst-complier-jobsystem/ Unity DOTS：ECS的核心部分：https://www.lfzxb.top/unity-dots-core-of-ecs/ Unity DOTS：拓展内容：https://www.lfzxb.top/unity-dots-extension/ Unity DOTS：Entities部分：https://www.lfzxb.top/unity-dots-part-of-entities/ Unity DOTS：Components部分：https://www.lfzxb.top/unity-dots-part-of-components/ Unity DOTS：Systems部分：https://www.lfzxb.top/unity-dots-systems/ Unity DOTS：使用ECS进行GamePlay开发：https://www....</div></div></div></a><a class="pagination-related" href="/unity-dots-part-of-entities/" title="Unity DOTS：Entities部分"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post" loading='lazy'><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Unity DOTS：Entities部分</div></div><div class="info-2"><div class="info-item-1">Entities Entities是实体组件系统体系结构的三个主要元素之一。它们代表游戏或应用程序中的各个“事物”。Entities既没有行为也没有数据；取而代之的是，它担任索引各种数据的职责。Systems提供行为，而Components存储数据。 entity本质上是一个ID。最简单方法是把它作为一个超轻量级GameObject甚至没有名称。实体ID稳定；您可以使用它们来存储对另一个component或entities的引用。例如，Hierarchy中的子entity可能需要引用其父entity。 一个EntityManager管理在一个World中所有的entities。EntityManager维护entities列表并组织与entities相关联的数据以实现最佳性能。 尽管实体没有类型，但是可以按与entities相关联的components的类型对其进行分组。创建entities并向其添加components时，EntityManager会持续跟踪监控entities上components的唯一组合。这种独特的组合称为Archetype（原型）。将components...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/dots-anything-about-isharedcomponent/" title="关于ISharedComponent的一切"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2020-02-01</div><div class="info-item-2">关于ISharedComponent的一切</div></div><div class="info-2"><div class="info-item-1">前言 ECS中的ISharedComponent是一个非常重要的概念，但是理解起来却不是这么容易，前阵子找到一篇讲ISharedComponent的文章，感觉例子举的很好，讲的也很透彻，故翻译出来分享给大家。 本文翻译自：https://gametorrahod.com/everything-about-isharedcomponentdata/ 正文 这是ECS最容易被误解的功能之一。当您不知道它是如何设计的时候，通常会出现诸如“如何在工作中获取SCD数据？我不能？那有什么卵用！”这样的问题。因此，让我们开始了解它是如何工作的。 数据共享并不那么ECS 众所周知，ECS会紧密排布entity数据成为chunk。同样，高性能C＃（HPC＃）的限制是得确保您没有通往外界的任何“门户”。static无法使用。禁用别名。分析器无法通过公有字段引入job的引用类型。它也不会让您将指针潜入IComponentData其中。另外，存储器必须是线性的。 “共享”的概念听起来根本不像ECS。在ECS中，可以从chunk中获取任何用来工作的数据。您不会在任何地方跳转，这就是“默认情况下的性能”的来...</div></div></div></a><a class="pagination-related" href="/unity-dots-core-of-ecs/" title="Unity DOTS：ECS的核心部分"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-02-04</div><div class="info-item-2">Unity DOTS：ECS的核心部分</div></div><div class="info-2"><div class="info-item-1">ECS的概念 实体组件系统（ECS）架构将身份（Entities，实体），数据（Components，组件）和行为（Systems，系统）分开。该架构专注于数据。Systems读取Components数据流，然后将数据从输入状态转换为输出状态，然后对这些实体进行索引。 下图说明了这三个基本部分如何协同工作：  在此图中，系统读取Translation和Rotation部分，将它们相乘，然后更新相应的LocalToWorld成分（L2W = T*R）。 实体A和B具有Renderer组件，而实体C则没有，但是这不会影响系统，因为系统并不关心Renderer组件。 您可以设置一个系统，使其需要一个Renderer组件，在这种情况下，系统将忽略实体C的组件。或者，您也可以设置系统以排除具有Renderer组件的实体，然后忽略实体A和B的组件。 Archetypes(原型) 组件类型的组合称为“原型”。例如，一个3D对象可能具有一个用于其世界变换的组件，一个用于其线性运动的组件，一个用于旋转的组件和一个用于渲染的组件。这些3D对象的每个实例都对应一个实体，但是由于它们共享相同的组件集，因...</div></div></div></a><a class="pagination-related" href="/unity-dots-ecs-burst-complier-jobsystem/" title="Unity DOTS：入门简介（ECS，Burst Complier，JobSystem）"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-04-13</div><div class="info-item-2">Unity DOTS：入门简介（ECS，Burst Complier，JobSystem）</div></div><div class="info-2"><div class="info-item-1">本文章已于2021.4.13更新，修正了当时因为水平不足而导致的一些错误，拓展了部分内容。  前言 近期想从更深层次上学习ECS，之前一直停留在浅层次的编码模式（即ECS意识流），没有真正的去了解ECS的内部原理，Unity目前在维护一套以ECS为架构开发的DOTS技术栈，非常值得学习。 ECS 什么是ECS ECS即实体（Entity），组件（Component），系统（System），其中Entity，Component皆为纯数据向的类，System负责操控他们，这种模式会一定程度上优化我们的代码速度。  Entities：游戏中的事物，但在ECS中他只作为一个Id Components：与Entity相关的数据，但是这些数据应该由Component本身而不是Entity来组织。（这种组织上的差异正是面向对象和面向数据的设计之间的关键差异之一）。 Systems：Systems是把Components的数据从当前状态转换为下一个状态的逻辑，但System本身应当是无状态的。例如，一个system可能会通过他们的速度乘以从前一帧到这一帧的时间间隔来更新所有的移动中的entiti...</div></div></div></a><a class="pagination-related" href="/unity-dots-extension/" title="Unity DOTS：ECS拓展内容"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-02-04</div><div class="info-item-2">Unity DOTS：ECS拓展内容</div></div><div class="info-2"><div class="info-item-1">Sync points synchronization poin（sync point）是程序执行中的一个点，它等待到目前为止已调度的所有job的完成。同步点会限制您一段时间内使用Job System中所有可用工作线程的能力。因此，通常应避免同步点。 Structural changes(结构变化) 同步点是由 您在任何其他job正在操作components时不能安全执行自己的操作所引起的。ECS中数据的结构更改是引发Sync points的主要原因。以下所有都是结构上的变化：  创建entities 删除entities 向entity添加component 从entity中删除component 更改sharedcomponent的value  广义上讲，任何更改entity archetype或导致chunk中entities顺序更改的操作都是结构性更改。这些结构更改只能在主线程上执行。 结构更改不仅需要Sync points，而且还会使对任何component数据的所有直接引用无效。这包括DynamicBuffer的实例以及提供对component（例如Component...</div></div></div></a><a class="pagination-related" href="/unity-dots-part-of-components/" title="Unity DOTS：Components部分"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-02-04</div><div class="info-item-2">Unity DOTS：Components部分</div></div><div class="info-2"><div class="info-item-1">组件 Components是ECS体系结构的三个主要元素之一。它们代表您的游戏或应用程序的数据。Entities是索引您的components集合的标识符，而systems提供了行为。 ECS中的Components是具有以下“标记接口”之一的结构体类型：  IComponentData —用于通用和[chunk components]。 IBufferElementData —将[动态缓冲区（dynamic buffers）]与entities相关联。 ISharedComponentData —按archetype中的值对entities进行分类或分组。有关更多信息，请参见[Shared Component Data]。 ISystemStateComponentData —将特定system的状态与entity相关联，并检测何时创建或销毁单个实体。有关更多信息，请参见System State Component。 ISharedSystemStateComponentData —共享状态和System状态 数据的组合。请参阅System State Component。 B...</div></div></div></a><a class="pagination-related" href="/unity-dots-part-of-entities/" title="Unity DOTS：Entities部分"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2020/05/nordeus_jobsystem_2.jpg!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-02-04</div><div class="info-item-2">Unity DOTS：Entities部分</div></div><div class="info-2"><div class="info-item-1">Entities Entities是实体组件系统体系结构的三个主要元素之一。它们代表游戏或应用程序中的各个“事物”。Entities既没有行为也没有数据；取而代之的是，它担任索引各种数据的职责。Systems提供行为，而Components存储数据。 entity本质上是一个ID。最简单方法是把它作为一个超轻量级GameObject甚至没有名称。实体ID稳定；您可以使用它们来存储对另一个component或entities的引用。例如，Hierarchy中的子entity可能需要引用其父entity。 一个EntityManager管理在一个World中所有的entities。EntityManager维护entities列表并组织与entities相关联的数据以实现最佳性能。 尽管实体没有类型，但是可以按与entities相关联的components的类型对其进行分组。创建entities并向其添加components时，EntityManager会持续跟踪监控entities上components的唯一组合。这种独特的组合称为Archetype（原型）。将components...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">1.</span> <span class="toc-text">Systems</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Instantiating-systems"><span class="toc-number">1.1.</span> <span class="toc-text">Instantiating systems</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">System类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAsystem"><span class="toc-number">1.3.</span> <span class="toc-text">创建一个system</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">2.</span> <span class="toc-text">使用Entities.ForEach创建systems</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9entities"><span class="toc-number">2.1.</span> <span class="toc-text">选择entities</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BF%E9%97%AEEntityQuery%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.1.</span> <span class="toc-text">访问EntityQuery对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%80%89components"><span class="toc-number">2.1.2.</span> <span class="toc-text">可选components</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B4%E6%94%B9filtering%EF%BC%88%E8%BF%87%E6%BB%A4%E9%80%89%E9%A1%B9%EF%BC%89"><span class="toc-number">2.1.3.</span> <span class="toc-text">更改filtering（过滤选项）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shared-component-filtering"><span class="toc-number">2.1.4.</span> <span class="toc-text">Shared component filtering</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89ForEach%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text">定义ForEach函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%A7%94%E6%89%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">自定义委托</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Component%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.2.</span> <span class="toc-text">Component参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%91%BD%E5%90%8D%E5%8F%82%E6%95%B0"><span class="toc-number">2.2.3.</span> <span class="toc-text">特殊的命名参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8D%95%E8%8E%B7%E5%8F%98%E9%87%8F"><span class="toc-number">2.3.</span> <span class="toc-text">捕获变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">2.4.</span> <span class="toc-text">支持的功能</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dependencies"><span class="toc-number">2.5.</span> <span class="toc-text">Dependencies</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">3.</span> <span class="toc-text">使用Job.WithCode创建Systems</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F"><span class="toc-number">3.1.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">执行函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E5%AD%98%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.</span> <span class="toc-text">依存关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">4.</span> <span class="toc-text">使用IJobChunk jobs创建System</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8EntityQuery%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE"><span class="toc-number">4.1.</span> <span class="toc-text">使用EntityQuery查询数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89IJobChunk%E7%BB%93%E6%9E%84"><span class="toc-number">4.2.</span> <span class="toc-text">定义IJobChunk结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E5%86%99Execute%E6%96%B9%E6%B3%95"><span class="toc-number">4.3.</span> <span class="toc-text">编写Execute方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%BF%87%E9%82%A3%E4%BA%9B%E5%86%85%E5%AE%B9%E9%83%BD%E6%98%AF%E6%9C%AA%E5%8F%98%E5%8C%96%E7%9A%84entities%E7%9A%84chunk"><span class="toc-number">4.4.</span> <span class="toc-text">跳过那些内容都是未变化的entities的chunk</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96%E5%B9%B6%E8%B0%83%E5%BA%A6job"><span class="toc-number">4.5.</span> <span class="toc-text">实例化并调度job</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">5.</span> <span class="toc-text">通过手动迭代创建Systems</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%8B%E5%8A%A8%E8%BF%AD%E4%BB%A3"><span class="toc-number">5.1.</span> <span class="toc-text">手动迭代</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">6.</span> <span class="toc-text">Systems更新顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Component-System-Groups"><span class="toc-number">6.1.</span> <span class="toc-text">Component System Groups</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System-Ordering-Attributes"><span class="toc-number">6.2.</span> <span class="toc-text">System Ordering Attributes</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Default-System-Groups"><span class="toc-number">6.3.</span> <span class="toc-text">Default System Groups</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AAWorlds"><span class="toc-number">6.4.</span> <span class="toc-text">多个Worlds</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%90%E7%A4%BA%E5%92%8C%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.5.</span> <span class="toc-text">提示和最佳实践</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">7.</span> <span class="toc-text">Job dependencies</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">8.</span> <span class="toc-text">查找数据</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8Systems%E4%B8%AD%E6%9F%A5%E6%89%BEentities%E6%95%B0%E6%8D%AE"><span class="toc-number">8.1.</span> <span class="toc-text">在Systems中查找entities数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8IJobChunk%E4%B8%AD%E6%9F%A5%E6%89%BEentity%E6%95%B0%E6%8D%AE"><span class="toc-number">8.2.</span> <span class="toc-text">在IJobChunk中查找entity数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%A4%B1%E8%B4%A5"><span class="toc-number">8.3.</span> <span class="toc-text">获取数据失败</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">9.</span> <span class="toc-text">Entity Command Buffers</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Entity-command-buffer-systems"><span class="toc-number">9.1.</span> <span class="toc-text">Entity command buffer systems</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/20210912135042.png!webp);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">©&nbsp;2025 - 2026 By 烟雨迷离半世殇</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">2018-2025 lfzxb.top版权所有<br><span id="realtime_duration"></span><br><a href="https://beian.miit.gov.cn" target="_blank">苏ICP备19003389号-1</a><br><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/20210912135040.png!webp" alt="公网安备字" loading='lazy'><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=32032102000159" target="_blank">苏公网安备 32032102000159号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="fluid-control-btn" type="button" title="流体模拟控制台"><i class="fas fa-water"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '508db6cacf197b7363d1',
      clientSecret: '2882a0b135eaa72b3ab256e37249c50733ce9e91',
      repo: 'wqaetly',
      owner: 'wqaetly',
      admin: ['wqaetly'],
      updateCountCallback: commentCount,
      proxy: "https://strong-caramel-969805.netlify.app/github_access_token",
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '00bfe1eb259169603ed65a83de0fc249'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/dayjs/dayjs.min.js"></script><script src="https://cdn.jsdelivr.net/npm/dayjs/plugin/duration.min.js"></script><script src="/js/realtime.js"></script><script>window.FLUID_CONFIG={enable:true,mobile:false,z_index:-1,SIM_RESOLUTION:128,DYE_RESOLUTION:1024,DENSITY_DISSIPATION:1,VELOCITY_DISSIPATION:0.2,PRESSURE:0.8,PRESSURE_ITERATIONS:20,CURL:30,SPLAT_RADIUS:0.25,SPLAT_FORCE:6000,SHADING:true,COLORFUL:true,COLOR_UPDATE_SPEED:10,PAUSED:false,BACK_COLOR:{r:0,g:0,b:0},TRANSPARENT:false,BLOOM:true,BLOOM_ITERATIONS:8,BLOOM_RESOLUTION:256,BLOOM_INTENSITY:0.8,BLOOM_THRESHOLD:0.6,BLOOM_SOFT_KNEE:0.7,SUNRAYS:true,SUNRAYS_RESOLUTION:196,SUNRAYS_WEIGHT:1.0,interaction:{enable:true}};</script><script src="/js/fluid-simulation/dat.gui.min.js"></script><script src="/js/fluid-simulation/fluid-core.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'D3U85CARGJ',
    apiKey: '3edfc5bada9a140d5a4126085596f99c',
    indexName: 'blogsearch',
    container: '#docsearch',
    placeholder: '搜索文章',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div>
    <link rel="stylesheet" href="https://ai.tianli0.top/static/public/postChatUser_summary.min.css">
    <script>
        let tianliGPT_key = 'S-TY6LYYCZMYV6UADE';
        let tianliGPT_postSelector = '#article-container';
        let tianliGPT_Title = '烟雨迷离半世殇（人机版）为您总结文章';
        let tianliGPT_postURL = 'https://www.lfzxb.top/*/';
        let tianliGPT_blacklist = '';
        let tianliGPT_wordLimit = '50000';
        let tianliGPT_typingAnimate = false;
        let tianliGPT_theme = 'menghuan';
        var postChatConfig = {
          backgroundColor: "#3e86f6",
          bottom: "16px",
          left: "16px",
          fill: "#FFFFFF",
          width: "44px",
          frameWidth: "375px",
          frameHeight: "600px",
          defaultInput: false,
          upLoadWeb: true,
          showInviteLink: true,
          userTitle: "烟雨迷离半世殇（人机版）为您服务",
          userDesc: "在下定知无不言",
          addButton: true,
          beginningText: "这篇文章介绍了",
          userIcon: "https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp",
          userMode: "magic",
          defaultChatQuestions: ["你好","你是谁"],
          defaultSearchQuestions: ["视频压缩","设计"]
        };
    </script>
    <script data-postchat_key="S-TY6LYYCZMYV6UADE" src="https://ai.tianli0.top/static/public/postChatUser_summary.min.js"></script>
  </body></html>