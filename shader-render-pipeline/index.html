<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Unity Shader入门精要学习笔记：渲染流水线 | 登峰造极者，殊途亦同归。</title><meta name="author" content="烟雨迷离半世殇"><meta name="copyright" content="烟雨迷离半世殇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言 本系列博客记录学习《Unity Shader入门精要》（冯乐乐著）中的笔记和感悟。 渲染流水线 综述 渲染流水线的最终目的在于生成或者说是渲染一张二维纹理。 什么是渲染流水线 渲染流水线的任务在于：从一系列的的顶点数据，纹理等信息出发，把这些信息最终转换成一张人眼可以看到的图像。而这个工作通常是由CPU和GPU共同完成的。 渲染流程分为三个阶段： 应用阶段 主要提供渲染图元（点，线，三角面）">
<meta property="og:type" content="article">
<meta property="og:title" content="Unity Shader入门精要学习笔记：渲染流水线">
<meta property="og:url" content="https://www.lfzxb.top/shader-render-pipeline/index.html">
<meta property="og:site_name" content="登峰造极者，殊途亦同归。">
<meta property="og:description" content="前言 本系列博客记录学习《Unity Shader入门精要》（冯乐乐著）中的笔记和感悟。 渲染流水线 综述 渲染流水线的最终目的在于生成或者说是渲染一张二维纹理。 什么是渲染流水线 渲染流水线的任务在于：从一系列的的顶点数据，纹理等信息出发，把这些信息最终转换成一张人眼可以看到的图像。而这个工作通常是由CPU和GPU共同完成的。 渲染流程分为三个阶段： 应用阶段 主要提供渲染图元（点，线，三角面）">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ%E6%88%AA%E5%9B%BE20191009225439.png!webp">
<meta property="article:published_time" content="2021-02-04T00:00:00.000Z">
<meta property="article:modified_time" content="2021-02-04T00:00:00.000Z">
<meta property="article:author" content="烟雨迷离半世殇">
<meta property="article:tag" content="图形渲染">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ%E6%88%AA%E5%9B%BE20191009225439.png!webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Unity Shader入门精要学习笔记：渲染流水线",
  "url": "https://www.lfzxb.top/shader-render-pipeline/",
  "image": "https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ截图20191009225439.png!webp",
  "datePublished": "2021-02-04T00:00:00.000Z",
  "dateModified": "2021-02-04T00:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "烟雨迷离半世殇",
      "url": "https://www.lfzxb.top/www.lfzxb.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp"><link rel="canonical" href="https://www.lfzxb.top/shader-render-pipeline/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="AhlEJ91V_L12bkwRF1ZS0BbytGCfsjqCX4GXztUluC8"><meta name="baidu-site-verification" content="iRRtEBalDiujISsN"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 8
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-7235595771604497',
  enable_page_level_ads: 'true'
});</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-XSL6D8K8G2"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-XSL6D8K8G2')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-XSL6D8K8G2', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":800,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Unity Shader入门精要学习笔记：渲染流水线',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/CustomIcons/iconfontformaliyun.css"><meta name="referrer" content="no-referrer-when-downgrade"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar" loading='lazy'></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">246</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">188</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-torii-gate"></i><span> 蓬莱仙境</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-stream"></i><span> 白驹过隙</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 包罗万象</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分朋引类</span></a></div><div class="menus_item"><a class="site-page" href="/self/"><i class="fa-fw fas fa-id-card"></i><span> 择交而友</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 一见如故</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ截图20191009225439.png!webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/202507052331881.png!webp" alt="Logo" loading='lazy'></a><a class="nav-page-title" href="/"><span class="site-name">Unity Shader入门精要学习笔记：渲染流水线</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-torii-gate"></i><span> 蓬莱仙境</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-stream"></i><span> 白驹过隙</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 包罗万象</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分朋引类</span></a></div><div class="menus_item"><a class="site-page" href="/self/"><i class="fa-fw fas fa-id-card"></i><span> 择交而友</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 一见如故</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Unity Shader入门精要学习笔记：渲染流水线</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-04T00:00:00.000Z" title="发表于 2021-02-04 00:00:00">2021-02-04</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-02-04T00:00:00.000Z" title="更新于 2021-02-04 00:00:00">2021-02-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93/">图形渲染</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/">游戏引擎</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93/%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86/">理论知识</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/Unity/">Unity</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>8分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/shader-render-pipeline/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;这篇文章已经&quot;,&quot;messageNext&quot;:&quot;天没维护了，相关内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2021-02-04 00:00:00&quot;}" hidden=""></div><div id="postchat_postcontent"><h1>前言</h1>
<p>本系列博客记录学习《Unity Shader入门精要》（冯乐乐著）中的笔记和感悟。</p>
<h1>渲染流水线</h1>
<h2 id="综述">综述</h2>
<p>渲染流水线的最终目的在于生成或者说是渲染一张二维纹理。</p>
<h3 id="什么是渲染流水线">什么是渲染流水线</h3>
<p>渲染流水线的任务在于：从一系列的的顶点数据，纹理等信息出发，把这些信息最终转换成一张人眼可以看到的图像。而这个工作通常是由CPU和GPU共同完成的。 渲染流程分为三个阶段：</p>
<h4 id="应用阶段">应用阶段</h4>
<p>主要提供<code>渲染图元（点，线，三角面）</code>，以及<code>渲染状态（顶点片元着色器，光源属性，材质等）</code>，我们开发者在这一阶段有绝对控制权。</p>
<h4 id="几何阶段">几何阶段</h4>
<p>处理所有和我们要绘制的几何相关的事情（例如应用阶段提供的渲染图元），决定需要绘制的图元，如何绘制图元，在哪里绘制图元。这一阶段在GPU进行。 一个重要任务是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理。 这一阶段会输出屏幕空间的二维顶点坐标，每个顶点对应的深度值，着色等相关信息，并传递给下一个阶段。</p>
<h4 id="光栅化阶段">光栅化阶段</h4>
<p>使用几何阶段传递的数据来产生屏幕上的像素，并渲染出最后的图像。 这一阶段也是在GPU上运行。 光栅化的主要任务是决定每个渲染图元中的哪些像素应该被绘制在屏幕上，他需要对上一个阶段得到的逐顶点数据（例如纹理坐标，顶点颜色等）进行插值，然后进行逐像素处理。</p>
<h2 id="CPU与GPU之间的通信">CPU与GPU之间的通信</h2>
<p>在渲染流水线的应用阶段可细分为三个阶段 1. 把数据加载到显存中 2. 设置渲染状态 3. 调用Draw Call</p>
<h3 id="把数据加载到显存中">把数据加载到显存中</h3>
<p>所有渲染所需数据都需要经历<code>硬盘——系统内存——显存</code>这一阶段。</p>
<h3 id="设置渲染状态">设置渲染状态</h3>
<p>渲染状态定义了场景中的网格是怎样被渲染的。例如，使用哪个顶点片元着色器，光源属性，材质等。如果不对渲染状态进行更改，那么所有网格都将使用同一种渲染状态。 完成以上工作后，CPU就需要调用一个渲染命令——<code>Draw Call</code>告诉GPU进行渲染。</p>
<h3 id="调用Draw-Call">调用Draw Call</h3>
<p>Draw Call是一个命令，发起方是CPU，接收方是GPU。这个命令仅仅会指向一个需要被渲染的图元列表（不包含顶点片元着色器，光源属性，材质等信息）。 当GPU收到Draw Call，就会根据渲染状态和所有接受到的顶点数据进行计算。最终输出成屏幕上显示的像素。而这个过程，就是GPU流水线。</p>
<h2 id="GPU流水线">GPU流水线</h2>
<p>当GPU从CPU那里得到渲染命令（Draw Call）后就会进行一系列流水线操作，最终把图元渲染到屏幕上。</p>
<h3 id="概述">概述</h3>
<h4 id="几何阶段-2">几何阶段</h4>
<p>GPU的渲染流水线接收顶点数据作为输入。这些顶点数据是由<code>应用阶段</code>加载到显存中，再由Draw Call指定的。这些数据随后被传递给<code>顶点着色器</code>。 <code>PS：一般是顶点-&gt;图元-&gt;片元-&gt;像素的流程</code> <strong><code>顶点着色器（Vertex Shader）</code></strong>：完全可编程，通常用于实现顶点的空间变换，顶点着色等功能。 <strong><code>曲面细分着色器（Tessellation Shader）</code></strong>：用于细分图元。 <strong><code>几何着色器（Geometry Shader）</code></strong>：可用于执行<code>逐图元（Per-Primitive）</code>的着色操作，或者用于产生更多的图元。 接下来是<code>裁剪（Clipping）</code>，目的是将那些不在摄像机视野内的顶点裁剪掉，并提出某些三角图元的面片。 几何阶段的最后一个阶段是<code>屏幕映射（Screen Mapping）</code>，负责把每个图元的坐标转换到屏幕坐标系中。</p>
<h4 id="光栅化阶段-2">光栅化阶段</h4>
<p>光栅化阶段中的三角形设置和三角形遍历也是固定函数。 **<code>片元着色器（Triangle Traversal）</code>**是完全可编程的它用于实现<code>逐片元（Per-FragmentOperations）</code>的着色操作</p>
<h3 id="顶点着色器">顶点着色器</h3>
<p>顶点着色器（Vertex Shader）是流水线的第一个阶段，它的输入来自CPU。顶点着色器的处理单位是顶点，也就是说，<code>输入进来的每个顶点都会调用一次顶点着色器</code>。 需要完成的工作有：坐标变换和逐顶点光照，也可以输出后续阶段所需的数据。</p>
<h4 id="坐标变换">坐标变换</h4>
<p>对顶点的坐标进行某种变换。<code>一个最基本的顶点着色器必须完成的一个工作是：把顶点坐标从模型空间转换到齐次裁剪空间</code>。</p>
<h4 id="计算顶点颜色">计算顶点颜色</h4>
<p>顶点着色器会对顶点位置进行坐标变换并计算顶点颜色。</p>
<h3 id="裁剪">裁剪</h3>
<p>完全在视野内的图元就继续传递给下一个流水线阶段，完全在视野外的图元就不会继续向下传递，因为他们不需要被渲染。而那些部分在事业内的图元需要进行一个处理，这就是裁剪。</p>
<h3 id="屏幕映射">屏幕映射</h3>
<p>任务是把每个图元的x和y坐标转换到屏幕坐标系。 <code>注意，OpenGL把屏幕的左下角当成最小的窗口坐标值，而DirectX则定义了屏幕左上角为最小的窗口坐标值。</code></p>
<h3 id="三角形设置">三角形设置</h3>
<p>由这一步开始就进入了光栅化阶段，从上一个阶段输出的信息时屏幕坐标系下的定点位置以及和它们相关的额外信息，如深度值（z坐标），法线方向，视角方向等。 光栅化阶段有两个最重要的目标：计算每个图元覆盖了哪些像素，以及为这些像素计算他们的颜色。 三角形设置：计算三角网格表示数据，并把此数据输出给下一阶段的过程</p>
<h3 id="三角形遍历">三角形遍历</h3>
<p>将会检查每个像素是否被一个三角网格所覆盖。如果被覆盖就会生成一个<code>片元</code>。这个过程也叫做<code>扫描变换</code>。 <img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ%E6%88%AA%E5%9B%BE20191009225439.png!webp" alt="" loading='lazy'> 一个片元并不是真正的像素，还包含了很多状态，这些状态计算每个像素的最终颜色。这些状态包括屏幕坐标，深度信息，顶点信息等。</p>
<h3 id="片元着色器">片元着色器</h3>
<p>片元着色器输入是上阶段对顶点信息插值的结果，具体来说就是从顶点着色器输出的数据插值得到的，而他的输出是一个或多个颜色值。 <img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ%E6%88%AA%E5%9B%BE20191009225450.png!webp" alt="" loading='lazy'> 前面的光栅化阶段实际上并不会影响屏幕上的每个像素的颜色值，而是会产生一系列的数据信息，用来表述一个三角网格是怎样覆盖每个像素的。而每个片元就负责储存这样一系列数据。真正会对像素产生影响的阶段是——<code>逐片元操作</code></p>
<h3 id="逐片元操作">逐片元操作</h3>
<p>这是渲染流水线的最后一步。 主要任务有 1. 决定每个片元的可见性。设计测试工作，比如深度测试，模板测试 2. 如果一个片元通过了所有测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区的颜色进行合并或者说是混合。 这个阶段需要解决每个片元的可见性问题，这需要一系列测试。 <img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ%E6%88%AA%E5%9B%BE20190827225021.png!webp" alt="" loading='lazy'></p>
<h4 id="模板测试">模板测试</h4>
<p>模板测试和我们经常听到的颜色缓冲，深度缓冲几乎是一类东西。 如果开启模板测试,GPU会先读取模板缓冲区中该偏远位置的模板值，然后将该值和读取到的参考值进行比较。更加具体的规则（取舍条件）完全可以由开发者自己定制。</p>
<h4 id="深度测试">深度测试</h4>
<p>如果开启深度测试，GPU会把该片元的深度值和已经存在于深度缓冲区中的深度值进行比较。更加具体的规则（取舍条件）完全可以由开发者自己定制。</p>
<h4 id="混合">混合</h4>
<p>关闭后片元着色器计算得到的颜色值就会直接覆盖掉颜色缓冲区中的像素值。 <img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ%E6%88%AA%E5%9B%BE20190827225647.png!webp" alt="" loading='lazy'></p>
<h2 id="一些专业术语科普">一些专业术语科普</h2>
<h3 id="OpenGL-DirectX">OpenGL/DirectX</h3>
<p>OpenGL和DirectX是我们访问GPU的桥梁。封装了很多编程接口，一个应用程序向这些接口发送渲染命令，这些接口会依次向显卡驱动发送渲染命令，这些显卡驱动知道如何和GPU通信，正是他们把OpenGL或DirectX的函数调用翻译成了GPU能听懂的语言，同时也负责把纹理等数据转换成GPU所支持的格式。 <img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ%E6%88%AA%E5%9B%BE20190827211444.png!webp" alt="" loading='lazy'></p>
<h3 id="HLSL，GLSL，CG">HLSL，GLSL，CG</h3>
<p>这三个都是编写Shader的语言。 DirectX的HLSL（High Level Shading Language），OpenGL的GLSL（OpenGL Shading Language），NVIDIA的CG（C for Grapgic）. GLSL：跨平台，但由于硬件供应商不同，编译结果可能不同 HLSL：微软控制着色器的编译，就算硬件供应商不同，同一个着色器的编译结果也是一样的。 CG：真正的跨平台，自适应平台。</p>
<h3 id="Draw-Call">Draw Call</h3>
<p>一个常见误区是Draw Call中造成性能问题的元凶是GPU，认为GPU上的状态切换是耗时的，其实不是的，真正拖后腿的是CPU。</p>
<h4 id="问题：CPU和GPU如何实现并行工作">问题：CPU和GPU如何实现并行工作</h4>
<p><strong><code>命令缓冲区（Command Buffer）</code></strong> <img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ%E6%88%AA%E5%9B%BE20190827231014.png!webp" alt="" loading='lazy'></p>
<h4 id="问题：为什么Draw-Call多了会影响帧率">问题：为什么Draw Call多了会影响帧率</h4>
<p>在每次调用Draw Call之前，CPU需要向GPU发送很多内容，包括数据，状态和命令等。CPU在这一过程中也需要完成很多工作，比如检查渲染状态。而一旦CPU完成了这些准备工作，GPU就可以开始本次渲染。GPU渲染能力是很强的，渲染200个还是2000个三角网格通常没什么太大区别，因此渲染速度往往快于CPU提交命令的速度。 <img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ%E6%88%AA%E5%9B%BE20190827231415.png!webp" alt="" loading='lazy'></p>
<h4 id="问题：如何减少Draw-Call">问题：如何减少Draw Call</h4>
<p>方法之一：批处理 提交大量很小的Draw Call会造成CPU的性能瓶颈，即CPU把时间都花费在了准备Draw Call工作上了，那么一个很显然的有话想法就是把很多Draw Call合并成一个打的Draw Call，这就是批处理的思想。 由于我们需要在CPU的内存中合并网格，而合并的过程是需要消耗时间的。因此，批处理技术更加适合那些静态的物体，例如不会移动的大地，石头等。对于这些静态物体。我们只需要合并一次即可。当然，我们也可以对动态物体进行批处理。但是由于这些物体是不断运动的，因此每一帧都需要进行合并然后发给GPU，这对空间和时间都会造成一定的影响。 正常开发中，我们需要注意两点</p>
<ul>
<li>避免使用大量很小的网格</li>
<li>避免使用过多的材质，尽量在不同的网格之间共用一个材质。</li>
</ul>
<h2 id="总结">总结</h2>
<p>Shader就是 - GPU流水线上一些可高度编程的阶段，而由着色器编译出来的最终代码是会在GPU上运行的。 - 有一些特定类型的着色器，如顶点着色器，片元着色器等 - 依靠着色器我们可以控制流水线中的渲染细节，例如用顶点着色器来进行顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。</p>
<h2 id="渲染流水线流程图">渲染流水线流程图</h2>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ%E6%88%AA%E5%9B%BE20190828000507.png!webp" alt="" loading='lazy'></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="www.lfzxb.top">烟雨迷离半世殇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.lfzxb.top/shader-render-pipeline/">https://www.lfzxb.top/shader-render-pipeline/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.lfzxb.top" target="_blank">登峰造极者，殊途亦同归。</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93/">图形渲染</a></div><div class="post-share"><div class="social-share" data-image="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ截图20191009225439.png!webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175314.png!webp" target="_blank"><img class="post-qr-code-img" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175314.png!webp" alt="微信" loading='lazy'></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175304.png!webp" target="_blank"><img class="post-qr-code-img" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175304.png!webp" alt="支付宝" loading='lazy'></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><div class="ads-wrap"><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7235595771604497" data-ad-slot="9104433828"></ins><script> (adsbygoogle = window.adsbygoogle || []).push({});</script></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/shader-unity-shader-base/" title="Unity Shader入门精要学习笔记：Unity Shader基础"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/08/QQ截图20190828180847.png!webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post" loading='lazy'><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Unity Shader入门精要学习笔记：Unity Shader基础</div></div><div class="info-2"><div class="info-item-1">Unity Shader概述 材质和Unity Shader 在Unity中需要配合使用材质和Unity Shader才能达到需要的效果 Unity Shader基础：ShaderLab 什么是ShaderLab Unity Shader是Unity为开发者提供的高层级的渲染抽象层。 在Unity中，所有的Unity Shader都是使用ShaderLab来编写的。 ShaderLab是Unity提供的编写Unity Shader的一种说明性语言。 Unity在背后会根据使用的平台来把这些结构编译成真正的代码和Shader文件，而开发者只需要和Unity Shader打交道即可。 Unity Shader的结构 12345678910111213141516171819202122232425262728Shader "Shader的名字，通过增加'/'来细分种类"{    Properties    {		//Name:属性的名字		//display name：显示在材质面板上的名字		//PropertyType：...</div></div></div></a><a class="pagination-related" href="/reminiscence-once-i-grew-up-they-are-not/" title="那些年我喜欢的主播——曾经的我长大了，他们却不在了"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/202509232351560.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post" loading='lazy'><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">那些年我喜欢的主播——曾经的我长大了，他们却不在了</div></div><div class="info-2"><div class="info-item-1">今天天气很好，但是昨天睡得很晚，第一节又有课，7:50就起床了，所以很困。 但是又不想午睡，把玩的时间浪费在睡觉上总有点不合适，那干什么呢？ LOL？不想玩，太累了。 看直播吧，嗯小C不错，但是总感觉少了点什么，哦，不知道什么时候阿亮已经不在了，看了一会，除了那略显做作的大吼大叫，已经没什么节目效果了吧。带着略微烦躁的心情推出了直播间。 发了一会呆，突然想起，去看看曾经的那些主播吧。 最先想起的是猴哥，曾经和老王闹掰之后人气就再也回不来了了，直播间也尘封已久了。 老王其实现在也还行，在企鹅直播，当年可是龙珠LOL区霸主级别的主播，虽然现企鹅人气大不如前，不过相对于其他主播来说处境已经很好了。 城管希，曾经的观赏性极强的王者AP蛮王，也早就不在了，据说考上公务员之后就停播了。 马老C现在热度还行，靠着B站那几个传菜的互相反哺，经营的不错，不过这种情况还能维持多久呢？ LOL区就这么多吧，接下来是从高中玩到大学的英魂之刃 首先想到的是LS小妖，当时的童年女神哦，其实在上高中的时候偶然瞥见了一次她的直播，没有了当年的清纯，浓妆艳抹的样子。现在在各个平台也找不到了，据说是擦边球违规被封了...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/air-distortion-based-on-pp-in-urp/" title="URP下基于后处理的热空气扭曲效果"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/20210907004036.png!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-02-20</div><div class="info-item-2">URP下基于后处理的热空气扭曲效果</div></div><div class="info-2"><div class="info-item-1">前言 前几天在网上看到一位大神的 Unity Shader-热空气扭曲效果 文章，感觉应该是个常见的效果，所以准备在URP里实现一下，正好再次深入使用一下URP，期间也遇到了一些匪夷所思的坑，也会在文章中说明。 原文中的全屏扭曲和基于GrabPass的方式都省略不谈，这里来用URP实现一下基于后处理的热空气扭曲。 环境 URP版本：7.3.1 Unity版本：2019.4.8f1 正文 原文中的实现核心思路是在需要扭曲的地方摆放一个面片，然后将这个面片渲染到一张RenderTexture上作为Mask，后处理的时候以Mask为基准决定ColorTexture哪些地方需要扭曲，然后对一张Noise图进行采样，对目标像素做偏移，达到扭曲的效果。 仔细分析后发现其实就一个难点，就是如何在URP下将物体渲染到一个RenderTexture上。 恰巧前阵子 研究战争迷雾 的时候看到了这篇文章：流朔 -【Unity URP】以Render Feature实现卡通渲染中的刘海投影 ，其中就有将物体渲染到RenderTexture的相关操作，这样一来就没有问题了，开搞。 首先创建一个Render...</div></div></div></a><a class="pagination-related" href="/color-pipeline/" title="颜色管线精粹"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2025/image-20250126195238973.png" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-01-28</div><div class="info-item-2">颜色管线精粹</div></div><div class="info-2"><div class="info-item-1">前言 接触图形学中颜色相关的概念许久了，色域，LDR，HDR，ToneMapping，伽马空间，线性空间，sRGB，ACES等名词也都算耳熟能详，但一直以来都是零散细碎的知识点，从来没系统整理过。 个人一直关注UE的发展和官方油管频道，恰巧看到了一个颜色管线的视频，算是事无巨细的详解了上面每一个概念和他们之间的关系，遂有此文，与诸君共赏。 今天我们要讨论发生在引擎和渲染过程中的颜色管线以及特定的颜色转换 线性渲染 我们先想象一个简化版的渲染管线，一个纹理输入，在线性空间下渲染，经过后处理，最后显示在窗口中（或者存储到一个文件中）  我们先从中间看起，即Linear Rendering in RGB，既然是渲染，我们首先应该关注的就是颜色值 颜色值代表光量，可以是范围很大的值，也可以是范围很小的值 并且他们是线性的，这意味着如果我们将颜色值翻倍，我们得到的光量也是翻倍的  他们用于引擎的工作环境和运行时环境的颜色空间中 在更加深入之前，我们先了解一下颜色的基础知识 颜色基础知识  一般我们在谈论颜色空间的时候，同时涵盖了颜色编码和颜色空间这两个概念，我们先来看颜色空间 颜色空间  ...</div></div></div></a><a class="pagination-related" href="/early-z-test-and-late-z-test/" title="Early-Z和Late-Z规则"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/20210907005950.png!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2023-07-24</div><div class="info-item-2">Early-Z和Late-Z规则</div></div><div class="info-2"><div class="info-item-1">前言 已经不止一次看到有文章说：不管有没有Early-Z最后的Late-Z一定会执行了，仔细想一下其实是不合理的：  Early-Z相当于把Late-Z提前，一样会有逐片元的深度测试和深度写入，如果Early-Z和Late-Z是共存的，那么就有两次Z-Buffer的读取和写入，造成带宽浪费 Early-Z因为种种原因失效了，执行Late-Z无可非议，但如果Early-Z没有失效，我们都在Early-Z处理好了，为什么还需要在Late-Z处理一次？  这篇文章就把深度缓冲区的所有操作都整理起来，并且还会包含一些引申出来的知识点，给每位看官进行一条龙服务。 正文 名词规范 国际惯例了属于是，为了避免歧义，本文中所有用到的名词，英语词汇都将在此处列出，希望看官们能把此处列出的名词和释义代入文章中，而不是自己脑海里的，这样你好我也好：  PS：片元着色器 Z-Buffer：深度缓冲区 Z-Test：深度测试 Z-Write：深度写入 Early-Z：提前Z-Test和Z-Write，位于光栅化阶段之后，PS阶段之前，以pixel quad为单位（既以4个像素为一组，因为深度缓存内的数据是...</div></div></div></a><a class="pagination-related" href="/fog-of-war-based-on-ss-in-urp/" title="基于URP屏幕空间采样与JobSystem加速的战争迷雾"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/20210920154319.jpg!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-10-21</div><div class="info-item-2">基于URP屏幕空间采样与JobSystem加速的战争迷雾</div></div><div class="info-2"><div class="info-item-1">  本文章已于 2021.9.24 更新，提供一个 JobSystem 加速示例。 本文章已于 2021.3.23 更新，将用到的 Shader 代码转为 HLSL 语言，支持 SRP Batcher（虽然在这里并没有什么卵用），优化模糊 Blit 次数。  前言 这阵子在研究战争迷雾相关的内容，在网上找了一些文章和开源库，主要有两种做法：  一是直接在场景上放一张大面片，用作迷雾，这种方式适用于相机角度不会发生改变的情况，否则会有穿帮的风险，但这种方案性能比较好。 二是基于屏幕空间对迷雾纹理进行采样，然后通过后处理的方式得到最终游戏画面，这种方案最为稳妥，但相应的性能会低一些。  但是网上找得到的战争迷雾方案全都是 Built-In 管线下进行的，那么对于基于屏幕后处理的战争迷雾，就会不可避免的涉及到 OnRenderImage 和 Blit 操作，这些操作在默认不指定相机 RenderTexture 的情况下会涉及对 GPU 中的 FrameBuffer 进行拷贝 + 和 CPU 与 GPU 之间的数据传递，都是比较消耗性能的操作，需要尽量减少，单一个战争迷雾可能还好，后处理...</div></div></div></a><a class="pagination-related" href="/fundamentals-of-computer-graphics-chapter11-111-5/" title="纹理映射"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/20210920155919.jpg!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-01-01</div><div class="info-item-2">纹理映射</div></div><div class="info-2"><div class="info-item-1">纹理映射 在尝试复制真实世界的外貌时，人们很快意识到几乎任何物质的表面都是有特征的。木材长有纹理。皮肤长有皱纹；布料会有编织结构；油画会有画刷或滚筒留下的痕迹，即使是光滑的塑料也会有制作他的模具的凹凸不平的痕迹，并且光滑金属显示出机器加工过程的痕迹。材料的没有特征的地方很快也会被斑点，凹痕，污点，划痕，指纹和污垢覆盖。 在图形学中，我们把这些现象统称为“空间上表面属性的变化”——表面的属性在每一处地方都在发生着变化，但并没有真正意义上改变表面的形状，考虑到这些因素，所有的建模和渲染系统都提供了一些纹理映射的涵义：使用一个被称作纹理贴图，纹理图像，或者仅仅是一个纹理，来存储这些你想要在一个表面上展示的细节，然后进行数学处理，把这个图片“映射”到表面上。 事实证明，一旦存在将图像映射到表面的机制，就会有很多奇淫技巧，这些技巧已经超过了我们介绍表面细节的基本目标。纹理可以用来制作阴影和反射，提供光照信息，甚至定义表面形状。在复杂的交互程序中，纹理经常被用于存储与其作为一张图片毫无干系的的数据（这里不知道怎么组织语言了，举个例子就是我们可以把骨骼动画烘焙到一张纹理中，从而让GPU去执行蒙...</div></div></div></a><a class="pagination-related" href="/graphic-profilertools-guides/" title="常见游戏渲染Profiler工具使用指南"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/20211203115213.png!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2021-11-26</div><div class="info-item-2">常见游戏渲染Profiler工具使用指南</div></div><div class="info-2"><div class="info-item-1">前言 最近除了拼UI之外也在断断续续做着渲染性能优化工作，其实这块内容说难也不难，说简单肯定也不简单，不难是因为当今Profiler工具相当完善，甚至可以精确到每一条Shader汇编指令的耗时，XCode还可以给出优化建议，不简单是因为很多时候就算得知了性能热点，但却不知道如何下手，因为需要掌握的知识很多，比如要会看Nvidia，OpenGL，Vulkan等后端API的汇编码，要知道做了优化操作之后对渲染流程中各个模块的影响，比如为了减少OverDraw把Alpha Blend改成Alpha Test，Early-z会不会失效，在移动平台是不是性能更高，还有些情况让人纠结，比如优化了下ALU耗时，带宽又上去了。 对于老手来说可能一行代码写下来，什么带宽，ALU耗时，精度转换，甚至汇编码都知道是什么个情况了，对于新手来说，就得老老实实对着Profiler工具慢慢看，慢慢调。当然这是少数情况了，大部分情况下老手们依旧要看Profiler，因为谁也捉摸不透不同的GPU架构和指令集会做出怎么样的优化（负优化），所以于情于理Profiler工具的学习还是很必要的。 目前用下来感觉最好用的移...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">2.</span> <span class="toc-text">渲染流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%BC%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">综述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">2.1.1.</span> <span class="toc-text">什么是渲染流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">应用阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">几何阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E6%A0%85%E5%8C%96%E9%98%B6%E6%AE%B5"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">光栅化阶段</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CPU%E4%B8%8EGPU%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">2.2.</span> <span class="toc-text">CPU与GPU之间的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%8A%E6%95%B0%E6%8D%AE%E5%8A%A0%E8%BD%BD%E5%88%B0%E6%98%BE%E5%AD%98%E4%B8%AD"><span class="toc-number">2.2.1.</span> <span class="toc-text">把数据加载到显存中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E6%B8%B2%E6%9F%93%E7%8A%B6%E6%80%81"><span class="toc-number">2.2.2.</span> <span class="toc-text">设置渲染状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E7%94%A8Draw-Call"><span class="toc-number">2.2.3.</span> <span class="toc-text">调用Draw Call</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#GPU%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-number">2.3.</span> <span class="toc-text">GPU流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">2.3.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%A0%E4%BD%95%E9%98%B6%E6%AE%B5-2"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">几何阶段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%89%E6%A0%85%E5%8C%96%E9%98%B6%E6%AE%B5-2"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">光栅化阶段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">2.3.2.</span> <span class="toc-text">顶点着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9D%90%E6%A0%87%E5%8F%98%E6%8D%A2"><span class="toc-number">2.3.2.1.</span> <span class="toc-text">坐标变换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E9%A1%B6%E7%82%B9%E9%A2%9C%E8%89%B2"><span class="toc-number">2.3.2.2.</span> <span class="toc-text">计算顶点颜色</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%81%E5%89%AA"><span class="toc-number">2.3.3.</span> <span class="toc-text">裁剪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E6%98%A0%E5%B0%84"><span class="toc-number">2.3.4.</span> <span class="toc-text">屏幕映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E8%AE%BE%E7%BD%AE"><span class="toc-number">2.3.5.</span> <span class="toc-text">三角形设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%A7%92%E5%BD%A2%E9%81%8D%E5%8E%86"><span class="toc-number">2.3.6.</span> <span class="toc-text">三角形遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%87%E5%85%83%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">2.3.7.</span> <span class="toc-text">片元着色器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%90%E7%89%87%E5%85%83%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.8.</span> <span class="toc-text">逐片元操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%9D%BF%E6%B5%8B%E8%AF%95"><span class="toc-number">2.3.8.1.</span> <span class="toc-text">模板测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E6%B5%8B%E8%AF%95"><span class="toc-number">2.3.8.2.</span> <span class="toc-text">深度测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B7%E5%90%88"><span class="toc-number">2.3.8.3.</span> <span class="toc-text">混合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD%E7%A7%91%E6%99%AE"><span class="toc-number">2.4.</span> <span class="toc-text">一些专业术语科普</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenGL-DirectX"><span class="toc-number">2.4.1.</span> <span class="toc-text">OpenGL/DirectX</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HLSL%EF%BC%8CGLSL%EF%BC%8CCG"><span class="toc-number">2.4.2.</span> <span class="toc-text">HLSL，GLSL，CG</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Draw-Call"><span class="toc-number">2.4.3.</span> <span class="toc-text">Draw Call</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9ACPU%E5%92%8CGPU%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%B9%B6%E8%A1%8C%E5%B7%A5%E4%BD%9C"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">问题：CPU和GPU如何实现并行工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88Draw-Call%E5%A4%9A%E4%BA%86%E4%BC%9A%E5%BD%B1%E5%93%8D%E5%B8%A7%E7%8E%87"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">问题：为什么Draw Call多了会影响帧率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%EF%BC%9A%E5%A6%82%E4%BD%95%E5%87%8F%E5%B0%91Draw-Call"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">问题：如何减少Draw Call</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B8%B2%E6%9F%93%E6%B5%81%E6%B0%B4%E7%BA%BF%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">2.6.</span> <span class="toc-text">渲染流水线流程图</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/20210912135042.png!webp);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">©&nbsp;2025 - 2026 By 烟雨迷离半世殇</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">2018-2025 lfzxb.top版权所有<br><span id="realtime_duration"></span><br><a href="https://beian.miit.gov.cn" target="_blank">苏ICP备19003389号-1</a><br><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/20210912135040.png!webp" alt="公网安备字" loading='lazy'><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=32032102000159" target="_blank">苏公网安备 32032102000159号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="fluid-control-btn" type="button" title="流体模拟控制台"><i class="fas fa-water"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '508db6cacf197b7363d1',
      clientSecret: '2882a0b135eaa72b3ab256e37249c50733ce9e91',
      repo: 'wqaetly',
      owner: 'wqaetly',
      admin: ['wqaetly'],
      updateCountCallback: commentCount,
      proxy: "https://strong-caramel-969805.netlify.app/github_access_token",
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '2948a12b88872eee617a22b34d68e308'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/dayjs/dayjs.min.js"></script><script src="https://cdn.jsdelivr.net/npm/dayjs/plugin/duration.min.js"></script><script src="/js/realtime.js"></script><script>window.FLUID_CONFIG={enable:true,mobile:false,z_index:-1,SIM_RESOLUTION:128,DYE_RESOLUTION:1024,DENSITY_DISSIPATION:1,VELOCITY_DISSIPATION:0.2,PRESSURE:0.8,PRESSURE_ITERATIONS:20,CURL:30,SPLAT_RADIUS:0.25,SPLAT_FORCE:6000,SHADING:true,COLORFUL:true,COLOR_UPDATE_SPEED:10,PAUSED:false,BACK_COLOR:{r:0,g:0,b:0},TRANSPARENT:false,BLOOM:true,BLOOM_ITERATIONS:8,BLOOM_RESOLUTION:256,BLOOM_INTENSITY:0.8,BLOOM_THRESHOLD:0.6,BLOOM_SOFT_KNEE:0.7,SUNRAYS:true,SUNRAYS_RESOLUTION:196,SUNRAYS_WEIGHT:1.0,interaction:{enable:true}};</script><script src="/js/fluid-simulation/dat.gui.min.js"></script><script src="/js/fluid-simulation/fluid-core.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'D3U85CARGJ',
    apiKey: '3edfc5bada9a140d5a4126085596f99c',
    indexName: 'blogsearch',
    container: '#docsearch',
    placeholder: '搜索文章',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div>
    <link rel="stylesheet" href="https://ai.tianli0.top/static/public/postChatUser_summary.min.css">
    <script>
        let tianliGPT_key = 'S-TY6LYYCZMYV6UADE';
        let tianliGPT_postSelector = '#article-container';
        let tianliGPT_Title = '烟雨迷离半世殇（人机版）为您总结文章';
        let tianliGPT_postURL = 'https://www.lfzxb.top/*/';
        let tianliGPT_blacklist = '';
        let tianliGPT_wordLimit = '50000';
        let tianliGPT_typingAnimate = false;
        let tianliGPT_theme = 'menghuan';
        var postChatConfig = {
          backgroundColor: "#3e86f6",
          bottom: "16px",
          left: "16px",
          fill: "#FFFFFF",
          width: "44px",
          frameWidth: "375px",
          frameHeight: "600px",
          defaultInput: false,
          upLoadWeb: true,
          showInviteLink: true,
          userTitle: "烟雨迷离半世殇（人机版）为您服务",
          userDesc: "在下定知无不言",
          addButton: true,
          beginningText: "这篇文章介绍了",
          userIcon: "https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp",
          userMode: "magic",
          defaultChatQuestions: ["你好","你是谁"],
          defaultSearchQuestions: ["视频压缩","设计"]
        };
    </script>
    <script data-postchat_key="S-TY6LYYCZMYV6UADE" src="https://ai.tianli0.top/static/public/postChatUser_summary.min.js"></script>
  </body></html>