<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>（译）Forward vs Deferred vs Forward+ Rendering with DirectX 11 | 登峰造极者，殊途亦同归。</title><meta name="author" content="烟雨迷离半世殇"><meta name="copyright" content="烟雨迷离半世殇"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在网上鲜少有能全面，具体对比Forward,Deferred,Forward+渲染管线的文章，所以抽空翻译下，分享出来 原文地址：https://www.3dgep.com/forward-plus/ In this article, I will analyze and compare three rendering algorithms: 在本文中，我将分析并比较三种渲染算法：  Forwar">
<meta property="og:type" content="article">
<meta property="og:title" content="（译）Forward vs Deferred vs Forward+ Rendering with DirectX 11">
<meta property="og:url" content="https://www.lfzxb.top/forward-vs-deferred-vs-forward-plus/index.html">
<meta property="og:site_name" content="登峰造极者，殊途亦同归。">
<meta property="og:description" content="在网上鲜少有能全面，具体对比Forward,Deferred,Forward+渲染管线的文章，所以抽空翻译下，分享出来 原文地址：https://www.3dgep.com/forward-plus/ In this article, I will analyze and compare three rendering algorithms: 在本文中，我将分析并比较三种渲染算法：  Forwar">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172106940.jpeg!webp">
<meta property="article:published_time" content="2024-05-17T00:00:00.000Z">
<meta property="article:modified_time" content="2025-02-27T00:00:00.000Z">
<meta property="article:author" content="烟雨迷离半世殇">
<meta property="article:tag" content="Defered Render">
<meta property="article:tag" content="Forward Plus Render">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172106940.jpeg!webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "（译）Forward vs Deferred vs Forward+ Rendering with DirectX 11",
  "url": "https://www.lfzxb.top/forward-vs-deferred-vs-forward-plus/",
  "image": "https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172106940.jpeg!webp",
  "datePublished": "2024-05-17T00:00:00.000Z",
  "dateModified": "2025-02-27T00:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "烟雨迷离半世殇",
      "url": "https://www.lfzxb.top/www.lfzxb.top"
    }
  ]
}</script><link rel="shortcut icon" href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp"><link rel="canonical" href="https://www.lfzxb.top/forward-vs-deferred-vs-forward-plus/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="google-site-verification" content="AhlEJ91V_L12bkwRF1ZS0BbytGCfsjqCX4GXztUluC8"><meta name="baidu-site-verification" content="iRRtEBalDiujISsN"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const hour = new Date().getHours()
          const isNight = hour <= 6 || hour >= 8
          if (theme === undefined) isNight ? activateDarkMode() : activateLightMode()
          else theme === 'light' ? activateLightMode() : activateDarkMode()
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-7235595771604497',
  enable_page_level_ads: 'true'
});</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-XSL6D8K8G2"></script><script>window.dataLayer = window.dataLayer || []
function gtag(){dataLayer.push(arguments)}
gtag('js', new Date())
gtag('config', 'G-XSL6D8K8G2')
btf.addGlobalFn('pjaxComplete', () => {
  gtag('config', 'G-XSL6D8K8G2', {'page_path': window.location.pathname})
}, 'google_analytics')
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":false,"highlightHeightLimit":800,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '（译）Forward vs Deferred vs Forward+ Rendering with DirectX 11',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/CustomIcons/iconfontformaliyun.css"><meta name="referrer" content="no-referrer-when-downgrade"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar" loading='lazy'></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">246</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">188</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">56</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-torii-gate"></i><span> 蓬莱仙境</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-stream"></i><span> 白驹过隙</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 包罗万象</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分朋引类</span></a></div><div class="menus_item"><a class="site-page" href="/self/"><i class="fa-fw fas fa-id-card"></i><span> 择交而友</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 一见如故</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172106940.jpeg!webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/202507052331881.png!webp" alt="Logo" loading='lazy'></a><a class="nav-page-title" href="/"><span class="site-name">（译）Forward vs Deferred vs Forward+ Rendering with DirectX 11</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-torii-gate"></i><span> 蓬莱仙境</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-stream"></i><span> 白驹过隙</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 包罗万象</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分朋引类</span></a></div><div class="menus_item"><a class="site-page" href="/self/"><i class="fa-fw fas fa-id-card"></i><span> 择交而友</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 一见如故</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">（译）Forward vs Deferred vs Forward+ Rendering with DirectX 11</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-05-17T00:00:00.000Z" title="发表于 2024-05-17 00:00:00">2024-05-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-02-27T00:00:00.000Z" title="更新于 2025-02-27 00:00:00">2025-02-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93/">图形渲染</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%9B%BE%E5%BD%A2%E6%B8%B2%E6%9F%93/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">基础知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">36.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>130分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/forward-vs-deferred-vs-forward-plus/#post-comment"><span class="gitalk-comment-count"><i class="fa-solid fa-spinner fa-spin"></i></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;这篇文章已经&quot;,&quot;messageNext&quot;:&quot;天没维护了，相关内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2025-02-27 00:00:00&quot;}" hidden=""></div><div id="postchat_postcontent"><p>在网上鲜少有能全面，具体对比Forward,Deferred,Forward+渲染管线的文章，所以抽空翻译下，分享出来</p>
<p>原文地址：<a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/">https://www.3dgep.com/forward-plus/</a></p>
<p>In this article, I will analyze and compare three rendering algorithms:<br>
在本文中，我将分析并比较三种渲染算法：</p>
<ol>
<li>Forward Rendering&nbsp;Forward 渲染</li>
<li>Deferred Shading&nbsp;延迟着色</li>
<li>Forward+ (Tiled Forward Rendering)<br>
Forward+（平铺前向渲染）</li>
</ol>
<p>Contents</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Introduction">1 Introduction&nbsp;1 介绍</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Definitions">1.1 Definitions&nbsp;1.1 定义</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Forward_Rendering">2 Forward Rendering&nbsp;2 前向渲染</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Vertex_Shader">2.1 Vertex Shader&nbsp;2.1 顶点着色器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Pixel_Shader">2.2 Pixel Shader&nbsp;2.2 像素着色器</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Material">2.2.1 Material&nbsp;2.2.1 材质</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Textures">2.2.2 Textures&nbsp;2.2.2 纹理</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Lights">2.2.3 Lights&nbsp;2.2.3 灯光</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Pixel_Shader_Continued">2.3 Pixel Shader Continued<br>
2.3 像素着色器继续</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Materials">2.3.1 Materials&nbsp;2.3.1 材质</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Diffuse">2.3.1.1 Diffuse&nbsp;2.3.1.1 漫反射</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Opacity">2.3.1.2 Opacity&nbsp;2.3.1.2 不透明度</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Ambient_and_Emissive">2.3.1.3 Ambient and Emissive<br>
2.3.1.3 环境和自发光</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Specular_Power">2.3.1.4 Specular Power&nbsp;2.3.1.4 镜面率</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Normals">2.3.1.5 Normals&nbsp;2.3.1.5 法线</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Normal_Mapping">2.3.1.6 Normal Mapping&nbsp;2.3.1.6 法线贴图</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Bump_Mapping">2.3.1.7 Bump Mapping&nbsp;2.3.1.7 凹凸贴图</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Lighting">2.3.2 Lighting&nbsp;2.3.2 灯光</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Diffuse_Lighting">2.3.2.1 Diffuse Lighting&nbsp;2.3.2.1 漫反射光</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Specular_Lighting">2.3.2.2 Specular Lighting<br>
2.3.2.2 镜面光照</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Attenuation">2.3.2.3 Attenuation&nbsp;2.3.2.3 衰减</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Point_Lights">2.3.2.4 Point Lights&nbsp;2.3.2.4 点光源</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Spot_Lights">2.3.2.5 Spot Lights&nbsp;2.3.2.5 聚光灯</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Directional_Lights">2.3.2.6 Directional Lights<br>
2.3.2.6 定向灯</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Final_Shading">2.3.3 Final Shading&nbsp;2.3.3 最终着色</a></li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Deferred_Shading">3 Deferred Shading&nbsp;3 延迟着色</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#G-Buffer_Pass">3.1 G-Buffer Pass&nbsp;3.1 G-缓冲区pass</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#G-Buffer_Layout">3.1.1 G-Buffer Layout&nbsp;3.1.1 G-缓冲区布局</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#DepthStencil_Buffer">3.1.1.1 Depth/Stencil Buffer<br>
3.1.1.1 深度/模板缓冲区</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Light_Accumulation_Buffer">3.1.1.2 Light Accumulation Buffer<br>
3.1.1.2 光积累缓冲区</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Diffuse_Buffer">3.1.1.3 Diffuse Buffer&nbsp;3.1.1.3 漫反射缓冲区</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Specular_Buffer">3.1.1.4 Specular Buffer&nbsp;3.1.1.4 镜面缓冲区</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Normal_Buffer">3.1.1.5 Normal Buffer&nbsp;3.1.1.5 法线缓冲区</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Layout_Summary">3.1.1.6 Layout Summary&nbsp;3.1.1.6 布局摘要</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Pixel_Shader-2">3.1.2 Pixel Shader&nbsp;3.1.2 像素着色器</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Lighting_Pass_Guerrilla">3.2 Lighting Pass (Guerrilla)<br>
3.2 灯光pass（游击队）</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Determine_Lit_Pixels">3.2.1 Determine Lit Pixels<br>
3.2.1 确定照亮的像素</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Mark_Pixels">3.2.1.1 Mark Pixels&nbsp;3.2.1.1 标记像素</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Count_Pixels">3.2.1.2 Count Pixels&nbsp;3.2.1.2 计算像素</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Shade_Pixels">3.2.2 Shade Pixels&nbsp;3.2.2 着色像素</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Lighting_Pass_My_Implementation">3.3 Lighting Pass (My Implementation)<br>
3.3 灯光pass（我的实现）</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Unmark_Pixels">3.3.1 Unmark Pixels&nbsp;3.3.1 取消标记像素</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Shade_Pixels-2">3.3.2 Shade Pixels&nbsp;3.3.2 着色像素</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Pixel_Shader-3">3.3.3 Pixel Shader&nbsp;3.3.3 像素着色器</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Transparent_Pass">3.4 Transparent Pass&nbsp;3.4 透明pass</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Forward">4 Forward+&nbsp;4 Foward+</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Grid_Frustums">4.1 Grid Frustums&nbsp;4.1 网格视锥体</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Grid_Frustums_Compute_Shader">4.2 Grid Frustums Compute Shader<br>
4.2 网格视锥体计算着色器</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Tile_Corners_in_Screen_Space">4.2.1 Tile Corners in Screen Space<br>
4.2.1 屏幕空间中的瓦片角点</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Tile_Corners_in_View_Space">4.2.2 Tile Corners in View Space<br>
在视图空间中放置瓦片角</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Compute_Frustum_Planes">4.2.3 Compute Frustum Planes<br>
计算视锥体平面</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Store_Grid_Frustums">4.2.4 Store Grid Frustums<br>
存储网格视锥体</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Light_Culling">4.3 Light Culling&nbsp;4.3 光照剔除</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Compute_MinMax_Depth_Values">4.3.1 Compute Min/Max Depth Values<br>
4.3.1 计算最小/最大深度值</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Light_List_Data_Structure">4.3.2 Light List Data Structure<br>
4.3.2 光列表数据结构</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Frustum_Culling">4.4 Frustum Culling&nbsp;4.4 视锥体剔除</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Frustum-Sphere_Culling">4.4.1 Frustum-Sphere Culling<br>
4.4.1 视锥体-球体剔除</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Frustum-Cone_Culling">4.4.2 Frustum-Cone Culling<br>
4.4.2 视锥体-圆锥剔除</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Light_Culling_Compute_Shader">4.5 Light Culling Compute Shader<br>
4.5 光照剔除计算着色器</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Final_Shading-2">4.6 Final Shading&nbsp;4.6 最终着色</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Experiment_Setup_and_Performance_Results">5 Experiment Setup and Performance Results<br>
5 实验设置和性能结果</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Forward_Rendering_Performance">5.1 Forward Rendering Performance<br>
5.1 正向渲染性能</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Large_Lights">5.1.1 Large Lights&nbsp;5.1.1 大灯光</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Small_Lights">5.1.2 Small Lights&nbsp;5.1.2 小灯光</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Deferred_Rendering_Performance">5.2 Deferred Rendering Performance<br>
5.2 延迟渲染性能</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Large_Lights-2">5.2.1 Large Lights&nbsp;5.2.1 大灯光</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Small_Lights-2">5.2.2 Small Lights&nbsp;5.2.2 小灯光</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Forward_Plus_Performance">5.3 Forward Plus Performance<br>
5.3 前进加性能</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Large_Lights-3">5.3.1 Large Lights&nbsp;5.3.1 大灯</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Small_Lights-3">5.3.2 Small Lights&nbsp;5.3.2 小灯</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Techniques_Compared">5.4 Techniques Compared&nbsp;5.4 方式比较</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Large_Lights-4">5.4.1 Large Lights&nbsp;5.4.1 大灯</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Small_Lights-4">5.4.2 Small Lights&nbsp;5.4.2 小灯</a></li>
</ul>
</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Future_Considerations">6 Future Considerations&nbsp;6 未来考虑</a>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#General_Considerations">6.1 General Considerations<br>
6.1 一般考虑</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Forward_Rendering-2">6.2 Forward Rendering&nbsp;6.2 前向渲染</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Deferred_Rendering">6.3 Deferred Rendering&nbsp;6.3 延迟渲染</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Tiled_Forward_Rendering">6.4 Tiled Forward Rendering<br>
6.4 平铺前向渲染</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Conclusion">7 Conclusion&nbsp;7 结论</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#Download_the_Demo">8 Download the Demo&nbsp;下载演示</a></li>
<li><a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#References">9 References&nbsp;参考资料</a></li>
</ul>
<h1>Introduction&nbsp;介绍</h1>
<p>前向渲染通过对场景中的每个几何对象进行光栅化来工作。在着色过程中，会迭代场景中的光源列表，以确定如何照亮几何对象。这意味着每个几何对象都必须考虑场景中的每个光源。当然，我们可以通过丢弃被遮挡或不出现在相机视锥体中的几何对象来优化这一过程。我们可以通过丢弃不在相机视锥体内的光源进一步优化这一方式。如果光源的范围已知，那么我们可以在渲染场景几何之前对光体积执行视锥体裁剪。对象裁剪和光体积裁剪为这一方式提供了有限的优化，而在使用前向渲染管线时通常不会实践光裁剪。更常见的做法是简单地限制可以影响场景对象的光源数量。例如，一些图形引擎将对最接近的两三个光源执行每像素光照，并对接下来最接近的三四个光源执行每顶点光照。 在 OpenGL 和 DirectX 提供的传统固定功能渲染管线中，场景中任何时候活动的动态光源数量被限制在大约八个左右。即使使用现代图形硬件，前向渲染管线在出现明显帧率问题之前仅限于大约 100 个动态场景光源。</p>
<p>延迟着色则通过将场景中的所有对象（不带光照）光栅化到一系列 2D 图像缓冲区中，这些缓冲区存储了执行后续光照计算所需的几何信息。存储在 2D 图像缓冲区中的信息包括：</p>
<ul>
<li>screen space depth&nbsp;屏幕空间深度</li>
<li>surface normals&nbsp;表面法线</li>
<li>diffuse color&nbsp;漫反射颜色</li>
<li>specular color and specular power<br>
镜面颜色和镜面率</li>
</ul>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405162220297.jpeg" alt="The textures that compose the G-Buffer. Diffuse (top-left), Specular (top-right), Normals (bottom-left), and Depth (bottom-right). The specular power is stored in the alpha channel of the specular texture (top-right).组成 G-Buffer的纹理。漫反射（左上角），镜面反射（右上角），法线（左下角）和深度（右下角）。镜面反射强度存储在镜面反射纹理的 alpha pass中（右上角）。" loading='lazy'></p>
<p>这些 2D 图像缓冲区的组合被称为几何缓冲区（或 G-Buffer）[1]。</p>
<p>如果需要进行后续的光照计算，其他信息也可以存储到图像缓冲区中，但每个 G-Buffer纹理在全高清（1080p）和每像素 32 位的情况下至少需要 8.29 MB 的纹理内存。</p>
<p>生成 G-Buffer后，几何信息可以用来在光照pass中计算光照信息。光照pass通过将每个光源渲染为场景中的几何对象来执行。每个被光源几何表示触及的像素都使用所需的光照方程进行着色。</p>
<p>与前向渲染相比，延迟着色方式的明显优势在于昂贵的光照计算仅针对每个受光源覆盖的像素计算一次。使用现代硬件，延迟着色方式可以处理约 2500 个动态场景光源，分辨率为全高清（1080p），在仅渲染不透明场景对象时才会出现帧率问题。</p>
<p>使用延迟着色的一个缺点是只有不透明物体可以被光栅化到 G-Buffer中。原因<code>在于多个透明物体可能覆盖相同的屏幕像素，但在 G-Buffer中每个像素只能存储单个值</code>。在光照pass中，为正在照亮的当前屏幕像素采样深度值、表面法线、漫反射和镜面颜色。由于只从每个 G-Buffer中采样单个值，透明物体无法在光照pass中受到支持。为了规避这个问题，透明几何体必须使用标准的前向渲染方式进行渲染，这限制了场景中透明几何体的数量或场景中动态光源的数量。一个只包含不透明物体的场景在出现帧速率问题之前可以处理大约 2000 个动态光源。</p>
<p>延迟着色的另一个缺点是在光照pass中只能模拟单个光照模型。这是因为在渲染光几何体时只能绑定单个像素着色器。对于使用超级着色器的流水线来说，使用单个像素着色器进行渲染是正常的，通常不是问题，但是如果您的渲染流水线利用各种像素着色器实现了几种不同的光照模型，那么将渲染流水线切换到使用延迟着色将会成为一个问题。</p>
<p>Forward+（也称为平铺前向着色）是一种渲染方式，它将前向渲染与平铺光照剔除相结合，以减少在着色过程中必须考虑的光源数量。Forward+主要包括两个阶段：</p>
<ol>
<li>Light culling&nbsp;光照剔除</li>
<li>Forward rendering&nbsp;前向渲染</li>
</ol>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405162222475.jpeg" alt="Forward+ Lighting. Default Lighting (left), Light heatmap (right). The colors in the heatmap indicate how many lights are affecting the tile. Black tiles contain no lights while blue tiles contain between 1-10 lights. The green tiles contain 20-30 lights.Forward+默认光照（左），光热图（右）。热图中的颜色表示有多少灯光影响了瓦片。黑色瓦片不包含灯光，而蓝色瓦片包含 1-10 盏灯光。绿色瓦片包含 20-30 盏灯光。" loading='lazy'></p>
<p>Forward+渲染方式的第一遍使用屏幕空间中的均匀网格划分灯光为每个瓦片列表。</p>
<p>第二遍使用标准的前向渲染传递来着色场景中的物体，但是不是遍历场景中的每个动态光源，而是使用当前像素的屏幕空间位置来查找在前一遍计算的网格中的灯光列表。光源剔除大大提高了性能，因为它大大减少了必须迭代的冗余光源数量，以正确照亮像素。不透明和透明几何体可以以类似的方式处理，而不会显著降低性能，并且使用 Forward+本地支持处理多种材质和光照模型。</p>
<p>由于 Forward+将标准的前向渲染管线纳入其方式中，因此 Forward+可以集成到最初使用前向渲染构建的现有图形引擎中。Forward+不使用 G-Buffer，也不受延迟着色的限制。透明和不透明几何体均可使用 Forward+进行渲染。在现代图形硬件的支持下，一个由 5,000 至 6,000 个动态光源组成的场景可以以全高清分辨率（1080p）实时渲染。</p>
<p>在本文的其余部分，我将描述这三种方式的实现：</p>
<ol>
<li>Forward Rendering&nbsp;Forward 渲染</li>
<li>Deferred Shading&nbsp;延迟着色</li>
<li>Forward+ (Tiled Forward Rendering)<br>
Forward+（平铺前向渲染）</li>
</ol>
<p>我还将展示在各种情况下的性能统计数据，以确定在哪些条件下一种方式的表现优于其他方式。</p>
<h1>Definitions&nbsp;定义</h1>
<p>在本文的背景下，重要的是定义一些术语，以便更容易理解文章的其余部分。如果您熟悉图形编程中使用的基本术语，可以跳过本节。</p>
<p>场景是指可以呈现的对象的嵌套层次结构。例如，所有可以呈现的静态对象将被分组到一个场景中。每个单独的可渲染对象在场景中使用场景节点进行引用。每个场景节点引用一个单个的可渲染对象（如网格），整个场景可以使用场景的顶级节点——根节点进行引用。场景中场景节点的连接也称为场景图。由于根节点也是一个场景节点，因此可以嵌套场景以创建具有静态和动态对象的更复杂的场景图。</p>
<p>一个pass是指执行渲染方式的一个步骤的单个操作。例如，不透明pass是一个遍历场景中所有对象并仅渲染不透明对象的pass。透明pass也会遍历场景中的所有对象，但仅渲染透明对象。pass也可以用于更一般的操作，比如复制 GPU 资源或dispatch compute shader。</p>
<p>方式是必须按特定顺序执行的几个步骤的组合，以实现渲染算法。</p>
<p>管线状态是指在对象渲染之前渲染管线的配置。管线状态对象封装了以下渲染状态：</p>
<ul>
<li>Shaders (vertex, tessellation, geometry, and pixel)<br>
着色器（顶点、镶嵌、几何和像素）</li>
<li>Rasterizer state (polygon fill mode, culling mode, scissor culling, viewports)<br>
光栅化器状态（多边形填充模式、剔除模式、剪裁剔除、视口）</li>
<li>Blend state&nbsp;混合状态</li>
<li>Depth/Stencil state&nbsp;深度/模板状态</li>
<li>Render target&nbsp;渲染目标</li>
</ul>
<p>DirectX 12 引入了管线状态对象，但我的管线状态定义与 DirectX 12 的定义略有不同。</p>
<h2 id="Forward-rendering">Forward rendering</h2>
<p>正向渲染是一种传统上只有两个pass的渲染方式：</p>
<ol>
<li>Opaque Pass&nbsp;不透明pass</li>
<li>Transparent Pass&nbsp;透明pass</li>
</ol>
<p>不透明pass将使场景中的所有不透明对象理想地按照从前到后（相对于摄像机）排序，以最小化过度绘制。在不透明pass期间，无需执行混合。</p>
<p>透明pass将使场景中的所有透明对象理想地按照从后到前（相对于摄像机）排序，以支持正确的混合。在透明pass期间，需要启用 alpha 混合，以便半透明材质能够与已经渲染到渲染目标颜色缓冲区的像素正确混合。</p>
<p>在正向渲染期间，所有光照都在像素着色器中执行，同时执行所有其他材质着色指令。</p>
<p>伪代码如下</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> light in lights:</span><br><span class="line">	<span class="keyword">for</span> mesh in opaqueMeshes:</span><br><span class="line">		draw(mesh, light)</span><br><span class="line">	<span class="keyword">for</span> mesh in transparentMeshes:</span><br><span class="line">		draw(mesh, light)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Deferred-shading">Deferred shading</h2>
<p>延迟着色是一种渲染方式，由三个主要pass组成：</p>
<ol>
<li>Geometry Pass&nbsp;几何pass</li>
<li>Lighting Pass&nbsp;灯光pass</li>
<li>Transparent Pass&nbsp;透明pass</li>
</ol>
<p>第一个pass是几何pass，类似于前向渲染方式中的不透明pass，因为在这个pass中只渲染不透明物体。不同之处在于几何pass不执行任何光照计算，而只将几何和材质数据输出到在介绍中描述的 G-Buffer。</p>
<p>在光照pass中，代表光源的几何体积被渲染到场景中，并且使用存储在 G-Buffer中的材质信息来计算光照以用于光栅化像素。</p>
<p>最终pass是透明pass。该pass与正向渲染方式的透明pass相同。由于延迟着色不支持透明材质，透明物体必须在单独的pass中渲染，该pass使用标准的正向渲染方法进行光照。</p>
<figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> mesh in meshes:</span><br><span class="line">	drawToGBuffer(mesh)</span><br><span class="line"><span class="keyword">for</span> light in lights:</span><br><span class="line">	drawToFramebuffer(light)</span><br><span class="line"><span class="keyword">for</span> light in lights:</span><br><span class="line">	<span class="keyword">for</span> mesh in transparentMeshes:</span><br><span class="line">		draw(mesh, light)</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Forward">Forward+</h2>
<p>Forward+（也称为平铺正向渲染）是一种渲染方式，由三个主要pass组成：</p>
<ol>
<li>Light Culling Pass&nbsp;光照剔除pass</li>
<li>Opaque Pass&nbsp;不透明pass</li>
<li>Transparent Pass&nbsp;透明pass</li>
</ol>
<p>正如在介绍中提到的，光照剔除pass负责将场景中的动态光源排序到屏幕空间的瓦片中。一个光源索引列表用于指示哪些光源索引（来自全局光源列表）与每个屏幕瓦片重叠。在光照剔除pass中，将生成两组光源索引列表：</p>
<ol>
<li>Opaque light index list<br>
不透明光索引列表</li>
<li>Transparent light index list<br>
透明光索引列表</li>
</ol>
<p>在渲染不透明几何体时使用不透明光索引列表，在渲染透明几何体时使用透明光索引列表。</p>
<p>Forward+渲染方式的不透明和透明pass与标准前向渲染方式相同，但不是遍历场景中的所有动态光源，而是只需考虑当前片元屏幕空间瓦片中的光源。</p>
<h2 id="Light">Light</h2>
<p>光指以下类型的光之一：</p>
<ul>
<li>Point light&nbsp;点光源</li>
<li>Spot light&nbsp;聚光灯</li>
<li>Directional light&nbsp;定向光</li>
</ul>
<p>本文中描述的所有渲染方式都支持这三种光源类型。区域光不受支持。点光源和聚光灯被模拟为从单个起源点发出，而方向光被认为是从远处无限发光，朝着同一方向到处发光。点光源和聚光灯在超出一定范围后，其强度会衰减至零。光强度的衰减称为衰减。点光源在几何上被表示为球体，聚光灯为圆锥体，方向光为全屏四边形。</p>
<p>让我们首先更详细地看一下标准的前向渲染方式。</p>
<p>前向渲染是三种光照方式中最简单、在游戏中渲染图形最常用的方式。它也是计算光照最昂贵的方式，因此不允许在场景中使用大量动态光源。</p>
<p>大多数使用前向渲染的图形引擎会利用各种方式来模拟场景中的许多光源。例如，光照贴图和光探针是用于预先计算场景中静态光源的光照贡献并将这些光照贡献存储在纹理中，在运行时加载的方法。不幸的是，光照贴图和光探针无法用于模拟场景中的动态光源，因为用于生成光照贴图的光源通常在运行时被丢弃。</p>
<p>对于这个实验，前向渲染被用作比较其他两种渲染方式的基准。前向渲染方式还被用来建立一个性能基准，可以用来比较其他渲染方式的性能。</p>
<p>前向渲染方式的许多功能在延迟渲染和Foward+渲染方式中得到重复利用。例如，前向渲染中使用的顶点着色器也用于延迟着色和Foward+渲染。同时，计算最终光照和材质着色的方法在所有渲染方式中得到重复利用。</p>
<p>在下一节中，我将描述前向渲染方式的实现。</p>
<h1>Foward渲染实现</h1>
<h2 id="Vertex-Shader-顶点着色器">Vertex Shader&nbsp;顶点着色器</h2>
<p>顶点着色器适用于所有渲染方式。在这个实验中，仅支持静态几何体，没有需要不同顶点着色器的骨骼动画或地形。顶点着色器尽可能简单，同时支持像法线贴图这样的像素着色器所需的功能。</p>
<p>在展示顶点着色器代码之前，我将描述顶点着色器使用的数据结构。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AppData</span></span><br><span class="line">{</span><br><span class="line">    float3 position : POSITION;</span><br><span class="line">    float3 tangent  : TANGENT;</span><br><span class="line">    float3 binormal : BINORMAL;</span><br><span class="line">    float3 normal   : NORMAL;</span><br><span class="line">    float2 texCoord : TEXCOORD0;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>AppData 结构定义了应用程序代码预期发送的数据（有关如何将数据从应用程序传递到顶点着色器的教程，请参阅我的上一篇文章，标题为<a target="_blank" rel="noopener" href="https://www.3dgep.com/introduction-to-directx-11/">《DirectX 11 入门》</a>）。对于法线贴图，除了法线向量外，我们还需要发送切线向量，以及可选的副法线（或双切线）向量。切线和副法线向量可以由 3D 艺术家在创建模型时创建，也可以由模型导入器生成。在我的情况下，如果 3D 艺术家尚未创建切线和副切线，我依赖于 Open Asset Import Library [7] 来生成切线和副切线。</p>
<p>在顶点着色器中，我们还需要知道如何将应用程序发送的对象空间向量转换为像素着色器所需的视图空间。为此，我们需要将世界、视图和投影矩阵发送到顶点着色器（有关本文中使用的各种空间的回顾，请参阅我的上一篇文章，标题为<a target="_blank" rel="noopener" href="https://www.3dgep.com/3d-math-primer-for-game-programmers/">坐标系</a>）。为了存储这些矩阵，我将创建一个常量缓冲区，用于存储顶点着色器所需的每个对象变量。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cbuffer PerObject : <span class="built_in">register</span>( b0 )</span><br><span class="line">{</span><br><span class="line">    float4x4 ModelViewProjection;</span><br><span class="line">    float4x4 ModelView;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于我不需要单独存储世界矩阵，我在应用程序中预先计算了组合的模型、视图和组合的模型、视图和投影矩阵，并将这些矩阵一起发送到顶点着色器中的单个常量缓冲区。</p>
<p>顶点着色器的输出（因此也是像素着色器的输入）如下所示：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">VertexShaderOutput</span></span><br><span class="line">{</span><br><span class="line">    float3 positionVS   : TEXCOORD0;    <span class="comment">// View space position.</span></span><br><span class="line">    float2 texCoord     : TEXCOORD1;    <span class="comment">// Texture coordinate</span></span><br><span class="line">    float3 tangentVS    : TANGENT;      <span class="comment">// View space tangent.</span></span><br><span class="line">    float3 binormalVS   : BINORMAL;     <span class="comment">// View space binormal.</span></span><br><span class="line">    float3 normalVS     : NORMAL;       <span class="comment">// View space normal.</span></span><br><span class="line">    float4 position     : SV_POSITION;  <span class="comment">// Clip space position.</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>VertexShaderOutput 结构用于将转换后的顶点属性传递给像素着色器。以 VS 后缀命名的成员表示该向量是以视图空间表示的。我选择在视图空间中进行所有光照计算，而不是在世界空间中，因为在实现延迟着色和Foward+渲染方式时，使用视图空间坐标更容易。</p>
<p>顶点着色器非常简单和最小。它的唯一目的是将应用程序传递的对象空间向量转换为视图空间，以供像素着色器使用。</p>
<p>顶点着色器还必须计算由光栅化器使用的裁剪空间位置。SV_POSITION 语义被应用于顶点着色器的输出值，以指定该值用作裁剪空间位置，但此语义也可以应用于像素着色器的输入变量。当 SV_POSITION 用作像素着色器的输入语义时，该值是屏幕空间中像素的位置[8]。在延迟着色和Foward+着色器中，我将使用此语义来获取当前像素的屏幕空间位置。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VertexShaderOutput <span class="title">VS_main</span><span class="params">( AppData IN )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    VertexShaderOutput OUT;</span><br><span class="line"></span><br><span class="line">    OUT.position = <span class="built_in">mul</span>( ModelViewProjection, <span class="built_in">float4</span>( IN.position, <span class="number">1.0f</span> ) );</span><br><span class="line"></span><br><span class="line">    OUT.positionVS = <span class="built_in">mul</span>( ModelView, <span class="built_in">float4</span>( IN.position, <span class="number">1.0f</span> ) ).xyz;</span><br><span class="line">    OUT.tangentVS = <span class="built_in">mul</span>( ( float3x3 )ModelView, IN.tangent );</span><br><span class="line">    OUT.binormalVS = <span class="built_in">mul</span>( ( float3x3 )ModelView, IN.binormal );</span><br><span class="line">    OUT.normalVS = <span class="built_in">mul</span>( ( float3x3 )ModelView, IN.normal );</span><br><span class="line"></span><br><span class="line">    OUT.texCoord = IN.texCoord;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OUT;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>您会注意到我正在将输入向量与矩阵进行预乘。这表明默认情况下矩阵是按列主序存储的。在 DirectX 10 之前，HLSL 中的矩阵是按行主序加载的，输入向量是由矩阵后乘的。自 DirectX 10 以来，默认情况下矩阵是按列主序加载的。您可以通过在矩阵变量声明中指定 row_major 类型修饰符来更改默认顺序。</p>
<h2 id="Pixel-Shader-像素着色器">Pixel Shader&nbsp;像素着色器</h2>
<p>像素着色器将计算用于确定单个屏幕像素最终颜色的所有光照和阴影。此像素着色器中使用的光照方程式在之前的一篇文章中描述，标题为“<a target="_blank" rel="noopener" href="https://www.3dgep.com/texturing-lighting-directx-11/">DirectX 11 中的纹理和光照</a>”，如果您对光照模型不熟悉，则应该先阅读该文章，然后再继续。</p>
<p>像素着色器使用几个结构来完成其工作。Material 结构存储描述被着色对象的表面材质的所有信息，Light 结构包含描述放置在场景中的光源所需的所有参数。</p>
<h3 id="Material-材质">Material&nbsp;材质</h3>
<p>Material 结构定义了描述当前被着色对象表面所需的所有属性。由于一些材质属性也可以有关联的纹理（例如，漫反射纹理、镜面反射纹理或法线纹理），我们还将使用材质来指示这些纹理是否存在于对象上。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Material</span></span><br><span class="line">{</span><br><span class="line">    float4  GlobalAmbient;</span><br><span class="line">    <span class="comment">//-------------------------- ( 16 bytes )</span></span><br><span class="line">    float4  AmbientColor;</span><br><span class="line">    <span class="comment">//-------------------------- ( 16 bytes )</span></span><br><span class="line">    float4  EmissiveColor;</span><br><span class="line">    <span class="comment">//-------------------------- ( 16 bytes )</span></span><br><span class="line">    float4  DiffuseColor;</span><br><span class="line">    <span class="comment">//-------------------------- ( 16 bytes )</span></span><br><span class="line">    float4  SpecularColor;</span><br><span class="line">    <span class="comment">//-------------------------- ( 16 bytes )</span></span><br><span class="line">    <span class="comment">// Reflective value.</span></span><br><span class="line">    float4  Reflectance;</span><br><span class="line">    <span class="comment">//-------------------------- ( 16 bytes )</span></span><br><span class="line">    <span class="type">float</span>   Opacity;</span><br><span class="line">    <span class="type">float</span>   SpecularPower;</span><br><span class="line">    <span class="comment">// For transparent materials, IOR &gt; 0.</span></span><br><span class="line">    <span class="type">float</span>   IndexOfRefraction;</span><br><span class="line">    <span class="type">bool</span>    HasAmbientTexture;</span><br><span class="line">    <span class="comment">//-------------------------- ( 16 bytes )</span></span><br><span class="line">    <span class="type">bool</span>    HasEmissiveTexture;</span><br><span class="line">    <span class="type">bool</span>    HasDiffuseTexture;</span><br><span class="line">    <span class="type">bool</span>    HasSpecularTexture;</span><br><span class="line">    <span class="type">bool</span>    HasSpecularPowerTexture;</span><br><span class="line">    <span class="comment">//-------------------------- ( 16 bytes )</span></span><br><span class="line">    <span class="type">bool</span>    HasNormalTexture;</span><br><span class="line">    <span class="type">bool</span>    HasBumpTexture;</span><br><span class="line">    <span class="type">bool</span>    HasOpacityTexture;</span><br><span class="line">    <span class="type">float</span>   BumpIntensity;</span><br><span class="line">    <span class="comment">//-------------------------- ( 16 bytes )</span></span><br><span class="line">    <span class="type">float</span>   SpecularScale;</span><br><span class="line">    <span class="type">float</span>   AlphaThreshold;</span><br><span class="line">    float2  Padding;</span><br><span class="line">    <span class="comment">//--------------------------- ( 16 bytes )</span></span><br><span class="line">};  <span class="comment">//--------------------------- ( 16 * 10 = 160 bytes )</span></span><br></pre></td></tr></tbody></table></figure>
<p>GlobalAmbient 术语用于描述应用于场景中所有对象的环境贡献。从方式上讲，这个变量应该是一个全局变量（而不是特定于单个对象），但由于像素着色器中一次只有一个材质，我觉得这是一个合适的放置位置。<br>
环境光、自发光、漫反射和镜面颜色值的含义与我之前的文章<a target="_blank" rel="noopener" href="https://www.3dgep.com/texturing-lighting-directx-11/#Materials_Properties">《DirectX 11 中的纹理和光照》</a>中相同，因此我不会在这里详细解释它们。</p>
<p>反射分量可用于指示应与漫反射颜色混合的反射颜色量。这将需要实现环境贴图，而我在这个实验中没有这样做，因此此值在此处未使用。</p>
<p>不透明度值用于确定物体的总不透明度。此值可用于使物体呈现为透明。此属性用于在透明pass中渲染半透明物体。如果不透明度值小于 1（1 表示完全不透明，0 表示完全透明），则该物体将被视为透明，并将在透明pass中渲染，而不是在不透明pass中。</p>
<p>SpecularPower 变量用于确定物体看起来有多闪亮。Specular power 在我的上一篇文章中有描述，标题为 DirectX 11 中的纹理和光照，所以我这里不会重复。</p>
<p>IndexOfRefraction 变量可应用于应该通过它们折射光线的物体。由于折射需要环境贴图方式，而这些方式在此实验中未实现，因此此变量将不会在此处使用。</p>
<p>HasTexture 变量在第 29-38 行定义，指示正在渲染的物体是否具有相关纹理。如果参数为 true，则将对应的纹理进行采样，并将 texel 与对应的材质颜色值混合。</p>
<p>BumpIntensity 变量用于缩放凸起贴图的高度值（不要与不需要缩放的法线贴图混淆），以软化或突出物体表面的凹凸感。在大多数情况下，模型将使用法线贴图为物体表面添加细节，而无需高细分，但也可以使用高度图来实现相同的效果。如果模型具有凸起贴图，则材质的 HasBumpTexture 属性将设置为 true，在这种情况下，模型将进行凸起贴图而不是法线贴图。</p>
<p>SpecularScale 变量用于缩放从镜面率纹理中读取的镜面率值。由于纹理通常将值存储为无符号归一化值，因此从纹理采样时，该值将作为浮点值读取，范围为[0…1]。镜面率为 1.0 并没有太多意义（正如我之前的文章《DirectX 11 中的纹理和光照》中所解释的那样），因此在用于最终光照计算之前，将从纹理中读取的镜面率值乘以 SpecularScale 进行缩放。</p>
<p>AlphaThreshold 变量可用于使用像素着色器中的“丢弃”命令丢弃不透明度低于某个值的像素。这可用于“切割”材质，其中对象不需要进行 alpha 混合，但对象应该有孔洞（例如，链环围栏）。</p>
<p>Padding 变量用于显式地向材质结构体添加八个字节的填充。虽然 HLSL 会隐式地向该结构体添加此填充，以确保结构体的大小是 16 字节的倍数，但显式添加填充可以清楚地表明该结构体的大小和对齐方式与其 C++对应项相同。</p>
<p>材质属性通过常量缓冲区传递给像素着色器。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cbuffer Material : <span class="built_in">register</span>( b2 )</span><br><span class="line">{</span><br><span class="line">    Material Mat;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>本文描述的所有像素着色器都使用此常量缓冲区和缓冲区寄存器分配。</p>
<h3 id="Textures-纹理">Textures&nbsp;纹理</h3>
<p>这些材质支持八种不同的纹理。</p>
<ol>
<li>Ambient&nbsp;环境光</li>
<li>Emissive&nbsp;自发光</li>
<li>Diffuse&nbsp;漫反射</li>
<li>Specular&nbsp;镜面</li>
<li>SpecularPower&nbsp;反射率</li>
<li>Normals&nbsp;法线</li>
<li>Bump&nbsp;凹凸</li>
<li>Opacity&nbsp;不透明度</li>
</ol>
<p>并非所有场景对象都会使用所有的纹理槽（法线和凹凸贴图是互斥的，因此它们可能会重用相同的纹理槽分配）。由 3D 艺术家决定场景中的模型将使用哪些纹理。应用程序将加载与材质关联的纹理。为每个这些材质属性声明一个纹理参数和一个关联的纹理槽分配。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Texture2D AmbientTexture        : <span class="built_in">register</span>( t0 );</span><br><span class="line">Texture2D EmissiveTexture       : <span class="built_in">register</span>( t1 );</span><br><span class="line">Texture2D DiffuseTexture        : <span class="built_in">register</span>( t2 );</span><br><span class="line">Texture2D SpecularTexture       : <span class="built_in">register</span>( t3 );</span><br><span class="line">Texture2D SpecularPowerTexture  : <span class="built_in">register</span>( t4 );</span><br><span class="line">Texture2D NormalTexture         : <span class="built_in">register</span>( t5 );</span><br><span class="line">Texture2D BumpTexture           : <span class="built_in">register</span>( t6 );</span><br><span class="line">Texture2D OpacityTexture        : <span class="built_in">register</span>( t7 );</span><br></pre></td></tr></tbody></table></figure>
<p>在本文中描述的每个像素着色器中，纹理槽 0-7 将被保留用于这些纹理。</p>
<h3 id="Lights-灯光">Lights&nbsp;灯光</h3>
<p>Light 结构存储了定义场景中光源所需的所有信息。聚光灯、点光源和定向光源并未分开存储在不同的结构中，定义任何一种光源类型所需的所有属性都存储在单个结构中。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Light</span></span><br><span class="line">{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Position for point and spot lights (World space).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    float4   PositionWS;</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------( 16 bytes )</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Direction for spot and directional lights (World space).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    float4   DirectionWS;</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------( 16 bytes )</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Position for point and spot lights (View space).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    float4   PositionVS;</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------( 16 bytes )</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Direction for spot and directional lights (View space).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    float4   DirectionVS;</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------( 16 bytes )</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Color of the light. Diffuse and specular colors are not seperated.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    float4   Color;</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------( 16 bytes )</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The half angle of the spotlight cone.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">float</span>    SpotlightAngle;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The range of the light.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">float</span>    Range;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The intensity of the light.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">float</span>    Intensity;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Disable or enable the light.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">bool</span>    Enabled;</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------( 16 bytes )</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Is the light selected in the editor?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="type">bool</span>    Selected;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The type of the light.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    uint    Type;</span><br><span class="line">    float2  Padding;</span><br><span class="line">    <span class="comment">//--------------------------------------------------------------( 16 bytes )</span></span><br><span class="line">    <span class="comment">//--------------------------------------------------------------( 16 * 7 = 112 bytes )</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>位置和方向属性分别存储在世界空间（带有 WS 后缀）和视图空间（带有 VS 后缀）中。当然，位置变量仅适用于点光源和聚光灯，而方向变量仅适用于聚光灯和方向光源。我同时存储世界空间和视图空间的位置和方向向量，因为我发现在应用程序中更容易在世界空间中工作，然后在将世界空间向量转换为视图空间之前将灯光数组上传到 GPU。这样，我就不需要维护多个光源列表，而需要的额外空间仅在 GPU 上。即使有 10,000 个光源，也仅需要 1.12 MB 的 GPU 空间，所以我认为这是一个合理的牺牲。但是，减小光源结构的大小可能对 GPU 上的缓存产生积极影响，并提高渲染性能。这在本文末尾的未来考虑部分进一步讨论。</p>
<p>在一些光照模型中，漫反射和镜面反射的光照贡献是分开的。我选择不分开漫反射和镜面反射的颜色贡献，因为这些值不经常不同。相反，我选择将漫反射和镜面反射的光照贡献都存储在一个名为 Color 的单个变量中。</p>
<p>SpotlightAngle 是以度为单位表示的聚光灯锥体的半角。使用度数似乎比使用弧度更直观。当我们需要计算聚光灯和光矢量的余弦角时，聚光灯角度当然会在着色器中转换为弧度。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405171903211.png" alt="Spotlight" loading='lazy'></p>
<p>Spotlight Angle&nbsp;聚光灯角度</p>
<p>范围变量确定光线的到达距离，并仍然为表面提供光线。虽然不完全符合物理规律（真实光源具有永远不会真正达到 0 的衰减），但需要光源具有有限范围以实现延迟着色和Foward+渲染方式。这个范围的单位是特定于场景的，但通常我尝试遵守 1 单位等于 1 米的规范。对于点光源，范围是代表光源的球体的半径，对于聚光灯，范围是代表光源的锥体的长度。定向光不使用范围，因为它们被认为是无限远，无论在哪里指向相同方向。</p>
<p>强度变量用于调节计算得到的光照贡献。默认情况下，该值为 1，但可以用来使一些灯光比其他灯光更亮或更微妙。</p>
<p>场景中的灯光可以通过 Enabled 标志进行开关控制。Enabled 标志为 false 的灯光将在着色器中被跳过。</p>
<p>在此演示中，灯光是可编辑的。可以通过在演示应用程序中单击灯光来选择灯光并修改其属性。要表示当前选择的灯光，Selected 标志将被设置为 true。当在场景中选择灯光时，其视觉表示将变暗（不透明度降低），以表示当前选择的状态。</p>
<p>Type 变量用于指示这是哪种类型的光。它可以具有以下值之一：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> POINT_LIGHT 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPOT_LIGHT 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DIRECTIONAL_LIGHT 2</span></span><br></pre></td></tr></tbody></table></figure>
<p>再次，Light 结构体明确填充了 8 字节，以匹配 C++ 中的结构布局，并使结构体明确对齐到 16 字节，这在 HLSL 中是必需的。</p>
<p>通过 StructuredBuffer 访问 lights 数组。大多数光照着色器实现将使用常量缓冲区来存储 lights 数组，但<code>常量缓冲区的大小限制为 64 KB，这意味着在 GPU 上的常量内存用完之前，lights 数组将受到限制，大约只能容纳约 570 个光源。Structured buffers 存储在纹理内存中，其大小受 GPU 上可用纹理内存的限制（通常在台式机 GPU 上为 GB 级别）</code>。大多数 GPU 上的纹理内存速度也非常快，因此将 lights 存储在结构化缓冲区中并不会对性能产生影响。事实上，在我的特定 GPU（NVIDIA GeForce GTX 680）上，当我将 lights 数组移动到结构化缓冲区时，我注意到了显著的性能改进。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StructuredBuffer&lt;Light&gt; Lights : <span class="built_in">register</span>( t8 );</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Pixel-Shader-Continued-像素着色器">Pixel Shader Continued&nbsp;像素着色器</h2>
<p>正向渲染方式的像素着色器比顶点着色器稍微复杂一些。如果您已经阅读了我之前的文章《DirectX 11 中的纹理和光照》，那么您应该已经熟悉了这个着色器的大部分实现，但我会在这里详细解释，因为它是本文中展示的所有渲染算法的基础。</p>
<h3 id="Materials-材质">Materials&nbsp;材质</h3>
<p>首先，我们需要收集材质的材质属性。如果材质具有与其各个组件相关联的纹理，那么在计算光照之前将对纹理进行采样。初始化材质属性后，将迭代场景中的所有灯光，并将光照贡献累积并与材质属性调制，以生成最终像素颜色。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[earlydepthstencil]</span><br><span class="line"><span class="function">float4 <span class="title">PS_main</span><span class="params">( VertexShaderOutput IN )</span> : SV_TARGET</span></span><br><span class="line"><span class="function">{</span></span><br><span class="line">    <span class="comment">// Everything is in view space.</span></span><br><span class="line">    float4 eyePos = { <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> };</span><br><span class="line">    Material mat = Mat;</span><br></pre></td></tr></tbody></table></figure>
<p>在函数之前的[earlydepthstencil]属性表示 GPU 应该利用提前深度和模板剔除[10]。这会导致深度/模板测试在像素着色器执行之前执行。这个属性不能用于修改像素深度值的着色器，因为它使用 SV_Depth 语义输出值。由于这个像素着色器只使用 SV_TARGET 语义输出颜色值，它可以利用提前深度/模板测试来提高性能，当像素被拒绝时。大多数 GPU 即使没有这个属性也会执行提前深度/模板测试，将这个属性添加到像素着色器并没有明显影响性能，但我还是决定保留这个属性。</p>
<p>由于所有的光照计算将在视图空间中执行，眼睛位置（相机的位置）始终为（0, 0, 0）。这是在<code>视图空间中工作的一个好处；相机的眼睛位置不需要作为额外参数传递给着色器</code>。</p>
<p>在第 24 行，将材质的临时副本创建，因为如果材质属性有关联的纹理，那么在着色器中将修改这些属性。由于材质属性存储在常量缓冲区中，无法直接从常量缓冲区统一变量更新材质属性，因此必须使用本地临时变量。</p>
<h4 id="Diffuse-漫反射">Diffuse&nbsp;漫反射</h4>
<p>我们将要阅读的第一个材质属性是漫反射颜色。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">float4 diffuse = mat.DiffuseColor;</span><br><span class="line"><span class="keyword">if</span> ( mat.HasDiffuseTexture )</span><br><span class="line">{</span><br><span class="line">    float4 diffuseTex = DiffuseTexture.<span class="built_in">Sample</span>( LinearRepeatSampler, IN.texCoord );</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">any</span>( diffuse.rgb ) )</span><br><span class="line">    {</span><br><span class="line">        diffuse *= diffuseTex;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        diffuse = diffuseTex;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>默认的漫反射颜色是分配给材质的 DiffuseColor 变量的漫反射颜色。如果材质还有与之关联的漫反射纹理，那么来自漫反射纹理的颜色将与材质的漫反射颜色混合。如果材质的漫反射颜色是黑色（0, 0, 0, 0），那么材质的漫反射颜色将简单地被漫反射纹理中的颜色替换。任何 hlsl 内置函数都可以用来查找颜色分量中是否有任何非零值。</p>
<h4 id="Opacity-不透明度">Opacity&nbsp;不透明度</h4>
<p>像素的 alpha 值是接下来确定的。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> alpha = diffuse.a;</span><br><span class="line"><span class="keyword">if</span> ( mat.HasOpacityTexture )</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// If the material has an opacity texture, use that to override the diffuse alpha.</span></span><br><span class="line">    alpha = OpacityTexture.<span class="built_in">Sample</span>( LinearRepeatSampler, IN.texCoord ).r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>默认情况下，片元的透明度值由漫反射颜色的 alpha 分量确定。如果材质有与之关联的不透明度纹理，不透明度纹理的红色分量将用作 alpha 值，覆盖漫反射纹理中的 alpha 值。在大多数情况下，不透明度纹理仅存储从 Sample 方法返回的颜色的第一个分量中的单个pass。为了从单pass纹理中读取，我们必须从红色pass读取，而不是从 alpha pass读取。单pass纹理的 alpha pass将始终为 1，因此从不透明度图中读取 alpha pass（这很可能是单pass纹理）将无法提供我们需要的值。</p>
<h4 id="Ambient-and-Emissive-环境和自发光">Ambient and Emissive&nbsp;环境和自发光</h4>
<p>环境色和发射色的读取方式与漫反射色类似。环境色还与材质的 GlobalAmbient 变量的值相结合。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">float4 ambient = mat.AmbientColor;</span><br><span class="line"><span class="keyword">if</span> ( mat.HasAmbientTexture )</span><br><span class="line">{</span><br><span class="line">    float4 ambientTex = AmbientTexture.<span class="built_in">Sample</span>( LinearRepeatSampler, IN.texCoord );</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">any</span>( ambient.rgb ) )</span><br><span class="line">    {</span><br><span class="line">        ambient *= ambientTex;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        ambient = ambientTex;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Combine the global ambient term.</span></span><br><span class="line">ambient *= mat.GlobalAmbient;</span><br><span class="line"></span><br><span class="line">float4 emissive = mat.EmissiveColor;</span><br><span class="line"><span class="keyword">if</span> ( mat.HasEmissiveTexture )</span><br><span class="line">{</span><br><span class="line">    float4 emissiveTex = EmissiveTexture.<span class="built_in">Sample</span>( LinearRepeatSampler, IN.texCoord );</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">any</span>( emissive.rgb ) )</span><br><span class="line">    {</span><br><span class="line">        emissive *= emissiveTex;</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    {</span><br><span class="line">        emissive = emissiveTex;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Specular-Power-反射率">Specular Power&nbsp;反射率</h4>
<p>接下来计算镜面率。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( mat.HasSpecularPowerTexture )</span><br><span class="line">{</span><br><span class="line">    mat.SpecularPower = SpecularPowerTexture.<span class="built_in">Sample</span>( LinearRepeatSampler, IN.texCoord ).r \</span><br><span class="line">                        * mat.SpecularScale;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果材质具有关联的高光强度纹理，纹理的红色分量将被采样并乘以材质的 SpecularScale 变量的值。在这种情况下，材质中的 SpecularPower 变量的值将被替换为纹理中的缩放值。</p>
<h4 id="Normals-正常">Normals&nbsp;正常</h4>
<p>如果材质具有关联的法线贴图或凹凸贴图，则将执行法线贴图以计算法线向量。如果材质未关联法线贴图或凹凸贴图纹理，则输入法线将按原样使用。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Normal mapping</span></span><br><span class="line"><span class="keyword">if</span> ( mat.HasNormalTexture )</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// For scenes with normal mapping, I don't have to invert the binormal.</span></span><br><span class="line">    float3x3 TBN = <span class="built_in">float3x3</span>( <span class="built_in">normalize</span>( IN.tangentVS ),</span><br><span class="line">                             <span class="built_in">normalize</span>( IN.binormalVS ),</span><br><span class="line">                             <span class="built_in">normalize</span>( IN.normalVS ) );</span><br><span class="line"></span><br><span class="line">    N = <span class="built_in">DoNormalMapping</span>( TBN, NormalTexture, LinearRepeatSampler, IN.texCoord );</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Bump mapping</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ( mat.HasBumpTexture )</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// For most scenes using bump mapping, I have to invert the binormal.</span></span><br><span class="line">    float3x3 TBN = <span class="built_in">float3x3</span>( <span class="built_in">normalize</span>( IN.tangentVS ),</span><br><span class="line">                             <span class="built_in">normalize</span>( -IN.binormalVS ), </span><br><span class="line">                             <span class="built_in">normalize</span>( IN.normalVS ) );</span><br><span class="line"></span><br><span class="line">    N = <span class="built_in">DoBumpMapping</span>( TBN, BumpTexture, LinearRepeatSampler, IN.texCoord, mat.BumpIntensity );</span><br><span class="line">}</span><br><span class="line"><span class="comment">// Just use the normal from the model.</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">{</span><br><span class="line">    N = <span class="built_in">normalize</span>( <span class="built_in">float4</span>( IN.normalVS, <span class="number">0</span> ) );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Normal-Mapping-法线贴图">Normal Mapping&nbsp;法线贴图</h4>
<p>DoNormalMapping 函数将从 TBN（切线、双切线/法线副切线、法线）矩阵和法线贴图执行法线采样。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405171903881.jpeg" alt="Lion Normal Map" loading='lazy'></p>
<p>狮子头在 Crytek Sponza 场景中的一个示例法线贴图纹理。[11]</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float3 <span class="title">ExpandNormal</span><span class="params">( float3 n )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> n * <span class="number">2.0f</span> - <span class="number">1.0f</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="function">float4 <span class="title">DoNormalMapping</span><span class="params">( float3x3 TBN, Texture2D tex, sampler s, float2 uv )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    float3 normal = tex.<span class="built_in">Sample</span>( s, uv ).xyz;</span><br><span class="line">    normal = <span class="built_in">ExpandNormal</span>( normal );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transform normal from tangent space to view space.</span></span><br><span class="line">    normal = <span class="built_in">mul</span>( normal, TBN );</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">normalize</span>( <span class="built_in">float4</span>( normal, <span class="number">0</span> ) );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>普通贴图非常简单，之前的一篇名为“法线贴图”的文章中对此进行了更详细的解释，所以我就不在这里详细解释了。基本上，我们只需要从法线贴图中采样法线，将法线扩展到[-1…1]范围内，并通过将其与 TBN 矩阵进行后乘来将其从切线空间转换到视图空间。</p>
<h4 id="Bump-Mapping-凹凸贴图">Bump Mapping&nbsp;凹凸贴图</h4>
<p>凹凸贴图的工作方式类似，不同之处在于凹凸贴图纹理中不直接存储法线，而是存储高度值，范围为[0…1]。可以通过计算高度图中 U 和 V 纹理坐标方向上的高度值梯度来生成法线。在每个方向上梯度的叉积给出了纹理空间中的法线。将结果法线与 TBN 矩阵相乘将给出视图空间中的法线。从凹凸贴图中读取的高度值可以缩放以产生更多（或更少）突出的凹凸效果。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405171903273.jpeg" alt="Bumpmapping" loading='lazy'></p>
<p>凹凸贴图纹理（左）和相应的头部模型（右）。【12】</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float4 <span class="title">DoBumpMapping</span><span class="params">( float3x3 TBN, Texture2D tex, sampler s, float2 uv, <span class="type">float</span> bumpScale )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Sample the heightmap at the current texture coordinate.</span></span><br><span class="line">    <span class="type">float</span> height = tex.<span class="built_in">Sample</span>( s, uv ).r * bumpScale;</span><br><span class="line">    <span class="comment">// Sample the heightmap in the U texture coordinate direction.</span></span><br><span class="line">    <span class="type">float</span> heightU = tex.<span class="built_in">Sample</span>( s, uv, <span class="built_in">int2</span>( <span class="number">1</span>, <span class="number">0</span> ) ).r * bumpScale;</span><br><span class="line">    <span class="comment">// Sample the heightmap in the V texture coordinate direction.</span></span><br><span class="line">    <span class="type">float</span> heightV = tex.<span class="built_in">Sample</span>( s, uv, <span class="built_in">int2</span>( <span class="number">0</span>, <span class="number">1</span> ) ).r * bumpScale;</span><br><span class="line"></span><br><span class="line">    float3 p = { <span class="number">0</span>, <span class="number">0</span>, height };</span><br><span class="line">    float3 pU = { <span class="number">1</span>, <span class="number">0</span>, heightU };</span><br><span class="line">    float3 pV = { <span class="number">0</span>, <span class="number">1</span>, heightV };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// normal = tangent x bitangent</span></span><br><span class="line">    float3 normal = <span class="built_in">cross</span>( <span class="built_in">normalize</span>(pU - p), <span class="built_in">normalize</span>(pV - p) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Transform normal from tangent space to view space.</span></span><br><span class="line">    normal = <span class="built_in">mul</span>( normal, TBN );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float4</span>( normal, <span class="number">0</span> );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>我不确定这个凹凸贴图算法是否 100%正确。我找不到任何资源显示如何正确地进行凹凸贴图。如果您能提出更好（和正确）的执行凹凸贴图的方法，请在下面留言。</p>
<p>如果材质没有关联的法线贴图或凹凸贴图，则直接使用顶点着色器输出的法线向量。</p>
<p>现在我们拥有计算光照所需的所有数据。</p>
<h3 id="Lighting-灯光">Lighting&nbsp;灯光</h3>
<p>正向渲染方式的灯光计算是在 DoLighting 函数中执行的。该函数接受以下参数：</p>
<ul>
<li><strong>lights</strong>: The lights array (as a structured buffer)<br>
灯光：灯光数组（作为结构化缓冲区）</li>
<li><strong>mat</strong>: The material properties that were just computed<br>
材质属性刚刚计算出来的</li>
<li><strong>eyePos</strong>: The position of the camera in view space (which is always (0, 0, 0))<br>
eyePos: 相机在视图空间中的位置（始终为（0, 0, 0））</li>
<li><strong>P</strong>: The position of the point being shaded in view space<br>
P: 在视图空间中被着色的点的位置</li>
<li><strong>N</strong>: The normal of the point being shaded in view space.<br>
N：在视空间中着色的点的法线。</li>
</ul>
<p>DoLighting 函数返回一个 LightingResult 结构，其中包含场景中所有灯光的漫反射和镜面光照贡献。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This lighting result is returned by the </span></span><br><span class="line"><span class="comment">// lighting functions for each light type.</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LightingResult</span></span><br><span class="line">{</span><br><span class="line">    float4 Diffuse;</span><br><span class="line">    float4 Specular;</span><br><span class="line">};</span><br><span class="line"></span><br><span class="line"><span class="function">LightingResult <span class="title">DoLighting</span><span class="params">( StructuredBuffer&lt;Light&gt; lights, Material mat, float4 eyePos, float4 P, float4 N )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    float4 V = <span class="built_in">normalize</span>( eyePos - P );</span><br><span class="line"></span><br><span class="line">    LightingResult totalResult = (LightingResult)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM_LIGHTS; ++i )</span><br><span class="line">    {</span><br><span class="line">        LightingResult result = (LightingResult)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Skip lights that are not enabled.</span></span><br><span class="line">        <span class="keyword">if</span> ( !lights[i].Enabled ) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// Skip point and spot lights that are out of range of the point being shaded.</span></span><br><span class="line">        <span class="keyword">if</span> ( lights[i].Type != DIRECTIONAL_LIGHT &amp;&amp;</span><br><span class="line">             <span class="built_in">length</span>( lights[i].PositionVS - P ) &gt; lights[i].Range ) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> ( lights[i].Type )</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> DIRECTIONAL_LIGHT:</span><br><span class="line">        {</span><br><span class="line">            result = <span class="built_in">DoDirectionalLight</span>( lights[i], mat, V, P, N );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> POINT_LIGHT:</span><br><span class="line">        {</span><br><span class="line">            result = <span class="built_in">DoPointLight</span>( lights[i], mat, V, P, N );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SPOT_LIGHT:</span><br><span class="line">        {</span><br><span class="line">            result = <span class="built_in">DoSpotLight</span>( lights[i], mat, V, P, N );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        totalResult.Diffuse += result.Diffuse;</span><br><span class="line">        totalResult.Specular += result.Specular;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> totalResult;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>视图向量（V）是从眼睛位置和视图空间中阴影像素的位置计算得出的。</p>
<p>光缓冲区在第 439 行上进行迭代。由于我们知道禁用的灯光和不在被着色点范围内的灯光不会提供任何光照，我们可以跳过这些灯光。否则，根据灯光类型调用适当的光照函数。</p>
<p>各种光源类型将计算它们的漫反射和镜面反射光照贡献。由于漫反射和镜面反射光照对于每种光源类型的计算方式相同，我将定义函数来计算漫反射和镜面反射光照贡献，独立于光源类型。</p>
<h4 id="Diffuse-Lighting-漫反射光照">Diffuse Lighting&nbsp;漫反射光照</h4>
<p>DoDiffuse 函数非常简单，只需要知道光矢量（L）和表面法线（N）即可。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405171906250.png" alt="Diffuse Lighting" loading='lazy'></p>
<p>Diffuse Lighting&nbsp;漫射光</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float4 <span class="title">DoDiffuse</span><span class="params">( Light light, float4 L, float4 N )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">float</span> NdotL = <span class="built_in">max</span>( <span class="built_in">dot</span>( N, L ), <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> light.Color * NdotL;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>漫反射光照是通过计算光矢量（L）和表面法线（N）之间的点积来实现的。DoDiffuse 函数期望这两个向量都被归一化。</p>
<p>然后将得到的点积乘以光的颜色，以计算光的漫反射贡献。</p>
<p>接下来，我们将计算光的镜面贡献。</p>
<h4 id="Specular-Lighting-镜面光照">Specular Lighting&nbsp;镜面光照</h4>
<p>DoSpecular 函数用于计算光的镜面贡献。除了光矢量（L）和表面法线（N）之外，该函数还需要视图矢量（V）来计算光的镜面贡献。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405171906036.png" alt="Specular Lighting" loading='lazy'></p>
<p>Specular Lighting&nbsp;镜面光照</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">float4 <span class="title">DoSpecular</span><span class="params">( Light light, Material material, float4 V, float4 L, float4 N )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    float4 R = <span class="built_in">normalize</span>( <span class="built_in">reflect</span>( -L, N ) );</span><br><span class="line">    <span class="type">float</span> RdotV = <span class="built_in">max</span>( <span class="built_in">dot</span>( R, V ), <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> light.Color * <span class="built_in">pow</span>( RdotV, material.SpecularPower );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于光矢量 L 是从被着色点指向光源的矢量，所以在计算反射矢量之前，需要对其取反，使其从光源指向被着色点。反射矢量（R）和视图矢量（V）的点积结果被提升到材质的高光率变量的值，并受光的颜色调制。重要的是要记住，范围在（0…1）的高光率值并不是一个有意义的高光率值。有关高光光照的详细解释，请参阅我之前发表的文章，标题为《DirectX 11 中的纹理和光照》。</p>
<h4 id="Attenuation-衰减">Attenuation&nbsp;衰减</h4>
<p>衰减是光强随着光离被遮挡点的距离增加而减弱的过程。在传统的光照模型中，衰减被计算为三个衰减因子之和的倒数乘以到光源的距离（如在衰减中所解释的）。</p>
<ol>
<li>Constant attenuation&nbsp;恒定衰减</li>
<li>Linear attenuation&nbsp;线性衰减</li>
<li>Quadratic attenuation&nbsp;二次衰减</li>
</ol>
<p>然而，这种计算衰减的方法假设光线的衰减永远不会达到零（灯光具有无限范围）。对于延迟着色和前向加法，我们必须能够将场景中的灯光表示为具有有限范围的体积，因此我们需要使用不同的方法来计算光线的衰减。</p>
<p>计算光线衰减的一种可能方法是从 1.0 开始进行线性混合，当点最靠近光源时为 1.0，如果点的距离大于光源的范围，则为 0.0。然而，线性衰减看起来并不是很现实，因为实际上衰减更类似于二次函数的倒数。</p>
<p>我决定使用 smoothstep hlsl 内置函数，该函数返回最小值和最大值之间的平滑插值。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405171907213.png" alt="HLSL smoothstep intrinsic function" loading='lazy'></p>
<p>HLSL smoothstep 内置函数</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute the attenuation based on the range of the light.</span></span><br><span class="line"><span class="function"><span class="type">float</span> <span class="title">DoAttenuation</span><span class="params">( Light light, <span class="type">float</span> d )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1.0f</span> - <span class="built_in">smoothstep</span>( light.Range * <span class="number">0.75f</span>, light.Range, d );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>smoothstep 函数将在距离光源的距离（d）小于光源范围的 3/4 时返回 0，在距离光源的距离大于范围时返回 1。当然，我们希望反转这种插值，所以我们只需从 1 中减去这个值，以获得我们需要的衰减。</p>
<p>可选地，我们可以通过上述方程中的 0.75f 的参数化来调整光线衰减的平滑度。平滑度因子为 0.0 应导致光线的强度一直保持为 1.0，直到光线的最大范围，而平滑度为 1.0 应导致光线的强度在整个光线范围内插值。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405171907698.jpeg" alt="Attenuation smoothness" loading='lazy'></p>
<p>变量衰减平滑度。<br>
现在让我们结合漫反射、镜面反射和衰减因子来计算每种光类型的光照贡献。</p>
<h4 id="Point-Lights-点光源">Point Lights&nbsp;点光源</h4>
<p>点光源结合衰减、漫反射和镜面反射值来确定光的最终贡献。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LightingResult <span class="title">DoPointLight</span><span class="params">( Light light, Material mat, float4 V, float4 P, float4 N )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LightingResult result;</span><br><span class="line"></span><br><span class="line">    float4 L = light.PositionVS - P;</span><br><span class="line">    <span class="type">float</span> distance = <span class="built_in">length</span>( L );</span><br><span class="line">    L = L / distance;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> attenuation = <span class="built_in">DoAttenuation</span>( light, distance );</span><br><span class="line"></span><br><span class="line">    result.Diffuse = <span class="built_in">DoDiffuse</span>( light, L, N ) * </span><br><span class="line">                      attenuation * light.Intensity;</span><br><span class="line">    result.Specular = <span class="built_in">DoSpecular</span>( light, mat, V, L, N ) * </span><br><span class="line">                       attenuation * light.Intensity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在第 400-401 行，漫反射和镜面反射的贡献在从函数返回之前会被衰减和光强因子缩放。</p>
<h4 id="Spot-Lights-聚光灯">Spot Lights&nbsp;聚光灯</h4>
<p>除了衰减因子外，聚光灯还有一个锥角。在这种情况下，光的强度由光矢量（L）与聚光灯方向之间的点积来缩放。如果光矢量与聚光灯方向之间的角度小于聚光灯锥角，则该点应该被聚光灯照亮。否则，聚光灯不应该为被遮蔽的点贡献任何光线。DoSpotCone 函数将根据聚光灯锥角计算光的强度。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">DoSpotCone</span><span class="params">( Light light, float4 L )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// If the cosine angle of the light's direction </span></span><br><span class="line">    <span class="comment">// vector and the vector from the light source to the point being </span></span><br><span class="line">    <span class="comment">// shaded is less than minCos, then the spotlight contribution will be 0.</span></span><br><span class="line">    <span class="type">float</span> minCos = <span class="built_in">cos</span>( <span class="built_in">radians</span>( light.SpotlightAngle ) );</span><br><span class="line">    <span class="comment">// If the cosine angle of the light's direction vector</span></span><br><span class="line">    <span class="comment">// and the vector from the light source to the point being shaded</span></span><br><span class="line">    <span class="comment">// is greater than maxCos, then the spotlight contribution will be 1.</span></span><br><span class="line">    <span class="type">float</span> maxCos = <span class="built_in">lerp</span>( minCos, <span class="number">1</span>, <span class="number">0.5f</span> );</span><br><span class="line">    <span class="type">float</span> cosAngle = <span class="built_in">dot</span>( light.DirectionVS, -L );</span><br><span class="line">    <span class="comment">// Blend between the minimum and maximum cosine angles.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>( minCos, maxCos, cosAngle );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>首先，计算聚光锥的余弦角。如果聚光灯方向与光矢量（L）的点积小于最小余弦角，则光的贡献将为 0。如果点积大于最大余弦角，则聚光的贡献将为 1。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405171908339.png" alt="Spotlight Min/Max Cosine Angles" loading='lazy'></p>
<p>聚光灯的最小和最大余弦角。</p>
<p>看起来可能有些反直觉，最大余弦角比最小余弦角小，但不要忘记 0°的余弦是 1，90°的余弦是 0。</p>
<p>DoSpotLight 函数将计算聚光灯的贡献，类似于点光源，但增加了聚光锥角。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LightingResult <span class="title">DoSpotLight</span><span class="params">( Light light, Material mat, float4 V, float4 P, float4 N )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LightingResult result;</span><br><span class="line"></span><br><span class="line">    float4 L = light.PositionVS - P;</span><br><span class="line">    <span class="type">float</span> distance = <span class="built_in">length</span>( L );</span><br><span class="line">    L = L / distance;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> attenuation = <span class="built_in">DoAttenuation</span>( light, distance );</span><br><span class="line">    <span class="type">float</span> spotIntensity = <span class="built_in">DoSpotCone</span>( light, L );</span><br><span class="line"></span><br><span class="line">    result.Diffuse = <span class="built_in">DoDiffuse</span>( light, L, N ) * </span><br><span class="line">                       attenuation * spotIntensity * light.Intensity;</span><br><span class="line">    result.Specular = <span class="built_in">DoSpecular</span>( light, mat, V, L, N ) * </span><br><span class="line">                       attenuation * spotIntensity * light.Intensity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h4 id="Directional-Lights-定向光">Directional Lights&nbsp;定向光</h4>
<p>定向光是最简单的光类型，因为它们不会随着到达被着色点的距离而衰减。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LightingResult <span class="title">DoDirectionalLight</span><span class="params">( Light light, Material mat, float4 V, float4 P, float4 N )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    LightingResult result;</span><br><span class="line"></span><br><span class="line">    float4 L = <span class="built_in">normalize</span>( -light.DirectionVS );</span><br><span class="line"></span><br><span class="line">    result.Diffuse = <span class="built_in">DoDiffuse</span>( light, L, N ) * light.Intensity;</span><br><span class="line">    result.Specular = <span class="built_in">DoSpecular</span>( light, mat, V, L, N ) * light.Intensity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Final-Shading-最终着色">Final Shading&nbsp;最终着色</h3>
<p>现在我们有场景中所有灯光的材质属性和总和光照贡献，我们可以将它们组合起来执行最终的着色。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    float4 P = <span class="built_in">float4</span>( IN.positionVS, <span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">    LightingResult lit = <span class="built_in">DoLighting</span>( Lights, mat, eyePos, P, N );</span><br><span class="line"></span><br><span class="line">    diffuse *= <span class="built_in">float4</span>( lit.Diffuse.rgb, <span class="number">1.0f</span> ); <span class="comment">// Discard the alpha value from the lighting calculations.</span></span><br><span class="line"></span><br><span class="line">    float4 specular = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( mat.SpecularPower &gt; <span class="number">1.0f</span> ) <span class="comment">// If specular power is too low, don't use it.</span></span><br><span class="line">    {</span><br><span class="line">        specular = mat.SpecularColor;</span><br><span class="line">        <span class="keyword">if</span> ( mat.HasSpecularTexture )</span><br><span class="line">        {</span><br><span class="line">            float4 specularTex = SpecularTexture.<span class="built_in">Sample</span>( LinearRepeatSampler, IN.texCoord );</span><br><span class="line">            <span class="keyword">if</span> ( <span class="built_in">any</span>( specular.rgb ) )</span><br><span class="line">            {</span><br><span class="line">                specular *= specularTex;</span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            {</span><br><span class="line">                specular = specularTex;</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">        specular *= lit.Specular;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float4</span>( ( ambient + emissive + diffuse + specular ).rgb, </span><br><span class="line">                     alpha * mat.Opacity );</span><br><span class="line"></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在第 113 行，使用刚刚描述的 DoLighting 函数计算光照贡献。</p>
<p>在第 115 行，材质的漫反射颜色受到光的漫反射贡献的调制。</p>
<p>如果材质的高光强度低于 1.0，则不会被考虑用于最终着色。一些艺术家会为没有高光反射的材质分配低于 1 的高光强度。在这种情况下，我们只忽略高光的贡献，将材质视为仅有漫反射（兰伯特反射）。否则，如果材质带有高光颜色纹理，将对其进行采样并与材质的高光颜色结合，然后再与光的高光贡献调制。</p>
<p>最终像素颜色是环境光、自发光、漫反射和高光分量的总和。像素的不透明度由像素着色器中先前确定的 alpha 值决定。</p>
<h1>Deferred Shading&nbsp;延迟渲染</h1>
<p>延迟渲染方式包括三个pass：</p>
<ol>
<li>G-buffer pass</li>
<li>Lighting pass</li>
<li>Transparent pass</li>
</ol>
<p>G 缓冲pass将填充介绍中描述的 G 缓冲纹理。光照pass将每个光源渲染为几何对象，并计算覆盖像素的光照。透明pass将使用标准的前向渲染方式渲染透明场景对象。</p>
<h2 id="G-Buffer-Pass">G-Buffer Pass</h2>
<p>延迟着色方式的第一步将生成 G 缓冲纹理。我将首先描述 G 缓冲的布局。</p>
<h3 id="G-Buffer-Layout">G-Buffer Layout</h3>
<p>G-buffer 的布局可以成为本网站上一篇完整文章的主题。我为这个演示选择的布局是基于简单和必要性的。这不是最有效的 G-buffer 布局，因为一些数据可以更好地打包到更小的缓冲区中。关于在 G-buffer 中打包属性已经有一些讨论，但我没有进行任何关于使用各种打包方法的效果的分析。</p>
<p>需要存储在 G-buffer 中的属性是：</p>
<ul>
<li>Depth/Stencil&nbsp;深度/模板</li>
<li>Light Accumulation&nbsp;光照累加</li>
<li>Diffuse&nbsp;漫反射</li>
<li>Specular&nbsp;高光</li>
<li>Normals&nbsp;法线</li>
</ul>
<h4 id="Depth-Stencil-Buffer-深度-模板缓冲区">Depth/Stencil Buffer&nbsp;深度/模板缓冲区</h4>
<p>深度/模板纹理以每像素 32 位存储，其中深度值为 24 位，作为无符号归一化值（UNORM），模板值为 8 位，作为无符号整数（UINT）。 深度缓冲区的纹理资源使用 R24G8_TYPELESS 纹理格式创建，深度/模板视图使用 D24_UNORM_S8_UINT 纹理格式创建。 在像素着色器中访问深度缓冲区时，着色器资源视图使用 R24_UNORM_X8_TYPELESS 纹理格式创建，因为模板值未使用。</p>
<p>深度/模板缓冲区将附加到输出合并阶段，并且不会直接在 G 缓冲像素着色器中计算。 顶点着色器的结果直接写入深度/模板缓冲区。</p>
<blockquote>
<p>（需要注意的是，此处的深度模板缓冲区是由Deferred Render创建的，而非渲染流水线的深度模板缓冲区，是两份资源，称之为自定义深度缓冲区更合适，对于Unity的_CameraDepthTexture就是Unity帮我们从深度缓冲区拷贝的一个深度纹理，我们完全可以像Deferred Render这样自己绘制一份DepthTexture）</p>
</blockquote>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405171931420.jpeg" alt="Depth/Stencil buffer" loading='lazy'></p>
<p>G-buffer pass中深度/模板缓冲区的输出</p>
<h4 id="Light-Accumulation-Buffer">Light Accumulation Buffer</h4>
<p>光积累缓冲区用于存储光照pass的最终结果。这与屏幕的后备缓冲区相同。如果您的 G 缓冲纹理与屏幕的尺寸相同，则无需为光积累缓冲区分配额外的缓冲区，可以直接使用屏幕的后备缓冲区。</p>
<p>光积累缓冲区存储为 32 位 4 分量无符号归一化纹理，使用 R8G8B8A8_UNORM 纹理格式作为纹理资源和着色器资源视图。</p>
<p><img src="https://www.3dgep.com/wp-content/uploads/2015/08/Light-Accumulation.jpg" alt="Light Accumulation Buffer" loading='lazy'></p>
<p>光积累缓冲区存储发射和环境项。为了使场景更加清晰可见，这幅图像已经明显变亮。</p>
<p>在 G 缓冲pass之后，光积累缓冲区最初仅存储光照方程中的环境和自发项。为了使其更加可见，这幅图像被明显加亮。</p>
<p>您可能还注意到场景中仅呈现完全不透明的对象。延迟着色不支持透明对象，因此在 G 缓冲pass中仅呈现不透明对象。</p>
<p>作为一种优化，您可能还希望在 G 缓冲pass中累积定向光，并在光照pass中跳过定向光。由于定向光在光照pass中呈现为全屏幕四边形，如果填充率是一个问题，那么在 G 缓冲pass中累积它们可能会节省一些着色器周期。在这个实验中，我没有利用这种优化，因为这将需要将定向光存储在一个单独的缓冲区中，这与前向和Foward+像素着色器处理光照的方式不一致。</p>
<h4 id="Diffuse-Buffer-漫反射Buffer">Diffuse Buffer&nbsp;漫反射Buffer</h4>
<p>漫反射缓冲区存储为 32 位 4 分量无符号归一化（UNORM）纹理。由于延迟着色中只渲染不透明对象，因此在此缓冲区中不需要 alpha pass，在此实验中保持未使用。纹理资源和着色器资源视图均使用 R8G8B8A8_UNORM 纹理格式。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405171945960.jpeg" alt="Diffuse Buffer" loading='lazy'></p>
<p>G-buffer pass后的漫反射缓冲区。</p>
<p>上述图像显示了 G-buffer pass后漫反射缓冲区的结果。</p>
<h4 id="Specular-Buffer-镜面缓冲区">Specular Buffer&nbsp;镜面缓冲区</h4>
<p>与光累积和漫反射缓冲区类似，镜面反射颜色缓冲区使用 R8G8B8A8_UNORM 格式存储为 32 位 4 分量无符号归一化纹理。红色、绿色和蓝色通道用于存储镜面反射颜色，而 Alpha 通道用于存储镜面反射强度。镜面反射强度值通常以 (1…256]或更高范围表示，但需要将其打包到要存储在纹理中的范围 [0…1],要将镜面反射强度打包到纹理中，我使用所描述的方法。在 Michiel van der Leeuw 发表的题为“Deferred Rendering in Killzone 2”的演讲中，他使用以下公式来计算镜面反射强度值：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>α</mi><mn>2</mn></msup><mo>=</mo><mfrac><mrow><msub><mrow><mi>log</mi><mo>⁡</mo></mrow><mn>2</mn></msub><mi>α</mi></mrow><mn>10.5</mn></mfrac></mrow><annotation encoding="application/x-tex">\alpha^2=\frac{\log_2 \alpha}{10.5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.3272em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9822em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">10.5</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4961em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1944em;"><span style="top:-2.2341em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2659em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.1952em;"></span><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></p>
<p>此函数允许打包 [1…1448.15],范围内的镜面反射功率值，并为正常镜面反射中的值提供良好的精度范围 (1…256),下图显示了打包镜面反射值的趋势。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172000308.png" alt="The result of packing specular power. The horizontal axis shows the original specular power and the vertical axis shows the packed specular power.打包镜面率的结果。水平轴显示原始镜面率，垂直轴显示打包后的镜面率。" loading='lazy'></p>
<p>And the result of the specular buffer after the G-buffer pass looks like this.<br>
G-buffer pass后镜面缓冲区的结果看起来像这样。</p>
<p><img src="https://www.3dgep.com/wp-content/uploads/2015/08/Specular-Buffer.jpg" alt="The results of the specular buffer after the G-buffer pass.镜面缓冲区在 G-Buffer传递后的结果。" loading='lazy'></p>
<h4 id="Normal-Buffer-法线缓冲区">Normal Buffer&nbsp;法线缓冲区</h4>
<p>视图空间法线存储在一个 128 位 4 分量浮点缓冲区中，使用 R32G32B32A32_FLOAT 纹理格式。这样大小的法线缓冲区实际上并不是必需的，我可能可以将法线的 X 和 Y 分量打包到一个 32 位 2 分量半精度浮点缓冲区中，并在光照pass中重新计算 z 分量。对于这个实验，我更看重精度和简单性，而不是效率，因为我的 GPU 不受纹理内存的限制，我使用了具有最高精度的最大可能缓冲区。</p>
<p>值得研究其他法线缓冲区的纹理格式，并分析质量与性能之间的权衡。我的假设是，对于法线缓冲区使用较小的纹理格式（例如 R16G16_FLOAT）可能会产生类似质量的结果，同时提供改进的性能。</p>
<p><img src="https://www.3dgep.com/wp-content/uploads/2015/08/Normal-Buffer.jpg" alt="Normal Buffer" loading='lazy'></p>
<p>正常缓冲区在 G-Buffer传递后的结果。</p>
<p>上面的图像显示了 G-buffer pass后的正常缓冲区的结果。</p>
<h4 id="Layout-Summary-布局摘要">Layout Summary&nbsp;布局摘要</h4>
<p>整个 G-buffer 布局看起来与下面显示的表格类似。</p>
<table>
<thead>
<tr>
<th></th>
<th>R</th>
<th>G</th>
<th>B</th>
<th>A</th>
</tr>
</thead>
<tbody>
<tr>
<td>Depth/Stencil&nbsp;深度/模板</td>
<td>D24_UNORM</td>
<td></td>
<td></td>
<td>S8_UINT</td>
</tr>
<tr>
<td>Light Accumulation&nbsp;光积累</td>
<td>R8_UNORM</td>
<td>G8_UNORM</td>
<td>B8_UNORM</td>
<td>A8_UNORM</td>
</tr>
<tr>
<td>Diffuse</td>
<td>R8_UNORM</td>
<td>G8_UNORM</td>
<td>B8_UNORM</td>
<td>A8_UNORM</td>
</tr>
<tr>
<td>Specular</td>
<td>R8_UNORM</td>
<td>G8_UNORM</td>
<td>B8_UNORM</td>
<td>A8_UNORM</td>
</tr>
<tr>
<td>Normal</td>
<td>R32_FLOAT</td>
<td>G32_FLOAT</td>
<td>B32_FLOAT</td>
<td>A32_FLOAT</td>
</tr>
</tbody>
</table>
<h3 id="Pixel-Shader-像素着色器-2">Pixel Shader&nbsp;像素着色器</h3>
<p>G-buffer pass的像素着色器与前向渲染器的像素着色器非常相似。主要区别在于 G-buffer pass中不执行任何光照计算。在前向渲染方式中收集材质属性的过程与之前相同，因此我不会在此重复着色器代码的这一部分。</p>
<p>将 G-Buffer数据输出到纹理，每个 G-Buffer纹理将绑定到一个渲染目标输出，使用 PixelShaderOutput 结构。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">PixelShaderOutput</span></span><br><span class="line">{</span><br><span class="line">    float4 LightAccumulation    : SV_Target0;</span><br><span class="line">    float4 Diffuse              : SV_Target1;</span><br><span class="line">    float4 Specular             : SV_Target2;</span><br><span class="line">    float4 NormalVS             : SV_Target3;</span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>由于深度/模板缓冲区绑定到输出合并阶段，因此我们不需要从像素着色器输出深度值。</p>
<p>现在让我们在像素着色器中填充 G 缓冲纹理。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[earlydepthstencil]</span><br><span class="line"><span class="function">PixelShaderOutput <span class="title">PS_Geometry</span><span class="params">( VertexShaderOutput IN )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    PixelShaderOutput OUT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get emissive, ambient, diffuse, specular and normal values </span></span><br><span class="line">    <span class="comment">// In the same way as the forward rendering pixel shader.</span></span><br><span class="line">    <span class="comment">// The source code is not shown here for the sake of brevity.</span></span><br><span class="line"></span><br><span class="line">    OUT.LightAccumulation = ( ambient + emissive );</span><br><span class="line">    OUT.Diffuse = diffuse;</span><br><span class="line">    OUT.Specular = <span class="built_in">float4</span>( specular.rgb, <span class="built_in">log2</span>( specularPower ) / <span class="number">10.5f</span> ); </span><br><span class="line">    OUT.NormalVS = N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> OUT;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>一旦检索到所有材质属性，我们只需要将属性保存到适当的渲染目标中。为简洁起见，读取所有材质属性的源代码已被省略。您可以在本文末尾下载源代码以查看完整的像素着色器。</p>
<p>有了 G-Buffer填充，我们可以在光pass中计算最终的着色。在接下来的部分，我将描述 Guerrilla 在 Killzone 2 中使用的方法，还将描述我使用的实现并解释为什么我使用了不同的方法。</p>
<h2 id="Lighting-Pass-Guerrilla">Lighting Pass (Guerrilla)</h2>
<p>在这个实验中我使用的延迟着色方式的光照pass的主要灵感来源于 Michiel van der Leeuw 在 2007 年 8 月在加利福尼亚州帕洛阿尔托索尼计算机娱乐图形研讨会上的演示“Killzone 2 中的延迟渲染”[13]。在 Michiel 的演示中，他将光照pass描述为四个阶段：</p>
<ol>
<li>Clear stencil buffer to 0,<br>
将模板缓冲区清除为 0，</li>
<li>Mark pixels in front of the far light boundary,<br>
标记在远光边界前面的像素，</li>
<li>Count number of lit pixels inside the light volume,<br>
计算光体内部照亮的像素数量，</li>
<li>Shade the lit pixels<br>
遮住亮起的像素</li>
</ol>
<p>我将简要描述最后三个步骤。然后，我将介绍我选择用来实现延迟着色方式的光照pass的方法，并解释为什么我选择了与 Michiel 演示中所解释的方法不同的方法。</p>
<h3 id="Determine-Lit-Pixels-确定照亮的像素">Determine Lit Pixels&nbsp;确定照亮的像素</h3>
<p>根据 Michiel 的演示，要确定哪些像素被照亮，首先需要渲染光体的背面，并标记在远光边界前面的像素。然后计算在光体前面的像素数量。最后，着色标记的像素并在光体前面的像素后面。</p>
<h4 id="Mark-Pixels-标记像素">Mark Pixels&nbsp;标记像素</h4>
<p>在第一阶段，将标记在光体后面的像素标记在模板缓冲区中。为此，必须首先将模板缓冲区清零，然后使用以下设置配置管线状态：</p>
<ul>
<li>Bind only the vertex shader (no pixel shader is required)<br>
仅绑定顶点着色器（不需要像素着色器）</li>
<li>Bind only the depth/stencil buffer to the output merger stage (since no pixel shader is bound, there is no need for a color buffer)<br>
仅将深度/模板缓冲区绑定到输出合并阶段（因为未绑定像素着色器，所以不需要颜色缓冲区）</li>
<li>Rasterizer State: &nbsp;光栅化器状态：
<ul>
<li>Set cull mode to <strong>FRONT</strong> to render only the back faces of the light volume<br>
将剔除模式设置为 FRONT 以仅渲染光体的背面</li>
</ul>
</li>
<li>Depth/Stencil State: &nbsp;深度/模板状态
<ul>
<li>Enable depth testing&nbsp;启用深度测试</li>
<li>Disable depth writes&nbsp;禁用深度写入</li>
<li>Set the depth function to <strong>GREATER_EQUAL</strong><br>
将深度函数设置为 GREATER_EQUAL</li>
<li>Enable stencil operations<br>
启用模板操作</li>
<li>Set stencil reference to 1<br>
将模板参考值设置为 1</li>
<li>Set stencil function to <strong>ALWAYS</strong><br>
将模板函数设置为始终</li>
<li>Set stencil operation to <strong>REPLACE</strong> on depth pass.<br>
在深度pass上将模板操作设置为替换。</li>
</ul>
</li>
</ul>
<p>And render the light volume. The image below shows the effect of this operation.<br>
并渲染光体积。下面的图像显示了此操作的效果。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172010134.png" alt="Determine Lit Pixels Render back faces of light volume. Write to stencil on depth pass. 渲染轻体积的背面。在深度pass上写入模板。" loading='lazy'></p>
<p>光体的虚线被剔除，只渲染背面的多边形。绿色的体积显示模板缓冲区将被标记为模板参考值的位置。下一步是计算光体内的像素数量。</p>
<h4 id="Count-Pixels-计算像素">Count Pixels&nbsp;计算像素</h4>
<p>下一阶段是计算在前一阶段标记的像素数量以及位于光体内部的像素数量。这是通过渲染光体的正面并计算在前一阶段被标记的像素数量以及位于光体正面后面的像素数量来完成的。在这种情况下，管线状态应配置为：</p>
<ul>
<li>Bind only the vertex shader (no pixel shader is required)<br>
仅绑定顶点着色器（不需要像素着色器）</li>
<li>Bind only the depth/stencil buffer to the output merger stage (since no pixel shader is bound, there is no need for a color buffer)<br>
仅将深度/模板缓冲区绑定到输出合并阶段（因为未绑定像素着色器，所以不需要颜色缓冲区）</li>
<li>Configure the Rasterizer State:<br>
配置光栅化器状态：
<ul>
<li>Set cull mode to <strong>BACK</strong> to render only the front faces of the light volume<br>
将剔除模式设置为后向以仅渲染光体的前面</li>
</ul>
</li>
<li>Depth/Stencil State: &nbsp;深度/模板状态
<ul>
<li>Enable depth testing&nbsp;启用深度测试</li>
<li>Disable depth writes&nbsp;禁用深度写入</li>
<li>Set the depth function to <strong>LESS_EQUAL</strong><br>
将深度函数设置为 LESS_EQUAL</li>
<li>Enable stencil operations<br>
启用模板操作</li>
<li>Set stencil reference to 1<br>
将模板参考值设置为 1</li>
<li>Set stencil operations to <strong>KEEP</strong> (don’t modify the stencil buffer)<br>
将模板操作设置为 KEEP（不修改模板缓冲区）</li>
<li>Set stencil function to <strong>EQUAL</strong><br>
将模板函数设置为 EQUAL</li>
</ul>
</li>
</ul>
<p>通过遮挡像素查询再次渲染光体积，以计算通过深度和模板操作的像素数量。下图显示了此操作的效果。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172010012.png" alt="Render front faces of light volume. Count pixels that are marked and behind the front faces of the light volume. 渲染光体的前表面。计算标记的像素并位于光体前表面后面。" loading='lazy'></p>
<p>图像中的红色体积显示了在此阶段将被计入的像素。</p>
<p>如果光栅化的像素数量低于一定阈值，则可以跳过着色步骤。如果光栅化的像素数量高于一定阈值，则需要对像素进行着色。</p>
<p>Michiel 的演示中描述的一个步骤，但在这个实验中被跳过的是生成光影地图。像素查询的主要目的是跳过阴影地图的生成。由于在这个实验中我没有进行阴影贴图，所以我完全跳过了自己实现中的这一步骤（稍后将会展示）。</p>
<h3 id="Shade-Pixels-阴影像素">Shade Pixels&nbsp;阴影像素</h3>
<p>根据 Michiel 的方法，最后一步是对位于光体内的像素进行着色。为此，管线状态的配置应与计算像素阶段的管线配置相同，同时启用附加混合，绑定像素着色器，并将颜色缓冲附加到输出合并器阶段。</p>
<ul>
<li>
<p>Bind both vertex and pixel shaders<br>
绑定顶点和像素着色器</p>
</li>
<li>
<p>Bind depth/stencil and light accumulation buffer to the output merger stage<br>
将深度/模板和光积累缓冲区绑定到输出合并阶段</p>
</li>
<li>
<p>Configure the Rasterizer State:<br>
配置光栅化器状态：</p>
<ul>
<li>Set cull mode to <strong>BACK</strong> to render only the front faces of the light volume<br>
将剔除模式设置为后向以仅渲染光体的前面</li>
</ul>
</li>
<li>
<p>Depth/Stencil State: &nbsp;深度/模板状态</p>
<ul>
<li>Enable depth testing&nbsp;启用深度测试</li>
<li>Disable depth writes&nbsp;禁用深度写入</li>
<li>Set the depth function to <strong>LESS_EQUAL</strong><br>
将深度函数设置为 LESS_EQUAL</li>
<li>Enable stencil operations<br>
启用模板操作</li>
<li>Set stencil reference to 1<br>
将模板参考值设置为 1</li>
<li>Set stencil operations to <strong>KEEP</strong> (don’t modify the stencil buffer)<br>
将模板操作设置为 KEEP（不修改模板缓冲区）</li>
<li>Set stencil function to <strong>EQUAL</strong><br>
将模板函数设置为 EQUAL</li>
</ul>
</li>
<li>
<p>Blend State:&nbsp;混合状态：</p>
</li>
<li>
<p>Enable blend operations&nbsp;启用混合操作</p>
</li>
<li>
<p>Set source factor to <strong>ONE</strong><br>
将源因子设置为 ONE</p>
</li>
<li>
<p>Set destination factor to <strong>ONE</strong><br>
将目的地因子设置为 ONE</p>
</li>
<li>
<p>Set blend operation to <strong>ADD</strong><br>
将混合操作设置为 ADD</p>
</li>
</ul>
<p>The result should be that only the pixels that are contained within the light volume are shaded.<br>
结果应该是只有包含在光体内的像素才会被着色。</p>
<h2 id="Lighting-Pass-My-Implementation">Lighting Pass (My Implementation)</h2>
<p>光照pass（我的实现）</p>
<p>Michiel 演示中描述的光照pass存在的问题是，像素查询操作几乎肯定会导致停顿，因为 CPU 必须等待 GPU 查询结果返回。如果使用前一帧（或前 2 帧）的查询结果而不是依赖于当前帧的查询结果，可以避免停顿，这依赖于时间相干理论[15]。这将需要为每个光源创建多个查询对象，因为如果查询对象必须在多个帧之间持久存在，则无法重用查询对象。</p>
<p>由于我在我的实现中没有进行阴影贴图，因此没有明显需要执行 Michiel 演示中描述的像素遮挡查询，从而避免了由查询操作产生的潜在停顿。<br>
Michiel 演示中描述的方法的另一个问题是，如果眼睛在光体内部，则在计算像素和着色像素阶段不会计算或着色任何像素。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172010406.png" alt="Eye inside light volume When the eye is inside the light volume, the front faces of the light volume will be clipped by the view frustum. 当眼睛在光体内部时，光体的前表面将被视锥剪裁。" loading='lazy'></p>
<p>图像中显示的绿色体积代表在第一阶段标记在模板缓冲区中的像素。没有显示红色体积，因为光体的前表面被视锥体剪裁。我尝试通过禁用深度剪裁来解决这个问题，但这只能防止在观察者前面剪裁像素（眼睛后面的像素仍然被剪裁）。</p>
<p>To solve this problem, I reversed Michiel’s method:<br>
为了解决这个问题，我颠倒了米歇尔的方法：</p>
<ol>
<li>Clear stencil buffer to 1,<br>
清除模板缓冲区为 1，</li>
<li>Unmark pixels in front of the near light boundary,<br>
取消标记靠近光边界前面的像素，</li>
<li>Shade pixels that are in front of the far light boundary<br>
着色在远光边界前面的像素</li>
</ol>
<p>我将解释我的实现的最后两个步骤，并描述用于着色像素的方法。</p>
<h3 id="Unmark-Pixels-取消标记像素">Unmark Pixels&nbsp;取消标记像素</h3>
<p>在我的实现的第一阶段中，我们需要取消标记所有位于光的几何体积前面的像素。这确保了遮挡光体积的像素不会在下一阶段渲染。首先清除模板缓冲区以将所有像素标记为 1，并取消标记位于光体积前面的像素。管线状态的配置如下：</p>
<ul>
<li>Bind only the vertex shader (no pixel shader is required)<br>
仅绑定顶点着色器（不需要像素着色器）</li>
<li>Bind only the depth/stencil buffer to the output merger stage (since no pixel shader is bound, there is no need for a color buffer)<br>
仅将深度/模板缓冲区绑定到输出合并阶段（因为未绑定像素着色器，所以不需要颜色缓冲区）</li>
<li>Rasterizer State: &nbsp;光栅化器状态：
<ul>
<li>Set cull mode to <strong>BACK</strong> to render only the front faces of the light volume<br>
将剔除模式设置为后向以仅渲染光体的前面</li>
</ul>
</li>
<li>Depth/Stencil State: &nbsp;深度/模板状态
<ul>
<li>Enable depth testing&nbsp;启用深度测试</li>
<li>Disable depth writes&nbsp;禁用深度写入</li>
<li>Set the depth function to <strong>GREATER</strong><br>
将深度函数设置为 GREATER</li>
<li>Enable stencil operations<br>
启用模板操作</li>
<li>Set stencil function to <strong>ALWAYS</strong><br>
将模板函数设置为始终</li>
<li>Set stencil operation to <strong>DECR_SAT</strong> on depth pass.<br>
在深度pass上将模板操作设置为 DECR_SAT。</li>
</ul>
</li>
</ul>
<p>And render the light volume. The image below shows the result of this operation.<br>
然后渲染光体积。下面的图像显示了此操作的结果。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172010808.png" alt="Unmark pixels in the stencil buffer where the pixel is in front of the front faces of the light volume. 取消模板缓冲区中像素的标记，其中像素位于光体前面的正面。" loading='lazy'></p>
<p>将模板操作设置为 DECR_SAT 将在深度测试通过时将模板缓冲区中的值递减并夹紧到 0。绿色体积显示了模板缓冲区将被递减到 0 的位置。因此，如果眼睛在光体积内部，所有像素仍将在模板缓冲区中标记，因为光体积的前表面将被视锥体剪裁，没有像素将被取消标记。</p>
<p>在下一阶段，将对光体背面前的像素进行着色。</p>
<h3 id="Shade-Pixels-阴影像素-2">Shade Pixels&nbsp;阴影像素</h3>
<p>在这个阶段，那些既在光体后面的像素前面，又在上一帧中没有标记的像素将被着色。在这种情况下，管线状态的配置将如下所示：</p>
<ul>
<li>
<p>Bind both vertex and pixel shaders<br>
绑定顶点和像素着色器</p>
</li>
<li>
<p>Bind depth/stencil and light accumulation buffer to the output merger stage<br>
将深度/模板和光积累缓冲区绑定到输出合并阶段</p>
</li>
<li>
<p>Configure the Rasterizer State:<br>
配置光栅化器状态：</p>
<ul>
<li>Set cull mode to <strong>FRONT</strong> to render only the back faces of the light volume<br>
将剔除模式设置为 FRONT 以仅渲染光体的背面</li>
<li>Disable depth clipping&nbsp;禁用深度裁剪</li>
</ul>
</li>
<li>
<p>Depth/Stencil State: &nbsp;深度/模板状态</p>
<ul>
<li>Enable depth testing&nbsp;启用深度测试</li>
<li>Disable depth writes&nbsp;禁用深度写入</li>
<li>Set the depth function to <strong>GREATER_EQUAL</strong><br>
将深度函数设置为 GREATER_EQUAL</li>
<li>Enable stencil operations<br>
启用模板操作</li>
<li>Set stencil reference to 1<br>
将模板参考值设置为 1</li>
<li>Set stencil operations to <strong>KEEP</strong> (don’t modify the stencil buffer)<br>
将模板操作设置为 KEEP（不修改模板缓冲区）</li>
<li>Set stencil function to <strong>EQUAL</strong><br>
将模板函数设置为 EQUAL</li>
</ul>
</li>
<li>
<p>Blend State:&nbsp;混合状态：</p>
</li>
<li>
<p>Enable blend operations&nbsp;启用混合操作</p>
</li>
<li>
<p>Set source factor to <strong>ONE</strong><br>
将源因子设置为 ONE</p>
</li>
<li>
<p>Set destination factor to <strong>ONE</strong><br>
将目的地因子设置为 ONE</p>
</li>
<li>
<p>Set blend operation to <strong>ADD</strong><br>
将混合操作设置为 ADD</p>
</li>
</ul>
<p>您可能已经注意到，我还在光栅化器状态中禁用了深度裁剪。这样做可以确保如果光体的任何部分超出了远裁剪平面，它不会被裁剪。</p>
<p>The image below shows the result of this operation.<br>
下面的图像显示了此操作的结果。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172010630.png" alt="The pixels in front of the back faces of the light volume will be shaded. 光体后面的像素将被着色。" loading='lazy'></p>
<p>红色体积显示了在这个阶段将被着色的像素。即使观察者在光体内部，此实现也将正确着色像素。在第二阶段，只有那些在光体后面的背面前面且在前一阶段未标记的像素将被着色。</p>
<p>接下来，我将描述用于实现延迟光照pass的像素着色器。</p>
<h3 id="Pixel-Shader-像素着色器-3">Pixel Shader&nbsp;像素着色器</h3>
<p>像素着色器仅在上面描述的着色像素阶段期间绑定。它将从 G-Buffer中提取纹理数据，并使用它来使用在前向渲染部分中描述的相同光照模型对像素进行着色。</p>
<p>由于我们所有的光照计算都是在视图空间中执行的，因此我们需要计算当前像素的视图空间位置。</p>
<p>我们将使用屏幕空间位置和深度缓冲区中的值来计算当前像素的视图空间位置。为此，我们将使用 ClipToView 函数将裁剪空间坐标转换为视图空间，并使用 ScreenToView 函数将屏幕坐标转换为视图空间。</p>
<p>为了方便这些功能，我们需要知道屏幕尺寸和摄像机的逆投影矩阵，这些信息应该从应用程序传递给着色器的常量缓冲区中。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Parameters required to convert screen space coordinates to view space.</span></span><br><span class="line">cbuffer ScreenToViewParams : <span class="built_in">register</span>( b3 )</span><br><span class="line">{</span><br><span class="line">    float4x4 InverseProjection;</span><br><span class="line">    float2 ScreenDimensions;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>将屏幕空间坐标转换为裁剪空间，我们需要将屏幕空间坐标缩放和平移到裁剪空间，然后通过将裁剪空间坐标乘以投影矩阵的逆矩阵来将裁剪空间坐标转换为视图空间。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Convert clip space coordinates to view space</span></span><br><span class="line"><span class="function">float4 <span class="title">ClipToView</span><span class="params">( float4 clip )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// View space position.</span></span><br><span class="line">    float4 view = <span class="built_in">mul</span>( InverseProjection, clip );</span><br><span class="line">    <span class="comment">// Perspective projection.</span></span><br><span class="line">    view = view / view.w;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> view;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert screen space coordinates to view space.</span></span><br><span class="line"><span class="function">float4 <span class="title">ScreenToView</span><span class="params">( float4 screen )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Convert to normalized texture coordinates</span></span><br><span class="line">    float2 texCoord = screen.xy / ScreenDimensions;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Convert to clip space</span></span><br><span class="line">    float4 clip = <span class="built_in">float4</span>( <span class="built_in">float2</span>( texCoord.x, <span class="number">1.0f</span> - texCoord.y ) * <span class="number">2.0f</span> - <span class="number">1.0f</span>, screen.z, screen.w );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ClipToView</span>( clip );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>首先，我们需要通过屏幕尺寸来归一化屏幕坐标。这将把以范围([0…屏幕宽度], [0…屏幕高度])表示的屏幕坐标转换为范围([0…1], [0…1])。</p>
<p>在 DirectX 中，屏幕原点（0，0）位于屏幕的左上角，屏幕的 y 坐标从上到下递增。这与裁剪空间中的 y 坐标方向相反，因此我们需要翻转归一化屏幕空间中的 y 坐标，使其在范围内（[0…1]，[1…0]）。然后，我们需要将归一化屏幕坐标缩放 2 倍，使其在范围内（[0…2]，[2…0]），并将其移位-1，使其在范围内（[-1…1]，[1…-1]）。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172011370.png" alt="Converting screen space coordinates to clip space. 将屏幕空间坐标转换为裁剪空间。" loading='lazy'></p>
<p>现在我们有了当前像素的剪辑空间位置，我们可以使用 ClipToView 函数将其转换为视图空间。这是通过将剪辑空间坐标乘以相机投影矩阵的逆（第 195 行）并除以 w 分量来完成的，以消除透视投影（第 197 行）。</p>
<p>现在让我们在着色器中使用这个函数。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[earlydepthstencil]</span><br><span class="line"><span class="function">float4 <span class="title">PS_DeferredLighting</span><span class="params">( VertexShaderOutput IN )</span> : SV_Target</span></span><br><span class="line"><span class="function">{</span></span><br><span class="line">    <span class="comment">// Everything is in view space.</span></span><br><span class="line">    float4 eyePos = { <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> };</span><br><span class="line"></span><br><span class="line">    int2 texCoord = IN.position.xy;</span><br><span class="line">    <span class="type">float</span> depth = DepthTextureVS.<span class="built_in">Load</span>( <span class="built_in">int3</span>( texCoord, <span class="number">0</span> ) ).r;</span><br><span class="line"></span><br><span class="line">    float4 P = <span class="built_in">ScreenToView</span>( <span class="built_in">float4</span>( texCoord, depth, <span class="number">1.0f</span> ) );</span><br></pre></td></tr></tbody></table></figure>
<p>延迟光照像素着色器的输入结构与顶点着色器的输出相同，包括绑定到 SV_Position 系统值语义的位置参数。在像素着色器中使用时，绑定到 SV_Position 语义的参数的值将是当前正在渲染的像素的屏幕空间位置。我们可以使用这个值和深度缓冲区中的值来计算视图空间位置。</p>
<p>由于 G 缓冲纹理与屏幕具有相同的尺寸，因此我们可以使用 Texture2D.Load [16]方法从每个 G 缓冲纹理中提取纹素。Texture2D.Load 方法的纹理坐标是一个 int3，其中 x 和 y 分量是非规范化屏幕坐标中的 U 和 V 纹理坐标，z 分量是要采样的 mipmap 级别。在采样 G 缓冲纹理时，我们总是希望采样 mipmap 级别 0（最详细的 mipmap 级别）。从较低的 mipmap 级别采样会导致纹理显示为块状。如果没有为 G 缓冲纹理生成 mipmaps，则从较低的 mipmap 级别采样将返回黑色纹素。Texture2D.Load 方法在采样纹理时不执行任何纹理过滤，因此在使用线性过滤时比 Texture2D.Sample 方法更快。</p>
<p>一旦我们有屏幕空间位置和深度值，我们就可以使用 ScreenToView 函数将屏幕空间位置转换为视图空间。</p>
<p>在计算光照之前，我们需要从 G 缓冲纹理中采样其他组件。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View vector</span></span><br><span class="line">float4 V = <span class="built_in">normalize</span>( eyePos - P );</span><br><span class="line"></span><br><span class="line">float4 diffuse = DiffuseTextureVS.<span class="built_in">Load</span>( <span class="built_in">int3</span>( texCoord, <span class="number">0</span> ) );</span><br><span class="line">float4 specular = SpecularTextureVS.<span class="built_in">Load</span>( <span class="built_in">int3</span>( texCoord, <span class="number">0</span> ) );</span><br><span class="line">float4 N = NormalTextureVS.<span class="built_in">Load</span>( <span class="built_in">int3</span>( texCoord, <span class="number">0</span> ) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unpack the specular power from the alpha component of the specular color.</span></span><br><span class="line"><span class="type">float</span> specularPower = <span class="built_in">exp2</span>( specular.a * <span class="number">10.5f</span> );</span><br></pre></td></tr></tbody></table></figure>
<p>在第 179 行，从镜面颜色的 alpha pass中解压出镜面率，使用与在 G 缓冲pass中的镜面纹理中打包它所使用的操作的逆操作。</p>
<p>为了检索正确的光属性，我们需要知道光缓冲区中当前光的索引。为此，我们将在常量缓冲区中传递当前光的光索引。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cbuffer LightIndexBuffer : <span class="built_in">register</span>( b4 )</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// The index of the light in the Lights array.</span></span><br><span class="line">    uint LightIndex;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>从光列表中检索光属性并计算最终的阴影。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    Light light = Lights[LightIndex];</span><br><span class="line">    </span><br><span class="line">    Material mat = (Material)<span class="number">0</span>;</span><br><span class="line">    mat.DiffuseColor = diffuse;</span><br><span class="line">    mat.SpecularColor = specular;</span><br><span class="line">    mat.SpecularPower = specularPower;</span><br><span class="line"></span><br><span class="line">    LightingResult lit = (LightingResult)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ( light.Type )</span><br><span class="line">    {</span><br><span class="line">    <span class="keyword">case</span> DIRECTIONAL_LIGHT:</span><br><span class="line">        lit = <span class="built_in">DoDirectionalLight</span>( light, mat, V, P, N );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> POINT_LIGHT:</span><br><span class="line">        lit = <span class="built_in">DoPointLight</span>( light, mat, V, P, N );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SPOT_LIGHT:</span><br><span class="line">        lit = <span class="built_in">DoSpotLight</span>( light, mat, V, P, N );</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ( diffuse * lit.Diffuse ) + ( specular * lit.Specular );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>您可能会注意到，我们不需要像在正向渲染着色器中那样检查光是否已启用。如果光未启用，则应用程序不应渲染光体积。<br>
我们也不需要检查光是否在当前像素的范围内，因为像素着色器不应该在超出光范围的像素上调用。</p>
<p>光照函数已经在前向渲染部分进行了解释，所以这里不会再进行解释。</p>
<p>在第 203 行，漫反射和镜面项被合并并从着色器中返回。环境光和自发光项已经在光累积缓冲区中的 G 缓冲着色器中计算过了。启用了加法混合后，所有光照项将被正确求和以计算最终的阴影。</p>
<p>在最后一步，我们需要渲染透明物体。</p>
<h2 id="Transparent-Pass-透明pass">Transparent Pass&nbsp;透明pass</h2>
<p>透明pass用于延迟着色方式与启用了 alpha 混合的前向渲染方式相同。这里没有新信息可提供。我们将在稍后描述的结果部分反思透明pass的性能。</p>
<p>现在让我们来看看本文将解释的最终方式; Forward+。</p>
<h1>Forward+</h1>
<p>Forward+提升了常规的前向渲染，首先确定哪些光源在屏幕空间中重叠。在着色阶段，只有潜在重叠当前片元的光源需要考虑。我使用“潜在”一词，因为用于确定重叠光源的方式并不完全准确，稍后我会解释。</p>
<p>Forward+ 方式主要包括以下三个pass：</p>
<ol>
<li>Light culling&nbsp;光照剔除</li>
<li>Opaque pass&nbsp;不透明pass</li>
<li>Transparent pass&nbsp;透明pass</li>
</ol>
<p>在光照剔除过程中，场景中的每个光源都被排序到屏幕空间的瓦片中。</p>
<p>在不透明pass中，从光剔除pass生成的光列表用于计算不透明几何体的光照。在这个pass中，不需要考虑所有的灯光进行光照，只需要考虑之前被排序到当前片元屏幕空间瓦片中的灯光在计算光照时需要考虑。</p>
<p>透明pass类似于不透明pass，只是用于计算光照的光列表略有不同。我将在接下来的部分中解释不透明pass和透明pass的光列表之间的区别。</p>
<h2 id="Grid-Frustums-网格视锥体">Grid Frustums&nbsp;网格视锥体</h2>
<p>在进行光照剔除之前，我们需要计算用于将光源剔除到屏幕空间瓦片中的剔除视锥体。由于剔除视锥体是以视图空间表示的，因此只有在网格的尺寸发生变化（例如，屏幕调整大小）或瓦片的尺寸发生变化时，才需要重新计算。我将解释瓦片的视锥体平面是如何定义的。</p>
<p>屏幕被分成许多方形瓦片。我将所有屏幕瓦片称为光栅。我们需要为每个瓦片指定一个大小。该大小定义了单个瓦片的垂直和水平尺寸。瓦片大小不应该随意选择，而应该选择一个可以由 DirectX 计算着色器中的单个线程组计算的大小。线程组中的线程数应该是 64 的倍数（以利用现代 GPU 上可用的双 warp 调度程序），并且不能超过每个线程组的 1024 个线程。线程组的维度的可能候选者是：</p>
<ul>
<li>8×8 (64 threads per thread group)<br>
8×8（每个线程组 64 个线程）</li>
<li>16×16 (256 threads per thread group)<br>
16×16（每个线程组 256 个线程）</li>
<li>32×32 (1024 threads per thread group)<br>
32×32（每个线程组 1024 个线程）</li>
</ul>
<p>目前，让我们假设线程组的维度为 16×16 个线程。在这种情况下，我们光栅的每个瓦片都有 16×16 个屏幕像素的尺寸。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172021044.png" alt="Thread Groups 16×16 线程组" loading='lazy'></p>
<p>上面的图像显示了一个 16×16 线程组的部分网格。每个线程组由粗黑线分隔，线程组内的线程由细黑线分隔。用于光线剔除的瓦片也以相同的方式分隔。</p>
<p>如果我们以斜角观察瓦片，我们可以可视化需要计算的剔除视锥体。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172021598.png" alt="Tile Frustum 平铺截锥体" loading='lazy'></p>
<p>上图显示相机位置（眼睛）是截锥体的原点，瓦片的角点表示截锥体的角点。有了这些信息，我们可以计算出瓦片截锥体的平面。</p>
<p>视锥由六个平面组成，但为了执行光剔除，我们希望预先计算视锥的四个侧面平面。近和远视锥平面的计算将推迟到光剔除阶段。</p>
<p>计算左、右、上和下视锥体平面，我们将使用以下算法：</p>
<ol>
<li>Compute the four corner points of the current tile in screen space.<br>
计算屏幕空间中当前瓦片的四个角点。</li>
<li>Transform the screen space corner points to the far clipping plane in view space.<br>
将屏幕空间的角点转换到视图空间中的远裁剪平面。</li>
<li>Build the frustum planes from the eye position and two other corner points.<br>
从眼睛位置和另外两个角点构建视锥平面。</li>
<li>Store the computed frustum in a <strong>RWStructuredBuffer</strong>.<br>
将计算得到的视锥存储在 RWStructuredBuffer 中。</li>
</ol>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172022143.png" alt="Tile Corners Tile Corners 瓷砖角" loading='lazy'></p>
<p>如果我们知道位于平面上的三个点，那么可以计算出一个平面[18]。如果我们给瓦片的角点编号，如上图所示，我们可以使用视图空间中的眼睛位置和其他两个角点来计算视锥体平面。</p>
<p>例如，我们可以使用以下点来计算视锥体平面，假设顺时针顺序：</p>
<ul>
<li><strong>Left Plane</strong>: Eye, Bottom-Left (2), Top-Left (0)<br>
左平面：眼睛，左下角（2），左上角（0）</li>
<li><strong>Right Plane</strong>: Eye, Top-Right (1), Bottom-Right (3)<br>
右平面：眼睛，右上角（1），右下角（3）</li>
<li><strong>Top Plane</strong>: Eye, Top-Left (0), Top-Right (1)<br>
顶部平面：眼睛，左上角（0），右上角（1）</li>
<li><strong>Bottom Plane</strong>: Eye, Bottom-Right (3), Bottom-Left (2)<br>
底部平面：眼睛，右下角（3），左下角（2）</li>
</ul>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172022218.png" alt="Counter-Clockwise Winding Order 逆时针" loading='lazy'></p>
<p>如果我们知道了位于一个平面上的三个点，就可以知道这个平面的发现</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>n</mi><mo>=</mo><mo stretchy="false">(</mo><mi>B</mi><mo>−</mo><mi>A</mi><mo stretchy="false">)</mo><mo>×</mo><mo stretchy="false">(</mo><mi>C</mi><mo>−</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">n=(B−A)×(C−A)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span></span></p>
<p>如果n已被归一化，那么给出一个位于平面上方的点P，可以与法线点乘得出P到平面的距离(看不懂这里的可以去复习下从深度图重建片元世界空间坐标的内容)</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mo>=</mo><mi>n</mi><mo>⋅</mo><mi>P</mi></mrow><annotation encoding="application/x-tex">d=n⋅P
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span></span></span></span></span></p>
<p>这被称为平面的常法线形式[18]，也可以表示为</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>a</mi><mi>x</mi><mo>+</mo><mi>b</mi><mi>y</mi><mo>+</mo><mi>c</mi><mi>z</mi><mo>−</mo><mi>d</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">ax+by+cz−d=0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">cz</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>Where n==(a,b,c) and X=(x,y,z) given that X is a point that lies in the plane.</p>
<p>In the HLSL shader, we can define a plane as a unit normal n and the distance to the origin d.</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Plane</span></span><br><span class="line">{</span><br><span class="line">    float3 N;   <span class="comment">// Plane normal.</span></span><br><span class="line">    <span class="type">float</span>  d;   <span class="comment">// Distance to origin.</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>给定三个不共线的逆时针排列在平面上的点，我们可以使用 HLSL 中的 ComputePlane 函数计算平面。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute a plane from 3 noncollinear points that form a triangle.</span></span><br><span class="line"><span class="comment">// This equation assumes a right-handed (counter-clockwise winding order) </span></span><br><span class="line"><span class="comment">// coordinate system to determine the direction of the plane normal.</span></span><br><span class="line"><span class="function">Plane <span class="title">ComputePlane</span><span class="params">( float3 p0, float3 p1, float3 p2 )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Plane plane;</span><br><span class="line"></span><br><span class="line">    float3 v0 = p1 - p0;</span><br><span class="line">    float3 v2 = p2 - p0;</span><br><span class="line"></span><br><span class="line">    plane.N = <span class="built_in">normalize</span>( <span class="built_in">cross</span>( v0, v2 ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the distance to the origin using p0.</span></span><br><span class="line">    plane.d = <span class="built_in">dot</span>( plane.N, p0 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plane;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>一个截头锥体被定义为由四个平面构成的结构。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Compute a plane from 3 noncollinear points that form a triangle.</span></span><br><span class="line"><span class="comment">// This equation assumes a right-handed (counter-clockwise winding order) </span></span><br><span class="line"><span class="comment">// coordinate system to determine the direction of the plane normal.</span></span><br><span class="line"><span class="function">Plane <span class="title">ComputePlane</span><span class="params">( float3 p0, float3 p1, float3 p2 )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    Plane plane;</span><br><span class="line"></span><br><span class="line">    float3 v0 = p1 - p0;</span><br><span class="line">    float3 v2 = p2 - p0;</span><br><span class="line"></span><br><span class="line">    plane.N = <span class="built_in">normalize</span>( <span class="built_in">cross</span>( v0, v2 ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the distance to the origin using p0.</span></span><br><span class="line">    plane.d = <span class="built_in">dot</span>( plane.N, p0 );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> plane;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>为了预先计算网格视锥体，我们需要为网格中的每个瓦片调用一个计算着色器核心。例如，如果屏幕分辨率为 1280×720，光栅被划分为 16×16 个瓦片，我们需要计算 80×45（3,600）个视锥体。如果一个线程组包含 16×16（256）个线程，我们需要派发 5×2.8125 个线程组来计算所有的视锥体。当然，我们不能派发部分线程组，所以在派发计算着色器时，我们需要将其四舍五入到最接近的整数。在这种情况下，我们将派发 5×3（15）个线程组，每个线程组包含 16×16（256）个线程，在计算着色器中，我们必须确保简单地忽略超出屏幕边界的线程。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172040938.png" alt="Compute Frustums 计算视锥" loading='lazy'></p>
<p>上面的图像显示了将被调用以生成瓦片视锥的线程组，假设一个 16×16 线程组。粗黑线表示线程组边界，细黑线代表线程组中的线程。蓝色线程代表将用于计算瓦片视锥的线程，红色线程应该简单地跳过视锥瓦片计算，因为它们超出了屏幕的大小。</p>
<p>我们可以使用以下公式来确定派遣的维度：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="right center left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="bold">g</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">(</mo><mo stretchy="false">⌈</mo><mfrac><mi>w</mi><mi>B</mi></mfrac><mo stretchy="false">⌉</mo><mo separator="true">,</mo><mo stretchy="false">⌈</mo><mfrac><mi>h</mi><mi>B</mi></mfrac><mo stretchy="false">⌉</mo><mo separator="true">,</mo><mn>1</mn><mo fence="true">)</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="bold">G</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo fence="true">(</mo><mo stretchy="false">⌈</mo><mfrac><msub><mi mathvariant="bold">g</mi><mi>x</mi></msub><mi>B</mi></mfrac><mo stretchy="false">⌉</mo><mo separator="true">,</mo><mo stretchy="false">⌈</mo><mfrac><msub><mi mathvariant="bold">g</mi><mi>y</mi></msub><mi>B</mi></mfrac><mo stretchy="false">⌉</mo><mo separator="true">,</mo><mn>1</mn><mo fence="true">)</mo></mrow></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{rcl}\mathbf{g}(x,y,z) &amp; = &amp; \left(\lceil\frac{w}{B}\rceil,\lceil\frac{h}{B}\rceil,1\right) \\ \\ \mathbf{G}(x,y,z) &amp; = &amp; \left(\lceil\frac{\mathbf{g}_x}{B}\rceil,\lceil\frac{\mathbf{g}_y}{B}\rceil,1\right)\end{array}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.6501em;vertical-align:-1.5751em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0751em;"><span style="top:-4.1949em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf" style="margin-right:0.01597em;">g</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span><span style="top:-2.9949em;"><span class="pstrut" style="height:3em;"></span><span class="mord"></span></span><span style="top:-1.7849em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathbf">G</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5751em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0751em;"><span style="top:-4.1949em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-1.7849em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5751em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.0751em;"><span style="top:-4.1949em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.6954em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8801em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span><span style="top:-1.7849em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">(</span></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7572em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4461em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathbf mtight" style="margin-right:0.01597em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.016em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mopen">⌈</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8184em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.5073em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathbf mtight" style="margin-right:0.01597em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1645em;"><span style="top:-2.357em;margin-left:-0.016em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2819em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">⌉</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">1</span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">)</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5751em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p>
<p>有了这些信息，我们可以调度用于预计算网格视锥的计算着色器。</p>
<h2 id="Grid-Frustums-Compute-Shader-网格截锥体计算着色器">Grid Frustums Compute Shader 网格截锥体计算着色器</h2>
<p>默认情况下，计算着色器的线程组大小将为 16×16 个线程，但应用程序可以在着色器编译期间定义不同的块大小。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> BLOCK_SIZE</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> message( <span class="string">"BLOCK_SIZE undefined. Default to 16."</span>)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BLOCK_SIZE 16 <span class="comment">// should be defined by the application.</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></tbody></table></figure>
<p>我们将定义一个通用结构来存储常见的计算着色器输入变量。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">ComputeShaderInput</span></span><br><span class="line">{</span><br><span class="line">    uint3 groupID           : SV_GroupID;           <span class="comment">// 3D index of the thread group in the dispatch.</span></span><br><span class="line">    uint3 groupThreadID     : SV_GroupThreadID;     <span class="comment">// 3D index of local thread ID in a thread group.</span></span><br><span class="line">    uint3 dispatchThreadID  : SV_DispatchThreadID;  <span class="comment">// 3D index of global thread ID in the dispatch.</span></span><br><span class="line">    uint  groupIndex        : SV_GroupIndex;        <span class="comment">// Flattened local index of the thread within a thread group.</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>See <a target="_blank" rel="noopener" href="https://www.3dgep.com/forward-plus/#cite_10">[10]</a> for a list of the system value semantics that are available as inputs to a compute shader.<br>
参见[10]，列出可用作计算着色器输入的系统值语义。</p>
<p>除了 HLSL 提供的系统值之外，我们还需要知道当前调度中线程的总数和线程组的总数。不幸的是，HLSL 没有为这些属性提供系统值语义。我们将把所需的值存储在一个名为 DispatchParams 的常量缓冲区中。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Global variables</span></span><br><span class="line">cbuffer DispatchParams : <span class="built_in">register</span>( b4 )</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// Number of groups dispatched. (This parameter is not available as an HLSL system value!)</span></span><br><span class="line">    uint3   numThreadGroups;</span><br><span class="line">    <span class="comment">// uint padding // implicit padding to 16 bytes.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Total number of threads dispatched. (Also not available as an HLSL system value!)</span></span><br><span class="line">    <span class="comment">// Note: This value may be less than the actual number of threads executed </span></span><br><span class="line">    <span class="comment">// if the screen size is not evenly divisible by the block size.</span></span><br><span class="line">    uint3   numThreads;</span><br><span class="line">    <span class="comment">// uint padding // implicit padding to 16 bytes.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>numThreads 变量的值可用于确保调度中的线程不会超出屏幕范围，如前所述。</p>
<p>为了存储计算的网格视锥体的结果，我们还需要创建一个足够大的结构化缓冲区，以存储每个瓦片的一个视锥体。这个缓冲区将绑定到 out_Frustrum RWStructuredBuffer 变量，使用统一访问视图。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// View space frustums for the grid cells.</span></span><br><span class="line">RWStructuredBuffer&lt;Frustum&gt; out_Frustums : <span class="built_in">register</span>( u0 );</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Tile-Corners-in-Screen-Space-屏幕空间中的瓦片角点">Tile Corners in Screen Space 屏幕空间中的瓦片角点</h3>
<p>在计算着色器中，我们首先需要做的是使用调度中当前线程的全局 ID 确定瓦片视锥体角点的屏幕空间点。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A kernel to compute frustums for the grid</span></span><br><span class="line"><span class="comment">// This kernel is executed once per grid cell. Each thread</span></span><br><span class="line"><span class="comment">// computes a frustum for a grid cell.</span></span><br><span class="line">[<span class="built_in">numthreads</span>( BLOCK_SIZE, BLOCK_SIZE, <span class="number">1</span> )]</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CS_ComputeFrustums</span><span class="params">( ComputeShaderInput IN )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// View space eye position is always at the origin.</span></span><br><span class="line">    <span class="type">const</span> float3 eyePos = <span class="built_in">float3</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Compute the 4 corner points on the far clipping plane to use as the </span></span><br><span class="line">    <span class="comment">// frustum vertices.</span></span><br><span class="line">    float4 screenSpace[<span class="number">4</span>];</span><br><span class="line">    <span class="comment">// Top left point</span></span><br><span class="line">    screenSpace[<span class="number">0</span>] = <span class="built_in">float4</span>( IN.dispatchThreadID.xy * BLOCK_SIZE, <span class="number">-1.0f</span>, <span class="number">1.0f</span> );</span><br><span class="line">    <span class="comment">// Top right point</span></span><br><span class="line">    screenSpace[<span class="number">1</span>] = <span class="built_in">float4</span>( <span class="built_in">float2</span>( IN.dispatchThreadID.x + <span class="number">1</span>, IN.dispatchThreadID.y ) * BLOCK_SIZE, <span class="number">-1.0f</span>, <span class="number">1.0f</span> );</span><br><span class="line">    <span class="comment">// Bottom left point</span></span><br><span class="line">    screenSpace[<span class="number">2</span>] = <span class="built_in">float4</span>( <span class="built_in">float2</span>( IN.dispatchThreadID.x, IN.dispatchThreadID.y + <span class="number">1</span> ) * BLOCK_SIZE, <span class="number">-1.0f</span>, <span class="number">1.0f</span> );</span><br><span class="line">    <span class="comment">// Bottom right point</span></span><br><span class="line">    screenSpace[<span class="number">3</span>] = <span class="built_in">float4</span>( <span class="built_in">float2</span>( IN.dispatchThreadID.x + <span class="number">1</span>, IN.dispatchThreadID.y + <span class="number">1</span> ) * BLOCK_SIZE, <span class="number">-1.0f</span>, <span class="number">1.0f</span> );</span><br></pre></td></tr></tbody></table></figure>
<p>将全局线程 ID 转换为屏幕空间位置，我们只需乘以光栅中一个瓦片的大小。屏幕空间位置的 z 分量为-1，因为我使用的是右手坐标系，在视图空间中相机朝向-z 轴。如果您使用左手坐标系，应该将 z 分量设为 1。这样我们就得到了远裁剪平面上瓦片角点的屏幕空间位置。</p>
<h3 id="Tile-Corners-in-View-Space-在视图空间中的Tile角">Tile Corners in View Space 在视图空间中的Tile角</h3>
<p>接下来，我们需要使用关于延迟渲染像素着色器部分中描述的 ScreenToView 函数，将屏幕空间位置转换为视图空间。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">float3 viewSpace[<span class="number">4</span>];</span><br><span class="line"><span class="comment">// Now convert the screen space points to view space</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ )</span><br><span class="line">{</span><br><span class="line">    viewSpace[i] = <span class="built_in">ScreenToView</span>( screenSpace[i] ).xyz;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Compute-Frustum-Planes-计算视锥体平面">Compute Frustum Planes&nbsp;计算视锥体平面</h3>
<p>利用瓦片角的视图空间位置，我们可以构建视锥体平面。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Now build the frustum planes from the view space points</span></span><br><span class="line">Frustum frustum;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Left plane</span></span><br><span class="line">frustum.planes[<span class="number">0</span>] = <span class="built_in">ComputePlane</span>( eyePos, viewSpace[<span class="number">2</span>], viewSpace[<span class="number">0</span>] );</span><br><span class="line"><span class="comment">// Right plane</span></span><br><span class="line">frustum.planes[<span class="number">1</span>] = <span class="built_in">ComputePlane</span>( eyePos, viewSpace[<span class="number">1</span>], viewSpace[<span class="number">3</span>] );</span><br><span class="line"><span class="comment">// Top plane</span></span><br><span class="line">frustum.planes[<span class="number">2</span>] = <span class="built_in">ComputePlane</span>( eyePos, viewSpace[<span class="number">0</span>], viewSpace[<span class="number">1</span>] );</span><br><span class="line"><span class="comment">// Bottom plane</span></span><br><span class="line">frustum.planes[<span class="number">3</span>] = <span class="built_in">ComputePlane</span>( eyePos, viewSpace[<span class="number">3</span>], viewSpace[<span class="number">2</span>] );</span><br></pre></td></tr></tbody></table></figure>
<h3 id="Store-Grid-Frustums-存储网格视锥体">Store Grid Frustums&nbsp;存储网格视锥体</h3>
<p>最后，我们需要将截头锥体写入全局内存。我们必须小心，不要访问超出分配的截头锥体缓冲区边界的数组元素。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// Store the computed frustum in global memory (if our thread ID is in bounds of the grid).</span></span><br><span class="line">    <span class="keyword">if</span> ( IN.dispatchThreadID.x &lt; numThreads.x &amp;&amp; IN.dispatchThreadID.y &lt; numThreads.y )</span><br><span class="line">    {</span><br><span class="line">        uint index = IN.dispatchThreadID.x + ( IN.dispatchThreadID.y * numThreads.x );</span><br><span class="line">        out_Frustums[index] = frustum;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>现在我们有预先计算的网格视锥体，我们可以在光遮挡计算着色器中使用它们。</p>
<h2 id="Light-Culling-光照剔除">Light Culling&nbsp;光照剔除</h2>
<p>在 Forward+渲染方式的下一步中，使用在前一节中计算的网格视锥体来剔除光源。只需要在应用程序开始时计算一次网格视锥体，或者在屏幕尺寸或瓦片大小发生变化时重新计算。但是，光源剔除阶段必须在每一帧中发生，即摄像机移动、光源位置移动或场景中的对象发生变化影响深度缓冲区内容时。这些事件中的任何一个都可能发生，因此通常每一帧都执行光源剔除是安全的。</p>
<p>The basic algorithm for performing light culling is as follows:<br>
执行光源剔除的基本算法如下：</p>
<ol>
<li>Compute the min and max depth values in view space for the tile<br>
计算视图空间中瓦片的最小和最大深度值</li>
<li>Cull the lights and record the lights into a light index list<br>
剔除灯光并将灯光记录到灯光索引列表中</li>
<li>Copy the light index list into global memory<br>
将灯光索引列表复制到全局内存中</li>
</ol>
<h3 id="Compute-Min-Max-Depth-Values-计算最小-最大深度值">Compute Min/Max Depth Values  计算最小/最大深度值</h3>
<p>算法的第一步是计算光栅每个瓦片的最小和最大深度值。最小和最大深度值将用于计算我们剔除视锥体的近平面和远平面。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172046593.png" alt="Min and Max Depth per Tile 每块瓷砖的最小和最大深度（不透明）" loading='lazy'></p>
<p>上面的图像显示了一个示例场景。蓝色物体代表场景中的不透明物体。黄色物体代表光源，阴影灰色区域代表从每个瓦片的最小和最大深度值计算出的瓦片视锥体。绿色线条代表光栅的瓦片边界。从上到下，瓦片编号为 1-7，不透明物体编号为 1-5，灯光编号为 1-4。</p>
<p>第一个瓦片的最大深度值为 1（在投影剪辑空间中），因为有一些像素未被不透明几何体覆盖。在这种情况下，裁剪视锥体非常大，可能包含不影响几何体的灯光。例如，灯光 1 包含在瓦片 1 内，但灯光 1 不影响任何几何体。在几何边界处，裁剪视锥体可能非常大，可能包含不影响任何几何体的灯光。</p>
<p>在瓦片 2 中，最小和最大深度值相同，因为物体 2 直接面向摄像机并填充整个瓦片。当我们执行光体积的实际裁剪时，这不会成为问题。</p>
<p>物体 3 完全遮挡了光 3，因此在着色任何片元时将不予考虑。</p>
<p>上述图像显示了不透明几何体每个瓦片的最小和最大深度值。对于透明几何体，我们只能裁剪在最大深度平面后面的光体积，但必须考虑所有在所有不透明几何体前面的光源。原因是在执行深度预处理步骤以生成用于确定每个瓦片的最小和最大深度的深度纹理时，我们不能将透明几何体渲染到深度缓冲区中。如果这样做，那么我们将无法正确照亮位于透明几何体后面的不透明几何体。这个问题的解决方案在一篇名为“平铺式前向着色”的文章中有所描述，作者是 Markus Billeter、Ola Olsson 和 Ulf Assarsson。在光照剔除计算着色器中，将生成两个光列表。第一个光列表仅包含影响不透明几何体的光源。第二个光列表仅包含可能影响透明几何体的光源。在对不透明几何体执行最终着色时，我将发送第一个列表，而在渲染透明几何体时，我将发送第二个列表到片元着色器。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172047516.png" alt="Depth Bounds for Opaque and Transparent Geometry 不透明和透明几何的深度边界" loading='lazy'></p>
<p>在讨论光剔除计算着色器之前，我将讨论在计算着色器中用于构建光列表的方法。</p>
<h3 id="Light-List-Data-Structure-光列表数据结构">Light List Data Structure 光列表数据结构</h3>
<p>用于存储每个瓦片光列表的数据结构在 Ola Olsson 和 Ulf Assarsson 的论文“平铺着色”中有描述。Ola 和 Ulf 描述了一个分为两部分的数据结构。第一部分是光栅，它是一个存储光索引列表中值的偏移量和计数的二维网格。这种方式类似于索引缓冲区，它引用顶点缓冲区中的顶点索引。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172047259.png" alt="Light List Data Structure 轻量级列表数据结构" loading='lazy'></p>
<p>光栅的大小基于用于光剔除的屏幕瓦片数量。光索引列表的大小基于每个瓦片预期的平均重叠光数。例如，对于分辨率为 1280×720 且瓦片大小为 16×16 的屏幕，结果是 80×45（3,600）的光栅。假设每个瓦片平均有 200 个光，这将需要一个包含 720,000 个索引的光索引列表。每个光索引占用 4 个字节（对于 32 位无符号整数），因此光列表将消耗 2.88 MB 的 GPU 内存。由于我们需要为透明和不透明几何体分别列出列表，这将总共消耗 5.76 MB。尽管 200 个光可能是对每个瓦片平均重叠光数的过高估计，但存储使用并不过分。</p>
<p>生成光栅和光索引列表，首先在计算着色器中生成一个组共享的光索引列表。使用全局光索引列表计数器来跟踪当前索引进入全局光索引列表。全局光索引计数器是原子地递增的，以便没有两个线程组可以使用全局光索引列表中的相同范围。一旦线程组在全局光索引列表中“保留”了空间，组共享的光索引列表就会被复制到全局光索引列表中。</p>
<p>The following pseudo code demonstrates this technique.<br>
以下伪代码演示了这种方式。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">CullLights</span><span class="params">( L, C, G, I )</span></span></span><br><span class="line"><span class="function">    Input: A set L of n lights.</span></span><br><span class="line"><span class="function">    Input: A counter C of the current index into the global light index list.</span></span><br><span class="line"><span class="function">    Input: A <span class="number">2</span>D grid G of index offset and count in the global light index list.</span></span><br><span class="line"><span class="function">    Input: A list I of global light index list.</span></span><br><span class="line"><span class="function">    Output: A <span class="number">2</span>D grid G with the current tiles offset and light count.</span></span><br><span class="line"><span class="function">    Output: A list I with the current tiles overlapping light indices appended to it.</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="number">1.</span>  let t be the index of the current tile  ;</span> t is the <span class="number">2</span>D index of the tile.</span><br><span class="line"><span class="number">2.</span>  let i be a local light index list       ; i is a local light index list.</span><br><span class="line"><span class="number">3.</span>  let f &lt;- <span class="built_in">Frustum</span>(t)                     ; f is the frustum <span class="keyword">for</span> the current tile.</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>  <span class="keyword">for</span> l in L                      ; Iterate the lights in the light list.</span><br><span class="line"><span class="number">5.</span>      <span class="function"><span class="keyword">if</span> <span class="title">Cull</span><span class="params">( l, f )</span>             </span>; Cull the light against the tile frustum.</span><br><span class="line"><span class="number">6.</span>          <span class="built_in">AppendLight</span>( l, i )     ; Append the light to the local light index list.</span><br><span class="line">                    </span><br><span class="line"><span class="number">7.</span>  c &lt;- <span class="built_in">AtomicInc</span>( C, i.count )    ; Atomically increment the current index of the </span><br><span class="line">                                    ; global light index list by the number of lights</span><br><span class="line">                                    ; overlapping the current tile <span class="keyword">and</span> store the</span><br><span class="line">                                    ; original index in c.</span><br><span class="line">            </span><br><span class="line"><span class="number">8.</span>  <span class="built_in">G</span>(t) &lt;- ( c, i.count )          ; Store the offset <span class="keyword">and</span> light count in the light grid.</span><br><span class="line">        </span><br><span class="line"><span class="number">9.</span>  <span class="built_in">I</span>(c) &lt;- i                       ; Store the local light index list into the global </span><br><span class="line">                                    ; light index list.</span><br></pre></td></tr></tbody></table></figure>
<p>在前三行中，将网格中当前瓦片的索引定义为 t。本地光索引列表定义为 i，用于对当前瓦片执行光剔除的瓦片视锥体定义为 f。</p>
<p>第 4、5 和 6 行循环遍历全局光列表，并根据当前切片的裁剪视锥体对光源进行裁剪。如果光源在视锥体内，则将光源索引添加到本地光源索引列表中。</p>
<p>在第 7 行，全局光源索引列表中的当前索引会增加本地光源索引列表中包含的光源数量。在增加之前，全局光源索引列表计数器的原始值会存储在本地计数器变量 c 中。</p>
<p>在第 8 行，光栅 G 会使用当前切片的偏移量和计数值更新全局光源索引列表。</p>
<p>最后，在第 9 行，将本地光索引列表复制到全局光索引列表中。</p>
<p>然后，在片元着色器中使用光栅和全局光索引列表执行最终着色。</p>
<h2 id="Frustum-Culling-视锥体裁剪">Frustum Culling&nbsp;视锥体裁剪</h2>
<p>对光体执行截锥体裁剪，将呈现两种截锥体裁剪方法：</p>
<ol>
<li><strong>Frustum-Sphere</strong> culling for point lights<br>
点光源的截锥-球体裁剪</li>
<li><strong>Frustum-Cone</strong> culling for spot lights<br>
聚光灯锥体裁剪</li>
</ol>
<p>球体的裁剪算法相对简单。锥体的裁剪算法稍微复杂一些。首先我会描述视锥-球体算法，然后我会描述锥体裁剪算法。</p>
<h3 id="Frustum-Sphere-Culling-视锥-球体裁剪">Frustum-Sphere Culling&nbsp;视锥-球体裁剪</h3>
<p>我们已经在前一节中看到了修剪视锥的定义，标题为计算网格视锥。一个球被定义为视图空间中的一个中心点和一个半径。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Sphere</span></span><br><span class="line">{</span><br><span class="line">    float3 c;   <span class="comment">// Center point.</span></span><br><span class="line">    <span class="type">float</span>  r;   <span class="comment">// Radius.</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>如果一个球完全包含在平面的负半空间中，则认为球在平面“内部”。如果一个球完全包含在任何视锥平面的“内部”，则它在视锥之外。</p>
<p>我们可以使用以下公式来确定球体与平面之间的有符号距离[18]：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>l</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi mathvariant="bold">c</mi><mo>⋅</mo><mi mathvariant="bold">n</mi><mo fence="true">)</mo></mrow><mo>−</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">l=\left(\mathbf{c}\cdot\mathbf{n}\right)-d
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathbf">c</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">n</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span></span></p>
<p>l是从球体到平面距离，c是球体中心点，n是平面法线，d是从平面到视点距离</p>
<p>如果l小于-r（为球体半径），那么我们可以认为球体被平面的一半完整包裹</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check to see if a sphere is fully behind (inside the negative halfspace of) a plane.</span></span><br><span class="line"><span class="comment">// Source: Real-time collision detection, Christer Ericson (2005)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SphereInsidePlane</span><span class="params">( Sphere sphere, Plane plane )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dot</span>( plane.N, sphere.c ) - plane.d &lt; -sphere.r;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后我们可以迭代应用 SphereInsidePlane 函数来确定球体是否包含在裁剪视锥体内部。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check to see of a light is partially contained within the frustum.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SphereInsideFrustum</span><span class="params">( Sphere sphere, Frustum frustum, <span class="type">float</span> zNear, <span class="type">float</span> zFar )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First check depth</span></span><br><span class="line">    <span class="comment">// Note: Here, the view vector points in the -Z axis so the </span></span><br><span class="line">    <span class="comment">// far depth value will be approaching -infinity.</span></span><br><span class="line">    <span class="keyword">if</span> ( sphere.c.z - sphere.r &gt; zNear || sphere.c.z + sphere.r &lt; zFar )</span><br><span class="line">    {</span><br><span class="line">        result = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then check frustum planes</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span> &amp;&amp; result; i++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">SphereInsidePlane</span>( sphere, frustum.planes[i] ) )</span><br><span class="line">        {</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>由于球是在视图空间中描述的，我们可以根据其 z 位置和到近和远裁剪平面的距离快速确定是否应该根据其 z 位置和到近和远裁剪平面的距离来剔除光线。如果球要么完全在近裁剪平面的前面，要么完全在远裁剪平面的后面，那么光线可以被丢弃。否则，我们必须检查光线是否在剔除视锥体的范围内。</p>
<p>SphereInsideFrustum 假定一个右手坐标系，摄像机朝向负 z 轴。在这种情况下，远平面逼近负无穷大，因此我们必须检查球体是否更远（在负方向上小于）。对于左手坐标系，应该在第 268 行交换 zNear 和 zFar 变量。</p>
<h3 id="Frustum-Cone-Culling-锥体截锥体裁剪">Frustum-Cone Culling&nbsp;锥体截锥体裁剪</h3>
<p>为了执行截锥体剔除，我将使用 Christer Ericson 在其名为“实时碰撞检测”的书中描述的技术 [18]。圆锥体可以通过其尖端 T、归一化方向向量 d、圆锥体高度 h 和底面半径 r 来定义</p>
<p><img src="https://www.3dgep.com/wp-content/uploads/2015/09/Cone-Plane-Intersection1.png" alt="Cone-Plane Intersection" loading='lazy'></p>
<p>在 HLSL 中，锥台被定义为</p>
<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Cone</span><br><span class="line">{</span><br><span class="line">    float3 T;   <span class="comment">// Cone tip.</span></span><br><span class="line">    <span class="type">float</span>  h;   <span class="comment">// Height of the cone.</span></span><br><span class="line">    float3 d;   <span class="comment">// Direction of the cone.</span></span><br><span class="line">    <span class="type">float</span>  r;   <span class="comment">// bottom radius of the cone.</span></span><br><span class="line">};</span><br></pre></td></tr></tbody></table></figure>
<p>要测试一个圆锥体是否完全包含在平面的负半空间中，只需要测试两个点。</p>
<ol>
<li>The tip T of the cone</li>
<li>The point Q that is on the base of the cone that is farthest away from the plane in the direction of n</li>
</ol>
<p>If both of these points are contained in the negative half-space of any of the frustum planes, then the cone can be culled.<br>
如果这两点都包含在任何锥台平面的负半空间中，则可以剔除锥体。</p>
<p>为了确定在 n 方向上距离平面最远的点 Q，我们将计算一个平行但相反的中间向量 m到 n 并垂直于 d</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi mathvariant="bold">m</mi><mo>=</mo><mrow><mo fence="true">(</mo><mi mathvariant="bold">n</mi><mo>×</mo><mi mathvariant="bold">d</mi><mo fence="true">)</mo></mrow><mo>×</mo><mi mathvariant="bold">d</mi></mrow><annotation encoding="application/x-tex">\mathbf{m}=\left(\mathbf{n}\times\mathbf{d}\right)\times\mathbf{d}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathbf">m</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord mathbf">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathbf">d</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathbf">d</span></span></span></span></span></p>
<p>Q是通过从尖端 T沿锥轴 d 步进距离 h获得的，然后沿圆锥体的底面距平面 −m 的正半空间的距离为 r倍。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>T</mi><mo>+</mo><mi>h</mi><mi mathvariant="bold">d</mi><mo>−</mo><mi>r</mi><mi mathvariant="bold">m</mi></mrow><annotation encoding="application/x-tex">Q=T+h\mathbf{d}-r\mathbf{m}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">h</span><span class="mord mathbf">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathbf">m</span></span></span></span></span></p>
<p>如果 n×d为零，则锥轴 d 平行于平面法线 n 和 m  将是零向量。这种特殊情况不需要专门处理，因为在这种情况下，方程简化为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>Q</mi><mo>=</mo><mi>T</mi><mo>+</mo><mi>h</mi><mi mathvariant="bold">d</mi><mo>−</mo><mi>r</mi><mi mathvariant="bold">m</mi></mrow><annotation encoding="application/x-tex">Q=T+h\mathbf{d}-r\mathbf{m}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal">h</span><span class="mord mathbf">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.4444em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathbf">m</span></span></span></span></span></p>
<p>导致需要测试的正确点。</p>
<p>计算出 T  和 Q 后，我们可以测试这两个点是否位于平面的负半空间中。如果是的话，我们就可以得出结论，光线可以被剔除。为了测试一个点是否在平面的负半空间中，我们可以使用以下方程：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>l</mi><mo>=</mo><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>X</mi><mo stretchy="false">)</mo><mo>−</mo><mi>d</mi></mrow><annotation encoding="application/x-tex">l=(n⋅X)−d
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span></span></span></span></span></p>
<p>其中l 是点到平面的有符号距离，X 是要测试的点。如果 l 为负，则该点包含在平面的负半空间中。<br>
在 HLSL 中，函数 PointInsidePlane 用于测试一个点是否在平面的负半空间内。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check to see if a point is fully behind (inside the negative halfspace of) a plane.</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">PointInsidePlane</span><span class="params">( float3 p, Plane plane )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dot</span>( plane.N, p ) - plane.d &lt; <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>而 ConeInsidePlane 函数用于测试锥体是否完全包含在平面的负半空间中。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Check to see if a cone if fully behind (inside the negative halfspace of) a plane.</span></span><br><span class="line"><span class="comment">// Source: Real-time collision detection, Christer Ericson (2005)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ConeInsidePlane</span><span class="params">( Cone cone, Plane plane )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="comment">// Compute the farthest point on the end of the cone to the positive space of the plane.</span></span><br><span class="line">    float3 m = <span class="built_in">cross</span>( <span class="built_in">cross</span>( plane.N, cone.d ), cone.d );</span><br><span class="line">    float3 Q = cone.T + cone.d * cone.h - m * cone.r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The cone is in the negative halfspace of the plane if both</span></span><br><span class="line">    <span class="comment">// the tip of the cone and the farthest point on the end of the cone to the </span></span><br><span class="line">    <span class="comment">// positive halfspace of the plane are both inside the negative halfspace </span></span><br><span class="line">    <span class="comment">// of the plane.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">PointInsidePlane</span>( cone.T, plane ) &amp;&amp; <span class="built_in">PointInsidePlane</span>( Q, plane );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>ConeInsideFrustum 函数用于测试锥体是否包含在裁剪截锥内。如果锥体在截锥内部，则此函数将返回 true；如果锥体完全包含在任何裁剪平面的负半空间中，则返回 false。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ConeInsideFrustum</span><span class="params">( Cone cone, Frustum frustum, <span class="type">float</span> zNear, <span class="type">float</span> zFar )</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="type">bool</span> result = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    Plane nearPlane = { <span class="built_in">float3</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span> ), -zNear };</span><br><span class="line">    Plane farPlane = { <span class="built_in">float3</span>( <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> ), zFar };</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First check the near and far clipping planes.</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">ConeInsidePlane</span>( cone, nearPlane ) || <span class="built_in">ConeInsidePlane</span>( cone, farPlane ) )</span><br><span class="line">    {</span><br><span class="line">        result = <span class="literal">false</span>;</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Then check frustum planes</span></span><br><span class="line">    <span class="keyword">for</span> ( <span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span> &amp;&amp; result; i++ )</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">ConeInsidePlane</span>( cone, frustum.planes[i] ) )</span><br><span class="line">        {</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>首先，我们检查圆锥体是否被近裁剪平面或远裁剪平面剪裁。否则，我们必须检查视锥体的四个平面。如果圆锥体在任何裁剪平面的负半空间中，该函数将返回 false。</p>
<p>现在我们可以将这些组合起来定义光照剔除计算着色器。</p>
<h2 id="Light-Culling-Compute-Shader-光照剔除计算着色器">Light Culling Compute Shader 光照剔除计算着色器</h2>
<p>光照剔除计算着色器的目的是更新片元着色器所需的全局光索引列表和光栅格。每帧需要更新两个列表：</p>
<ol>
<li>Light index list for opaque geometry<br>
不透明几何的光索引列表</li>
<li>Light index list for transparent geometry<br>
透明几何的光索引列表</li>
</ol>
<p>为了区分 HLSL 计算着色器中的这两个列表，我将使用前缀“o_”来指代不透明列表，“t_”来指代透明列表。这两个列表将在光剔除计算着色器中更新。</p>
<p>首先，我们将声明光照剔除计算着色器所需的资源。</p>
<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The depth from the screen space texture.</span></span><br><span class="line">Texture2D DepthTextureVS : register( t3 );</span><br><span class="line"><span class="comment">// Precomputed frustums for the grid.</span></span><br><span class="line">StructuredBuffer&lt;Frustum&gt; in_Frustums : register( t9 );</span><br></pre></td></tr></tbody></table></figure>
<p>为了读取深度预pass生成的深度值，结果深度纹理需要被发送到光照剔除计算着色器。DepthTextureVS 纹理包含深度预pass的结果。</p>
<p>in_Frustums 是在计算 frustums 计算着色器中计算并在标题为 Grid Frustums Compute Shader 的部分中描述的结构化缓冲区。</p>
<p>我们还需要跟踪全局光索引列表中的索引。</p>
<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Global counter for current index into the light index list.</span></span><br><span class="line"><span class="comment">// "o_" prefix indicates light lists for opaque geometry while </span></span><br><span class="line"><span class="comment">// "t_" prefix indicates light lists for transparent geometry.</span></span><br><span class="line">RWStructuredBuffer&lt;<span class="type">uint</span>&gt; o_LightIndexCounter : register( u1 );</span><br><span class="line">RWStructuredBuffer&lt;<span class="type">uint</span>&gt; t_LightIndexCounter : register( u2 );</span><br></pre></td></tr></tbody></table></figure>
<p>o_LightIndexCounter 是不透明几何体全局光索引列表的当前索引，t_LightIndexCounter 是透明几何体全局光索引列表的当前索引。</p>
<p>尽管光指数计数器是 RWStructuredBuffer 类型，但这些缓冲区仅在索引 0 处包含单个无符号整数。</p>
<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Light index lists and light grids.</span></span><br><span class="line">RWStructuredBuffer&lt;<span class="type">uint</span>&gt; o_LightIndexList : register( u3 );</span><br><span class="line">RWStructuredBuffer&lt;<span class="type">uint</span>&gt; t_LightIndexList : register( u4 );</span><br><span class="line">RWTexture2D&lt;uint2&gt; o_LightGrid : register( u5 );</span><br><span class="line">RWTexture2D&lt;uint2&gt; t_LightGrid : register( u6 );</span><br></pre></td></tr></tbody></table></figure>
<p>光索引列表存储为一维无符号整数数组，但光栅存储为二维纹理，其中每个“纹素”是一个二分量无符号整数向量。光栅纹理使用 R32G32_UINT 格式创建。</p>
<p>为了存储每个瓦片的最小和最大深度值，我们需要声明一些组共享变量来存储最小和最大深度值。原子递增函数将被用来确保只有一个线程组中的线程可以更改最小/最大深度值，但不幸的是，着色器模型 5.0 不提供用于浮点值的原子函数。为了规避这个限制，深度值将被存储为无符号整数在组共享内存中，这将被原子地比较和更新每个线程。</p>
<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">groupshared <span class="type">uint</span> uMinDepth;</span><br><span class="line">groupshared <span class="type">uint</span> uMaxDepth;</span><br></pre></td></tr></tbody></table></figure>
<p>由于用于执行裁剪的视锥体将是组中所有线程的相同视锥体，因此保留组中所有线程的视锥体的副本是有意义的。只有组中的线程 0 需要从全局内存缓冲区复制视锥体，我们还减少了每个线程所需的本地寄存器内存量。</p>
<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupshared Frustum GroupFrustum;</span><br></pre></td></tr></tbody></table></figure>
<p>我们还需要声明组共享变量来创建临时光列表。我们将需要一个用于不透明和透明几何体的单独列表。</p>
<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Opaque geometry light lists.</span></span><br><span class="line">groupshared <span class="type">uint</span> o_LightCount;</span><br><span class="line">groupshared <span class="type">uint</span> o_LightIndexStartOffset;</span><br><span class="line">groupshared <span class="type">uint</span> o_LightList[<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Transparent geometry light lists.</span></span><br><span class="line">groupshared <span class="type">uint</span> t_LightCount;</span><br><span class="line">groupshared <span class="type">uint</span> t_LightIndexStartOffset;</span><br><span class="line">groupshared <span class="type">uint</span> t_LightList[<span class="number">1024</span>];</span><br></pre></td></tr></tbody></table></figure>
<p>LightCount 将跟踪与当前瓷砖视锥相交的灯光数量。</p>
<p>LightIndexStartOffset 是全局光索引列表中的偏移量。此索引将被写入光栅，并在将本地光索引列表复制到全局光索引列表时用作起始偏移量。</p>
<p>本地光指数列表将允许我们在单个瓦片中存储多达 1024 个灯光。这个最大值几乎永远不会达到（至少不应该！）。请记住，当我们为全局光列表分配存储空间时，我们考虑了每个瓦片平均 200 个灯光。有可能有一些瓦片包含超过 200 个灯光（只要不超过 1024 个），也有一些瓦片包含少于 200 个灯光，但我们预计平均每个瓦片约有 200 个灯光。如前所述，每个瓦片平均 200 个灯光的估计可能是一个过高的估计，但由于 GPU 内存对于这个项目并不是一个限制性约束，我可以在估计上保守一些。<br>
更新本地光计数器和光列表，我将定义一个名为 AppendLight 的辅助函数。不幸的是，我还没有弄清楚如何将组共享变量作为参数传递给函数，所以现在我将定义同一函数的两个版本。函数的一个版本用于更新不透明几何体的光索引列表，另一个版本用于透明几何体。</p>
<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add the light to the visible light list for opaque geometry.</span></span><br><span class="line"><span class="type">void</span> o_AppendLight( <span class="type">uint</span> lightIndex )</span><br><span class="line">{</span><br><span class="line">    <span class="type">uint</span> <span class="keyword">index</span>; <span class="comment">// Index into the visible lights array.</span></span><br><span class="line">    InterlockedAdd( o_LightCount, <span class="number">1</span>, <span class="keyword">index</span> );</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">index</span> &lt; <span class="number">1024</span> )</span><br><span class="line">    {</span><br><span class="line">        o_LightList[<span class="keyword">index</span>] = lightIndex;</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add the light to the visible light list for transparent geometry.</span></span><br><span class="line"><span class="type">void</span> t_AppendLight( <span class="type">uint</span> lightIndex )</span><br><span class="line">{</span><br><span class="line">    <span class="type">uint</span> <span class="keyword">index</span>; <span class="comment">// Index into the visible lights array.</span></span><br><span class="line">    InterlockedAdd( t_LightCount, <span class="number">1</span>, <span class="keyword">index</span> );</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">index</span> &lt; <span class="number">1024</span> )</span><br><span class="line">    {</span><br><span class="line">        t_LightList[<span class="keyword">index</span>] = lightIndex;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>如果您正在阅读此内容，并且知道如何将组共享变量作为参数传递给 HSLS 中的函数，请在下方评论中留下您的解决方案。（请不要猜测。在建议之前确保您的解决方案有效）。</p>
<p>InterlockedAdd 函数确保组共享的灯计数变量一次只能由一个线程更新。这样我们就避免了多个线程同时尝试增加组共享的灯计数时可能发生的竞争条件。</p>
<p>在递增之前存储在索引本地变量中的光计数值，用于更新组共享光索引列表中的光索引。</p>
<p>计算每个瓦片的最小和最大深度范围的方法取自于 2011 年 Johan Andersson 的演示文稿“战地 3 中的 DirectX 11 渲染” [3] 和 Ola Olsson 与 Ulf Assarsson 的“平铺着色” [5]。</p>
<p>在光剔除计算着色器中，我们将首先读取当前线程的深度值。线程组中的每个线程将仅为当前线程采样深度缓冲区一次，因此组中的所有线程将为单个瓦片采样所有深度值。</p>
<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Implementation of light culling compute shader is based on the presentation</span></span><br><span class="line"><span class="comment">// "DirectX 11 Rendering in Battlefield 3" (2011) by Johan Andersson, DICE.</span></span><br><span class="line"><span class="comment">// Retrieved from: http://www.slideshare.net/DICEStudio/directx-11-rendering-in-battlefield-3</span></span><br><span class="line"><span class="comment">// Retrieved: July 13, 2015</span></span><br><span class="line"><span class="comment">// And "Forward+: A Step Toward Film-Style Shading in Real Time", Takahiro Harada (2012)</span></span><br><span class="line"><span class="comment">// published in "GPU Pro 4", Chapter 5 (2013) Taylor &amp; Francis Group, LLC.</span></span><br><span class="line">[numthreads( BLOCK_SIZE, BLOCK_SIZE, <span class="number">1</span> )]</span><br><span class="line"><span class="type">void</span> CS_main( ComputeShaderInput IN )</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// Calculate min &amp; max depth in threadgroup / tile.</span></span><br><span class="line">    int2 texCoord = IN.dispatchThreadID.xy;</span><br><span class="line">    <span class="type">float</span> fDepth = DepthTextureVS.Load( int3( texCoord, <span class="number">0</span> ) ).r;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint</span> uDepth = asuint( fDepth );</span><br></pre></td></tr></tbody></table></figure>
<p>由于我们只能对整数执行原子操作，在第 100 行，我们将浮点深度的位重新解释为无符号整数。由于我们期望深度图中的所有深度值都存储在范围[0…1]内（即所有正深度值），因此将浮点数重新解释为整数仍然允许我们正确地对这些值执行比较。只要我们不尝试对无符号整数深度值执行任何算术运算，我们应该能够获得正确的最小值和最大值。</p>
<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( IN.groupIndex == <span class="number">0</span> ) <span class="comment">// Avoid contention by other threads in the group.</span></span><br><span class="line">{</span><br><span class="line">    uMinDepth = <span class="number">0xffffffff</span>;</span><br><span class="line">    uMaxDepth = <span class="number">0</span>;</span><br><span class="line">    o_LightCount = <span class="number">0</span>;</span><br><span class="line">    t_LightCount = <span class="number">0</span>;</span><br><span class="line">    GroupFrustum = in_Frustums[IN.groupID.x + ( IN.groupID.y * numThreadGroups.x )];</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">GroupMemoryBarrierWithGroupSync();</span><br></pre></td></tr></tbody></table></figure>
<p>由于我们正在设置组共享变量，组中只需要一个线程来设置它们。实际上，如果我们不将这些变量的写入限制在组中的单个线程上，HLSL 编译器将生成竞争条件错误。</p>
<p>为了确保组中的每个线程在计算着色器中达到相同的点，我们调用 GroupMemoryBarrierWithGroupSync 函数。这确保了对组共享内存的任何写操作已经完成，并且组中所有线程的线程执行都已经达到了这一点。</p>
<p>接下来，我们将确定当前瓦片的最小和最大深度值。</p>
<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InterlockedMin( uMinDepth, uDepth );</span><br><span class="line">InterlockedMax( uMaxDepth, uDepth );</span><br><span class="line"></span><br><span class="line">GroupMemoryBarrierWithGroupSync();</span><br></pre></td></tr></tbody></table></figure>
<p>InterlockedMin 和 InterlockedMax 方法用于根据当前线程深度值原子更新 uMinDepth 和 uMaxDepth 组共享变量。</p>
<p>我们再次需要使用 GroupMemoryBarrierWithGroupSync 函数，以确保所有对组共享内存的写操作都已提交，并且组中的所有线程都已到达计算着色器中的此点。</p>
<p>在找到当前瓦片的最小和最大深度值之后，我们可以将无符号整数重新解释为浮点数，以便我们可以使用它来计算当前瓦片的视空间裁剪平面。</p>
<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> fMinDepth = asfloat( uMinDepth );</span><br><span class="line"><span class="type">float</span> fMaxDepth = asfloat( uMaxDepth );</span><br><span class="line"></span><br><span class="line"><span class="comment">// Convert depth values to view space.</span></span><br><span class="line"><span class="type">float</span> minDepthVS = ClipToView( float4( <span class="number">0</span>, <span class="number">0</span>, fMinDepth, <span class="number">1</span> ) ).z;</span><br><span class="line"><span class="type">float</span> maxDepthVS = ClipToView( float4( <span class="number">0</span>, <span class="number">0</span>, fMaxDepth, <span class="number">1</span> ) ).z;</span><br><span class="line"><span class="type">float</span> nearClipVS = ClipToView( float4( <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> ) ).z;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clipping plane for minimum depth value </span></span><br><span class="line"><span class="comment">// (used for testing lights within the bounds of opaque geometry).</span></span><br><span class="line">Plane minPlane = { float3( <span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span> ), -minDepthVS };</span><br></pre></td></tr></tbody></table></figure>
<p>在第 118 行，最小和最大深度值作为无符号整数需要重新解释为浮点值，以便可以用来计算视图空间中的正确点。</p>
<p>视图空间深度值是使用 ScreenToView 函数计算的，并提取视图空间中位置的 z 分量。我们只需要这些值来计算视图空间中的近裁剪面和远裁剪面，因此我们只需要知道与观察者的距离。</p>
<p>在为透明几何体剔除光源时，我们不希望使用深度图中的最小深度值。相反，我们将使用摄像机的近裁剪面来裁剪光源。在这种情况下，我们将使用 nearClipVS 值，即到摄像机近裁剪面的距离。</p>
<p>由于我使用右手坐标系，相机指向视图空间中的负 z 轴，因此最小深度裁剪平面是使用指向负 z 方向的法线 n 计算的轴，到原点 d 的距离为 -minDepth。我们可以通过使用平面的常量正规形式来验证这是正确的：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo stretchy="false">(</mo><mi mathvariant="bold">n</mi><mo>⋅</mo><mi>X</mi><mo stretchy="false">)</mo><mo>−</mo><mi>d</mi><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">(\mathbf{n}\cdot{X})-d=0
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathbf">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span></span></p>
<p>通过代入n=(0,0,-1), X=(x,y,z)，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>d</mi><mo>=</mo><mo>−</mo><msub><mi>z</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">d=-z_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7333em;vertical-align:-0.15em;"></span><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable rowspacing="0.16em" columnalign="right center left" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mrow><mo fence="true">(</mo><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo separator="true">,</mo><mi>z</mi><mo stretchy="false">)</mo><mo fence="true">)</mo></mrow><mo>−</mo><mo stretchy="false">(</mo><mo>−</mo><msub><mi>z</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>0</mn><mi>x</mi><mo>+</mo><mn>0</mn><mi>y</mi><mo>+</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>z</mi><mo>−</mo><mo stretchy="false">(</mo><mo>−</mo><msub><mi>z</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>z</mi><mo>−</mo><mo stretchy="false">(</mo><mo>−</mo><msub><mi>z</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub><mo stretchy="false">)</mo></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mi>z</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><msub><mi>z</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>z</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mo lspace="0em" rspace="0em">=</mo></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><msub><mi>z</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mstyle></mtd></mtr></mtable><annotation encoding="application/x-tex">\begin{array}{rcl}\left((0,0,-1)\cdot(x,y,z)\right)-(-z_{min})&amp;=&amp;0\\0x+0y+(-1)z-(-z_{min})&amp;=&amp;0\\(-1)z-(-z_{min})&amp;=&amp;0\\-z&amp;=&amp;-z_{min}\\z&amp;=&amp;z_{min}\end{array}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:6em;vertical-align:-2.75em;"></span><span class="mord"><span class="mtable"><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-r"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mclose">)</span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">0</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span><span style="top:-0.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span><span style="top:-0.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mrel">=</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.25em;"><span style="top:-5.41em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.81em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span><span style="top:-0.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.044em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:2.75em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span></span></span></span></span></span></span></p>
<p>这意味着 (0,0,zmin) 是裁剪平面上的最小深度点。</p>
<figure class="highlight glsl"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Cull lights</span></span><br><span class="line"><span class="comment">// Each thread in a group will cull 1 light until all lights have been culled.</span></span><br><span class="line"><span class="keyword">for</span> ( <span class="type">uint</span> i = IN.groupIndex; i &lt; NUM_LIGHTS; i += BLOCK_SIZE * BLOCK_SIZE )</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span> ( Lights[i].Enabled )</span><br><span class="line">    {</span><br><span class="line">        Light light = Lights[i];</span><br></pre></td></tr></tbody></table></figure>
<p>如果线程组中的每个线程同时检查全局灯光列表中的一个灯光，那么我们可以在第 132 行定义的 for 循环的每次迭代中检查 16×16 (256) 个灯光。循环以 i=groupIndex 开始对于循环的每次迭代， i = groupIndex 以及 i 递增， BLOCK_SIZE×BLOCK_SIZE BLOCK_SIZE × BLOCK_SIZE 。这意味着对于 BLOCK_SIZE=16 BLOCK_SIZE = 16 ，线程组中的每个线程将检查每 256 个灯，直到检查完所有灯为止。</p>
<ul>
<li><strong>Thread 0 checks</strong>: { 0, 256, 512, 768, … }<br>
线程 0 检查：{ 0, 256, 512, 768, … }</li>
<li><strong>Thread 1 checks</strong>: { 1, 257, 513, 769, … }<br>
线程 1 检查：{1, 257, 513, 769, …}</li>
<li><strong>Thread 2 checks</strong>: { 2, 258, 514, 770, … }<br>
线程 2 检查：{2, 258, 514, 770, …}</li>
<li><strong>…</strong></li>
<li><strong>Thread 255 checks</strong>: { 255, 511, 767, 1023, … }<br>
线程 255 检查：{255, 511, 767, 1023, …}</li>
</ul>
<p>For 10,000 lights, the for loop only needs 40 iterations (per thread) to check all lights for a tile.<br>
对于 10,000 个灯光，for 循环只需要 40 次迭代（每个线程）来检查一个瓦片上的所有灯光。</p>
<p>First we’ll check point lights using the <strong>SphereInsideFrustum</strong> function that was defined earlier.<br>
首先，我们将使用之前定义的 SphereInsideFrustum 函数来检查点光源。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> ( light.Type )</span><br><span class="line">{</span><br><span class="line"><span class="keyword">case</span> POINT_LIGHT:</span><br><span class="line">{</span><br><span class="line">    Sphere sphere = { light.PositionVS.xyz, light.Range };</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">SphereInsideFrustum</span>( sphere, GroupFrustum, nearClipVS, maxDepthVS ) )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Add light to light list for transparent geometry.</span></span><br><span class="line">        <span class="built_in">t_AppendLight</span>( i );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">SphereInsidePlane</span>( sphere, minPlane ) )</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Add light to light list for opaque geometry.</span></span><br><span class="line">            <span class="built_in">o_AppendLight</span>( i );</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>在第 142 行，使用光的位置和范围定义了一个球体。</p>
<p>首先，我们检查光是否在瓦片视锥体内，使用摄像机的近裁剪平面和从深度缓冲区读取的最大深度。如果光体积在这个范围内，它将被添加到透明几何体的光索引列表中。</p>
<p>要检查光是否应该被添加到不透明几何体的全局光索引列表中，我们只需要检查之前在第 128 行定义的最小深度裁剪平面。如果光在透明几何体的裁剪视锥体内并且在最小深度裁剪平面的前面，则将光的索引添加到不透明几何体的光索引列表中。</p>
<p>接下来，我们将检查聚光灯。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> SPOT_LIGHT:</span><br><span class="line">{</span><br><span class="line">    <span class="type">float</span> coneRadius = <span class="built_in">tan</span>( <span class="built_in">radians</span>( light.SpotlightAngle ) ) * light.Range;</span><br><span class="line">    Cone cone = { light.PositionVS.xyz, light.Range, light.DirectionVS.xyz, coneRadius };</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">ConeInsideFrustum</span>( cone, GroupFrustum, nearClipVS, maxDepthVS ) )</span><br><span class="line">    {</span><br><span class="line">        <span class="comment">// Add light to light list for transparent geometry.</span></span><br><span class="line">        <span class="built_in">t_AppendLight</span>( i );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( !<span class="built_in">ConeInsidePlane</span>( cone, minPlane ) )</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Add light to light list for opaque geometry.</span></span><br><span class="line">            <span class="built_in">o_AppendLight</span>( i );</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="keyword">break</span>;</span><br></pre></td></tr></tbody></table></figure>
<p>检查圆锥体几乎与检查球体相同，因此我在这里不会详细介绍。聚光锥体底部的半径未与光一起存储，因此需要为 ConeInsideFrustum 函数计算。要计算圆锥体底部的半径，我们可以使用聚光角的正切乘以圆锥体的高度。</p>
<p>最后，我们需要检查方向灯。这绝对是这个功能中最容易的部分。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">case</span> DIRECTIONAL_LIGHT:</span><br><span class="line">        {</span><br><span class="line">            <span class="comment">// Directional lights always get added to our light list.</span></span><br><span class="line">            <span class="comment">// (Hopefully there are not too many directional lights!)</span></span><br><span class="line">            <span class="built_in">t_AppendLight</span>( i );</span><br><span class="line">            <span class="built_in">o_AppendLight</span>( i );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// Wait till all threads in group have caught up.</span></span><br><span class="line"><span class="built_in">GroupMemoryBarrierWithGroupSync</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>没有可靠的方法来筛选定向光源，因此如果我们遇到定向光源，我们别无选择，只能将其索引添加到光源索引列表中。</p>
<p>确保线程组中的所有线程都已将其光线记录到组共享的光线索引列表中，我们将调用 GroupMemoryBarrierWithGroupSync 函数来同步组中的所有线程。</p>
<p>在将所有未被剔除的光线添加到组共享的光线索引列表之后，我们需要将其复制到全局光线索引列表中。首先，我们将更新全局光线索引列表计数器。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update global memory with visible light buffer.</span></span><br><span class="line"><span class="comment">// First update the light grid (only thread 0 in group needs to do this)</span></span><br><span class="line"><span class="keyword">if</span> ( IN.groupIndex == <span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// Update light grid for opaque geometry.</span></span><br><span class="line">    <span class="built_in">InterlockedAdd</span>( o_LightIndexCounter[<span class="number">0</span>], o_LightCount, o_LightIndexStartOffset );</span><br><span class="line">    o_LightGrid[IN.groupID.xy] = <span class="built_in">uint2</span>( o_LightIndexStartOffset, o_LightCount );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update light grid for transparent geometry.</span></span><br><span class="line">    <span class="built_in">InterlockedAdd</span>( t_LightIndexCounter[<span class="number">0</span>], t_LightCount, t_LightIndexStartOffset );</span><br><span class="line">    t_LightGrid[IN.groupID.xy] = <span class="built_in">uint2</span>( t_LightIndexStartOffset, t_LightCount );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">GroupMemoryBarrierWithGroupSync</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>我们将再次使用 InterlockedAdd 函数，将全局光线索引列表计数器增加已追加到组共享光线索引列表中的光线数量。在第 194 行和 198 行，光栅将使用全局光线索引列表的偏移量和光线计数进行更新。</p>
<p>为了避免竞态条件，只有线程组中的第一个线程将用于更新全局内存。</p>
<p>在第 201 行，必须再次同步线程组中的所有线程，然后我们才能更新全局光索引列表。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Update global memory with visible light buffer.</span></span><br><span class="line"><span class="comment">// First update the light grid (only thread 0 in group needs to do this)</span></span><br><span class="line"><span class="keyword">if</span> ( IN.groupIndex == <span class="number">0</span> )</span><br><span class="line">{</span><br><span class="line">    <span class="comment">// Update light grid for opaque geometry.</span></span><br><span class="line">    <span class="built_in">InterlockedAdd</span>( o_LightIndexCounter[<span class="number">0</span>], o_LightCount, o_LightIndexStartOffset );</span><br><span class="line">    o_LightGrid[IN.groupID.xy] = <span class="built_in">uint2</span>( o_LightIndexStartOffset, o_LightCount );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update light grid for transparent geometry.</span></span><br><span class="line">    <span class="built_in">InterlockedAdd</span>( t_LightIndexCounter[<span class="number">0</span>], t_LightCount, t_LightIndexStartOffset );</span><br><span class="line">    t_LightGrid[IN.groupID.xy] = <span class="built_in">uint2</span>( t_LightIndexStartOffset, t_LightCount );</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="built_in">GroupMemoryBarrierWithGroupSync</span>();</span><br></pre></td></tr></tbody></table></figure>
<p>更新不透明和透明的全局光索引列表，我们将允许所有线程使用类似于之前在 132-183 行上显示的迭代光列表的方法，将单个索引写入光索引列表。</p>
<p>在这一点上，光栅和全局光索引列表都包含了供像素着色器使用的必要数据，以执行最终着色。</p>
<h2 id="Final-Shading-最终着色-2">Final Shading&nbsp;最终着色</h2>
<p>Forward+渲染方式的最后部分是最终着色。这种方法与在标题为前向渲染-像素着色器的部分讨论的标准前向渲染方式没有什么不同，只是我们不再通过整个全局光列表进行循环，而是使用在光剔除阶段生成的光索引列表。</p>
<p>除了在标准前向渲染部分中描述的属性之外，Forward+像素着色器还需要获取在光照剔除阶段生成的光索引列表和光网格。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StructuredBuffer&lt;uint&gt; LightIndexList : <span class="built_in">register</span>( t9 );</span><br><span class="line">Texture2D&lt;uint2&gt; LightGrid : <span class="built_in">register</span>( t10 );</span><br></pre></td></tr></tbody></table></figure>
<p>在渲染不透明几何体时，必须注意为不透明几何体绑定光索引列表和光网格；在渲染透明几何体时，为透明几何体绑定光索引列表和光网格。当然，这似乎是显而易见的，但最终着色像素着色器的唯一区别因素是绑定到像素着色器阶段的光索引列表和光网格。</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">[earlydepthstencil]</span><br><span class="line"><span class="function">float4 <span class="title">PS_main</span><span class="params">( VertexShaderOutput IN )</span> : SV_TARGET</span></span><br><span class="line"><span class="function">{</span></span><br><span class="line">    <span class="comment">// Compute ambient, emissive, diffuse, specular, and normal</span></span><br><span class="line">    <span class="comment">// similar to standard forward rendering.</span></span><br><span class="line">    <span class="comment">// That code is omitted here for brevity.</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Get the index of the current pixel in the light grid.</span></span><br><span class="line">    uint2 tileIndex = <span class="built_in">uint2</span>( <span class="built_in">floor</span>(IN.position.xy / BLOCK_SIZE) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the start position and offset of the light in the light index list.</span></span><br><span class="line">    uint startOffset = LightGrid[tileIndex].x;</span><br><span class="line">    uint lightCount = LightGrid[tileIndex].y;</span><br><span class="line"></span><br><span class="line">    LightingResult lit = (LightingResult)<span class="number">0</span>; <span class="comment">// DoLighting( Lights, mat, eyePos, P, N );</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> ( uint i = <span class="number">0</span>; i &lt; lightCount; i++ )</span><br><span class="line">    {</span><br><span class="line">        uint lightIndex = LightIndexList[startOffset + i];</span><br><span class="line">        Light light = Lights[lightIndex];</span><br><span class="line"></span><br><span class="line">        LightingResult result = (LightingResult)<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> ( light.Type )</span><br><span class="line">        {</span><br><span class="line">        <span class="keyword">case</span> DIRECTIONAL_LIGHT:</span><br><span class="line">        {</span><br><span class="line">            result = <span class="built_in">DoDirectionalLight</span>( light, mat, V, P, N );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> POINT_LIGHT:</span><br><span class="line">        {</span><br><span class="line">            result = <span class="built_in">DoPointLight</span>( light, mat, V, P, N );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SPOT_LIGHT:</span><br><span class="line">        {</span><br><span class="line">            result = <span class="built_in">DoSpotLight</span>( light, mat, V, P, N );</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        lit.Diffuse += result.Diffuse;</span><br><span class="line">        lit.Specular += result.Specular;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    diffuse *= <span class="built_in">float4</span>( lit.Diffuse.rgb, <span class="number">1.0f</span> ); <span class="comment">// Discard the alpha value from the lighting calculations.</span></span><br><span class="line">    specular *= lit.Specular;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">float4</span>( ( ambient + emissive + diffuse + specular ).rgb, alpha * mat.Opacity );</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>大部分像素着色器的代码与前向渲染像素着色器的代码相同，因此为简洁起见在此省略。主要概念显示在第 298 行，其中从屏幕空间位置计算出光栅格中的瓦片索引。使用瓦片索引，从光栅格中在第 301 行和 302 行读取起始偏移和光计数。</p>
<p>在定义在第 306 行的 for 循环中，循环遍历光计数并从光索引列表中读取光的索引，然后使用该索引从全局光列表中检索光。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172106940.jpeg" alt="Forward+ with 10,000 lights Forward+ 与 10,000 个灯光" loading='lazy'></p>
<p>Now let’s see how the performance of the various methods compare.<br>
现在让我们看看各种方法的性能如何比较。</p>
<h1>Experiment Setup and Performance Results  实验设置和性能结果</h1>
<p>为了衡量各种渲染方式的性能，我在 NVIDIA GeForce GTX 680 GPU 上使用了 Crytek Sponza 场景[11]，屏幕分辨率为 1280×720。摄像机靠近世界原点，灯光被动画化以围绕世界原点旋转。</p>
<p>我使用两种场景测试了每种渲染方式：</p>
<ol>
<li>Large lights with a range of 35-40 units<br>
具有 35-40 个单位范围的大灯</li>
<li>Small lights with a range of 1-2 units<br>
1-2 个单位范围内的小灯光</li>
</ol>
<p>在场景中放置几个（2-3 个）大灯是一个现实的情景（例如主光、补光和背光[25]）。这些灯光可能是投射阴影的灯光，用来营造氛围。在屏幕上放置许多（超过 5 个）大灯并不一定是一个现实的情景，但我想看看在使用大面积、填充屏幕的灯光时各种方式是如何扩展的。</p>
<p>在游戏中使用许多小灯光是一个更为现实的情景。许多小灯光可以用来模拟区域光或反射光效果，类似于全局光照算法的效果，通常只能通过光照图或光探针来模拟，如“前向渲染”部分所述。</p>
<p>尽管演示支持定向光，但我没有测试使用定向光进行渲染的性能。定向光是大面积填充屏幕的灯光，类似于具有 35-40 单位范围的灯光（第一个情景）。</p>
<p>在这两种情况下，灯光是随机放置在场景的边界内的。 Sponza 场景被缩小，使其边界在 X 轴和 Z 轴上约为 30 个单位，在 Y 轴上约为 15 个单位。<br>
每个图表显示一组曲线，代表渲染方式的各个阶段。曲线的横轴代表场景中灯光的数量，纵轴代表以毫秒为单位的运行时间。每个图表还显示了最小和最大阈值。最小阈值显示为图表中的绿色水平线，代表理想帧率为每秒 60 帧（FPS）或 16.6 毫秒。最大阈值显示为图表中的红色水平线，代表最低可接受的帧率为每秒 30 帧（FPS）或 33.3 毫秒。</p>
<h2 id="Forward-Rendering-Performance-前向渲染性能">Forward Rendering Performance  前向渲染性能</h2>
<p>让我们首先分析使用大灯光的前向渲染方式的性能。</p>
<h3 id="Large-Lights-大灯">Large Lights&nbsp;大灯</h3>
<p>下面的图表显示了使用大灯光的前向渲染方式的性能结果。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172111076.png" alt="Forward Rendering (Light Range: 35-40 Units)前向渲染（光照范围：35-40 单位）" loading='lazy'></p>
<p>该图显示了前向渲染方式的两个主要阶段。紫色曲线显示了不透明pass，深红色曲线显示了透明pass。橙色线显示了渲染场景的总时间。</p>
<p>如图所示，渲染不透明几何体需要最长的时间，并且随着灯光数量的增加呈指数增长。渲染透明几何体的时间也呈指数增长，但场景中的透明几何体要比不透明几何体少得多，因此增长看起来更为渐进。</p>
<p>即使使用非常大的灯光，标准前向渲染可以渲染 64 个动态灯光，同时保持帧速率低于 30 FPS 的最大阈值。超过 512 个灯光后，帧时间变得无法测量。</p>
<p>由此我们可以得出结论，如果场景中包含超过 64 个大型可见光源，您可能需要考虑使用不同于前向渲染的渲染方式。</p>
<h3 id="Small-Lights-小灯">Small Lights&nbsp;小灯</h3>
<p>正向渲染在场景包含许多小灯时表现更好。在这种情况下，渲染方式可以处理两倍多的灯光，同时仍保持可接受的性能。超过 1024 个灯光后，帧时间变得如此之高，不再值得测量。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172111675.png" alt="Forward Rendering (Light Range: 1-2 Units) 前向渲染（光照范围：1-2 单位）" loading='lazy'></p>
<p>我们再次看到，大部分时间都花在渲染不透明几何体上，这并不令人意外。大灯和小灯的趋势相似，但使用小灯时，我们可以创建两倍多的灯光，同时实现可接受的帧速率。</p>
<p>接下来我将分析延迟渲染方式的性能。</p>
<h2 id="Deferred-Rendering-Performance-延迟渲染性能">Deferred Rendering Performance  延迟渲染性能</h2>
<p>同样的实验被重复进行，但这次使用了延迟渲染方式。让我们首先分析使用大屏幕填充灯光的性能。</p>
<h3 id="Large-Lights-大灯-2">Large Lights&nbsp;大灯</h3>
<p>下面的图表显示了使用大灯光的延迟渲染的性能结果。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172111037.png" alt="Deferred Rending (Large Lights)延迟渲染（大灯光）" loading='lazy'></p>
<p>使用延迟渲染渲染大型灯光，与前向渲染相比，效果仅略有改善。由于渲染透明几何体使用与前向渲染方式完全相同的代码路径，因此使用前向渲染与延迟渲染渲染透明几何体的性能几乎相同。如预期的那样，在渲染透明几何体时没有性能优势。</p>
<p>使用延迟渲染渲染不透明几何体的边际性能优势主要是由于前向渲染在遮挡几何体上执行的冗余光照计算数量减少。使用深度预pass可以减轻前向渲染时执行的冗余光照计算，从而允许在执行昂贵的光照计算之前拒绝片元。延迟渲染隐式受益于早期 z 测试和前向渲染期间未执行的模板操作。</p>
<h3 id="Small-Lights-小灯-2">Small Lights&nbsp;小灯</h3>
<p>下面的图表显示了使用小灯光进行延迟渲染的性能结果。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172111821.png" alt="Deferred Rending (Small Lights)延迟渲染（小灯光）" loading='lazy'></p>
<p>图表显示，延迟渲染能够渲染 512 个小型动态光源，同时仍保持可接受的帧率。在这种情况下，渲染透明几何体的时间远远超过了渲染不透明几何体的时间。如果只渲染不透明对象，那么延迟渲染方式能够渲染 2048 个光源，同时保持在低于最低可接受的 60 FPS 阈值以下的帧率。渲染透明几何体在大约 700 个光源后远远超过了最大阈值。</p>
<h2 id="Forward-Plus-Performance-Forward-性能">Forward Plus Performance&nbsp;Forward+性能</h2>
<p>同样的实验再次使用平铺的前向渲染进行了重复。首先，我们将分析使用大光源的性能特征。</p>
<h3 id="Large-Lights-大灯-3">Large Lights&nbsp;大灯</h3>
<p>下面的图表显示了使用大场景灯光的平铺前向渲染的性能结果。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172111402.png" alt="Forward Plus (Large Lights)" loading='lazy'></p>
<p>图表显示，瓷砖式前向渲染不适合渲染具有许多大光源的场景。在场景中渲染 512 个铺满屏幕的光源会导致问题，因为演示仅考虑每个瓷砖平均有 200 个光源。使用 512 个大光源，超过了 200 个光源的平均值，许多瓷砖简单地变黑。</p>
<p>使用大光源，光源剔除阶段从未超过 1 毫秒，但不透明pass和透明pass很快超过了最大帧速率阈值 30 FPS。</p>
<h3 id="Small-Lights-小灯-3">Small Lights&nbsp;小灯</h3>
<p>该图表显示了使用小光源的瓷砖式前向渲染的性能。</p>
<p><img src="https://www.3dgep.com/wp-content/uploads/2015/09/Forward-Plus-Small-Lights1.png" alt="Forward Plus (Small Lights)" loading='lazy'></p>
<p>前向加真正在使用许多小灯光时发挥作用。在这种情况下，我们看到光剔除阶段（橙线）是渲染方式的主要瓶颈。即使有超过 16,000 个灯光，渲染不透明（蓝线）和透明（紫线）几何体都低于实现所需帧速率 60 FPS 的最低阈值。大部分帧时间被光剔除阶段消耗。</p>
<p>现在让我们看看这三种方式如何相互比较。</p>
<h2 id="Techniques-Compared-方式比较">Techniques Compared&nbsp;方式比较</h2>
<p>首先，我们将看看这三种方式在使用大灯时如何相互比较。</p>
<h3 id="Large-Lights-大灯-4">Large Lights&nbsp;大灯</h3>
<p>下面的图表显示了使用大灯光时三种渲染方式的性能。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172111829.png" alt="Rendering Techniques (Large Lights)渲染方式（大灯光）" loading='lazy'></p>
<p>正如预期的那样，在渲染大光源时，前向渲染是最昂贵的渲染算法。延迟渲染和瓦片前向渲染在性能上是可比的。即使我们忽略场景中透明几何体的渲染，延迟渲染和瓦片前向渲染具有类似的性能特征。</p>
<p>如果我们只考虑有几个大灯光的场景，前向渲染、延迟渲染或前向加渲染之间仍然没有明显的性能优势。</p>
<p>如果我们考虑执行前向渲染与延迟渲染与平铺前向渲染所需的内存占用，那么传统的前向渲染具有最小的内存使用量。</p>
<p>无论场景中灯光数量如何，延迟渲染每个额外的 G 缓冲渲染目标每像素大约需要四个字节的 GPU 内存。平铺前向渲染需要额外的 GPU 存储用于光索引列表和光栅格，即使场景只包含少量动态光也必须存储。</p>
<ul>
<li>Deferred Rendering (Diffuse, Specular, Normal @ 1280×720): +11 MB<br>
延迟渲染（漫反射，镜面反射，法线 @ 1280×720）：+11 MB</li>
<li>Tiled Forward Rendering (Light Index List, Light Grid @ 1280×720): +5.76 MB<br>
平铺式前向渲染（光索引列表，1280×720 光栅）：+5.76 MB</li>
</ul>
<p>延迟渲染的额外存储需求基于每像素 32 位（4 字节）的三个全屏缓冲区。深度/模板缓冲区和光积累缓冲区不被视为额外存储，因为标准前向渲染也使用这些缓冲区。</p>
<p>平铺式前向渲染的额外存储需求基于两个光索引列表，每个瓦片平均存储 200 个光源，以及两个 80×45 的光栅，每个格子存储 2 个无符号整数。</p>
<p>如果 GPU 存储在目标平台上是一种稀缺资源，并且场景中不需要太多的光照，传统的前向渲染仍然是最佳选择。</p>
<h3 id="Small-Lights-小灯-4">Small Lights&nbsp;小灯</h3>
<p>下面的图表显示了使用小灯光时三种渲染方式的性能。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172111283.png" alt="Rendering Techniques (Small Lights)渲染方式（小灯光）" loading='lazy'></p>
<p>在小灯光的情况下，瓷砖式前向渲染在渲染时间方面显然是赢家。直到大约 128 个灯光左右，延迟和瓷砖式前向渲染在性能上是可比的，但当场景包含许多动态灯光时，它们很快就会分道扬镳。此外，我们必须考虑到延迟渲染方式的大部分消耗在渲染透明对象上。如果透明对象不是必需的话，那么延迟渲染可能是一个可行的选择。</p>
<p>即使使用小灯光，延迟渲染也需要更多的绘制调用来渲染光体的几何形状。使用延迟渲染，每个光体至少必须渲染两次，第一次绘制调用更新模板缓冲区，第二次绘制调用执行光照方程。如果图形平台对过多的绘制调用非常敏感，那么延迟渲染可能不是最佳选择。</p>
<p>与大灯光场景类似，当场景中只渲染少量灯光时，三种方式的性能特征相似。在这种情况下，我们必须考虑延迟和平铺前向渲染所施加的额外内存需求。同样，如果 GPU 内存稀缺且场景中不需要许多动态灯光，则标准前向渲染可能是一个可行的解决方案。</p>
<h2 id="Future-Considerations-未来考虑">Future Considerations&nbsp;未来考虑</h2>
<p>在这个项目中工作时，我发现了一些问题，这些问题在未来值得考虑。</p>
<ol>
<li>General Issues: &nbsp;一般问题:
<ul>
<li>Size of the light structure<br>
轻结构的大小</li>
</ul>
</li>
<li>Forward Rendering: &nbsp;前向渲染
<ul>
<li>Depth pre-pass&nbsp;深度预pass</li>
<li>View frustum culling of visible lights<br>
查看视锥体裁剪可见光</li>
</ul>
</li>
<li>Deferred Rendering: &nbsp;延迟渲染
<ul>
<li>Optimize G-buffers&nbsp;优化 G-Buffer</li>
<li>Rendering of directional lights<br>
定向光的渲染</li>
</ul>
</li>
<li>Tiled Forward Rendering &nbsp;平铺正向渲染
<ul>
<li>Improve light culling&nbsp;改进光剔除</li>
</ul>
</li>
</ol>
<h2 id="General-Considerations-一般考虑">General Considerations&nbsp;一般考虑</h2>
<p>在此演示中使用的每种渲染方式中，只有一个存储定向光、点光和聚光灯的全局光列表，存储在单个数据结构中。为了存储执行正确光照所需的所有属性，每个单独的光结构需要 160 字节的 GPU 内存。如果我们只存储描述光源所需的绝对最小信息，我们可以利用改进的光数据缓存，并可能改善所有渲染方式的渲染性能。这可能需要有额外的数据结构，只存储计算着色器或片元着色器所需的相关信息，或者创建定向光、聚光灯和点光的单独列表，以便不存储与光源无关的冗余信息在数据结构中。</p>
<h2 id="Forward-Rendering-前向渲染">Forward Rendering&nbsp;前向渲染</h2>
<p>此前向渲染方式的实现没有尝试优化前向渲染管线。根据视锥体剔除光源将是改善前向渲染器渲染性能的合理方法。</p>
<p>作为正向渲染方式的第一步，执行深度预先通行将使我们能够利用早期 z 测试来消除冗余的光照计算。</p>
<h2 id="Deferred-Rendering-延迟渲染">Deferred Rendering&nbsp;延迟渲染</h2>
<p>在创建延迟渲染方式的实现时，我并没有花太多时间评估延迟渲染的性能与所使用的 G-buffer 纹理格式有关。G-buffer 的布局是为了简单和易用而选择的。例如，用于存储视图空间法线的 G-buffer 纹理使用了一个 4 分量 32 位浮点缓冲。将这个渲染目标存储为一个 2 分量 16 位定点缓冲不仅会减少缓冲区大小 75%，还会改善纹理缓存。唯一需要更改的是在着色器中用于打包和解包法线数据的方法。为了将法线打包到 G-buffer 中，我们只需要将法线的归一化 32 位浮点 x 和 y 值转换为 16 位浮点值并存储在渲染目标中。在光照pass中解包法线时，我们可以从缓冲区中读取 16 位分量，并通过以下公式计算法线的 z 分量：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>z</mi><mo>=</mo><msqrt><mrow><mn>1</mn><mo>−</mo><mo stretchy="false">(</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup><mo stretchy="false">)</mo></mrow></msqrt></mrow><annotation encoding="application/x-tex">z=\sqrt{1-(x^2+y^2)}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.2561em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9839em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-2.9439em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width="400em" height="1.28em" viewBox="0 0 400000 1296" preserveAspectRatio="xMinYMin slice"><path d="M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z"></path></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2561em;"><span></span></span></span></span></span></span></span></span></span></p>
<p>这将导致法线的 z 分量在 [0⋯1] 范围内始终为正。这通常不是问题，因为法线始终存储在视图空间中，并且如果法线的 z 分量为负，则它将是背面的，并且背面的多边形无论如何都应该被剔除。</p>
<p>延迟渲染器的另一个潜在改进领域是处理定向光源。目前的实现将定向光源渲染为全屏四边形在光照pass中。这可能不是最佳方法，因为即使是少量的定向光源也会导致严重的过度绘制，并可能成为填充率受限硬件的问题。为了缓解这个问题，我们可以将定向光源的光照计算移到 G-buffer pass，并将定向光源的光照贡献累积到光积累缓冲区中，类似于环境和发射项的应用方式。</p>
<p>这种方式可以通过在 G-Buffer传递之前执行深度预pass来进一步改进，以允许提前进行 z 测试，以消除多余的光照计算。</p>
<p>使用延迟渲染的一个优点是阴影贴图可以被回收利用，因为在光照pass一次只渲染一个光源，所以只需要分配一个阴影贴图。将定向光的光照计算移动到 G 缓冲pass会要求在 G 缓冲pass之前需要准备好定向光使用的任何阴影贴图。只有在场景中有很多投射阴影的定向光时才会出现问题。如果使用了很多投射阴影的定向光，在 G 缓冲pass中执行定向光的光照计算的方法可能不可行。</p>
<h2 id="Tiled-Forward-Rendering-平铺式前向渲染">Tiled Forward Rendering&nbsp;平铺式前向渲染</h2>
<p>从实验结果可以看出，光剔除阶段需要相当长的时间来执行。如果光剔除阶段的性能得到改进，那么我们就可以获得平铺式前向渲染方式的整体性能提升。也许我们可以执行一个早期剔除步骤，消除不在视锥体内的光源。这将需要创建另一个计算着色器，对场景中的所有光源执行视锥体剔除，但不是对所有光源执行 3,600 个视锥体的剔除，只需要检查视锥体。这样，调度中的每个线程只需要检查一小部分光源是否在视锥体内。在根据较大的视锥体剔除光源之后，每个瓦片的光剔除计算着色器只需要检查包含在视锥体内的光源。</p>
<p>光照剔除阶段的另一个改进可能是使用稀疏八叉树来存储八叉树每个节点的光列表。如果节点中的光数量超过某个最大阈值，就会对节点进行分割。在八叉树中不包含任何光的节点可以从八叉树中移除，并且在最终渲染过程中无需考虑。</p>
<p>DirectX 12 引入了体积平铺资源[20]，可用于实现稀疏八叉树。八叉树中没有任何光源的节点不需要任何后备内存。我不确定这将如何实现，但值得调查。</p>
<p>瓷砖化前向渲染方式的另一个改进领域是提高光照剔除的准确性。视锥剔除可能导致将光视为包含在瓷砖中，而实际上光体的任何部分都不包含在瓷砖中。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172114921.png" alt="Tile Frustum Culling (Point Light)平铺锥体裁剪（点光源）" loading='lazy'></p>
<p>如上图所示，一个点光源用红色圆圈标出。图中的蓝色瓷砖显示了哪些瓷砖检测到圆圈包含在瓷砖的视锥体内。当然，红色圆圈内的瓷砖应该检测到点光源，但是在角落的瓷砖是误报。这是因为球体不能被瓷砖视锥体的任何平面完全拒绝。</p>
<p>如果我们放大到左上角的瓷砖（在上面的视频中用绿色标出），我们可以检查瓷砖的顶部、左侧、底部和右侧截锥面。如果您播放视频，您会看到球部分包含在瓷砖的四个截锥面中，因此光线无法被剔除。</p>
<p>在 2015 年 GDC 由 Gareth Thomas [21]演示的演示中，他提出了几种改进基于瓦片的计算渲染准确性的方法。他建议在光遮挡计算着色器中使用并行归约而不是原子最小/最大函数。他的性能分析显示，通过使用并行归约而不是原子最小/最大，他能够实现 11-14％的性能提升。</p>
<p>为了提高光遮挡的准确性，Gareth 建议使用轴对齐边界框（AABB）来近似瓦片视锥体。使用 AABB 来近似瓦片视锥体的大小被证明是一种成功减少误报数目的方法，而不需要进行昂贵的相交测试。为了执行球体-AABB 相交测试，Gareth 建议使用 James Arvo 在《图形宝石》系列第一版中描述的非常简单的算法。</p>
<p>使用最小/最大深度边界进行基于瓦片的光遮挡时的另一个问题出现在具有大深度不连续性的瓦片中，例如当前景几何体仅部分重叠瓦片时。</p>
<p><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172114535.png" alt="Depth Discontinuities深度不连续" loading='lazy'></p>
<p>蓝色和绿色瓦片中包含非常少的光。在这种情况下，最小和最大深度值非常接近。红色瓦片表示该瓦片包含许多光，因为深度差异很大。在加雷斯·托马斯的演示中[21]，他建议将视锥体分成两半，并为分割后的每半部分计算最小和最大深度值。这意味着光剔除算法必须对每个瓦片执行两倍的工作量，但他的性能分析显示，使用这种方式可以将总帧时间减少约 10-12％。</p>
<p>更有趣的性能优化是一种称为“集群着色”的方法，由 Ola Olsson、Markus Billeter 和 Ulf Assarsson 在他们的论文《集群延迟和前向着色》[23]中提出。他们的方法将具有相似属性（3D 位置和法线）的视图样本分组到集群中。场景中的灯光被分配到集群，并且每个集群的灯光列表在最终着色中使用。在他们的论文中，他们声称能够处理一百万个光源，同时保持实时帧速率。</p>
<p>其他空间划分算法也可能在改进基于瓦片的计算着色器性能方面取得成功。例如，使用二叉空间划分（BSP）树将光源分割到二叉树的叶子节点中。在执行最终着色时，只需要考虑片元存在的 BSP 叶子节点中的光源进行光照。</p>
<p>另一个可能用于减少冗余光照计算的数据结构是稀疏体素八叉树，由 Cyril Crassin 和 Simon Green 在 OpenGL Insights [24]中描述。该数据结构不是用于存储材质信息，而是用于存储每个节点中包含的光源索引列表。在最终着色期间，根据片元的 3D 位置从八叉树中查询光源索引列表。</p>
<h1>Conclusion&nbsp;结论</h1>
<p>在本文中，我描述了三种渲染方式的实现：</p>
<ol>
<li>Forward Rendering&nbsp;Forward 渲染</li>
<li>Deferred Rendering&nbsp;延迟渲染</li>
<li>Tiled Forward (Forward+) Rendering<br>
平铺前向（Forward+）渲染</li>
</ol>
<p>我已经表明传统前向渲染非常适合需要支持多种着色模型和半透明对象的场景。前向渲染也非常适合只有少量动态光源的场景。分析表明，包含少于 100 个动态场景光源的场景在商用硬件上仍然表现得相当好。当 GPU 内存稀缺且不需要支持许多动态光源时（例如在移动设备或嵌入式设备上），传统前向渲染可能是最佳选择，因为前向渲染在不需要多个阴影贴图时具有较低的内存占用。</p>
<p>延迟渲染最适合不需要多个着色模型或半透明对象的情况，但需要许多动态场景光源的情况。延迟渲染非常适合许多投射阴影的光源，因为在光照pass中可以在连续光源之间共享单个阴影贴图。延迟渲染不适合 GPU 内存有限的设备。在三种渲染方式中，延迟渲染具有最大的内存占用量，每像素每个 G 缓冲纹理需要额外 4 字节（在分辨率为 1280×720 的屏幕分辨率下每个纹理约为 3.7 MB）。</p>
<p>瓦片前向渲染需要一定的初始开销来调度光照剔除计算着色器，但是具有许多动态光源的瓦片前向渲染的性能很快超过了前向渲染和延迟渲染的性能。瓦片前向渲染需要少量额外的内存。在屏幕分辨率为 1280×720 时，需要大约 5.7 MB 的额外存储空间来存储光索引列表和光栅，使用 16×16 个瓦片。瓦片前向渲染要求目标平台支持计算着色器。如果计算着色器不可用，则可以在 CPU 上执行光照剔除，并将光索引列表和光栅传递给像素着色器，但性能折衷可能会抵消进行光照剔除的好处。</p>
<p>平铺式前向渲染本地支持多材质和半透明材质（使用两个光索引列表），不透明和半透明材质都可以从平铺式前向渲染提供的性能增益中受益。</p>
<p>尽管平铺的前向着色似乎是对生命、宇宙和一切的答案（实际上是 42），但这种方式仍有改进空间。聚类延迟渲染[23]应该能够在增加内存需求的情况下表现得更好。也许通过使用稀疏体纹理[20]可以缓解聚类延迟渲染的内存需求，但这还有待观察。</p>
<h1>Download the Demo&nbsp;下载演示</h1>
<p>源代码（包括预构建的可执行文件）可以从 GitHub 使用下面的链接下载。该存储库的大小接近 1GB，并包含所有预构建的第三方库和 Crytek Sponza 场景[11]。<br>
<a target="_blank" rel="noopener" href="https://github.com/3dgep/ForwardPlus">https://github.com/3dgep/ForwardPlus</a></p>
<h1>引用</h1>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=n5OiqJP2f7w">https://www.youtube.com/watch?v=n5OiqJP2f7w</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="www.lfzxb.top">烟雨迷离半世殇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://www.lfzxb.top/forward-vs-deferred-vs-forward-plus/">https://www.lfzxb.top/forward-vs-deferred-vs-forward-plus/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://www.lfzxb.top" target="_blank">登峰造极者，殊途亦同归。</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Defered-Render/">Defered Render</a><a class="post-meta__tags" href="/tags/Forward-Plus-Render/">Forward Plus Render</a></div><div class="post-share"><div class="social-share" data-image="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405172106940.jpeg!webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer=""></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175314.png!webp" target="_blank"><img class="post-qr-code-img" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175314.png!webp" alt="微信" loading='lazy'></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175304.png!webp" target="_blank"><img class="post-qr-code-img" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/2019/04/QQ截图20190430175304.png!webp" alt="支付宝" loading='lazy'></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><div class="ads-wrap"><ins class="adsbygoogle" style="display:block; text-align:center;" data-ad-layout="in-article" data-ad-format="fluid" data-ad-client="ca-pub-7235595771604497" data-ad-slot="9104433828"></ins><script> (adsbygoogle = window.adsbygoogle || []).push({});</script></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/houdini-intro/" title="Houdini大纲"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202406282153548.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post" loading='lazy'><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Houdini大纲</div></div><div class="info-2"><div class="info-item-1">总览 Houdini 是一款次时代的程序化建模、动画、特效、模拟、渲染和合成软件包。 Houdini 的强大在于程序化的工作流程。在 Houdini 中工作涉及创建连接在一起的节点网络，描述完成任务的步骤。例如，一个创建盒子的节点可能被连接到一个将盒子的边缘挤出的节点，然后是一个细分多边形的节点，再是一个编辑点位置的节点。这赋予了您巨大的力量：  您可以返回到网络中的先前节点并更改选择、更改设置或替换资产。更改会自动传播到网络中，改变最终结果。您无需撤销或重新开始并重新创建工作，以更改您之前做出的决定。 它鼓励快速原型设计。在探索想法时，您无需丢弃已完成的工作 - 只需重复使用网络的部分或重新配置网络以将其升级为工业级的质量。 由于 Houdini 基于程序生成事物，它拥有许多用于管理极其庞大和复杂场景的工具，包括支持生成/加载几何体，并在渲染时添加细节，而不是将所有内容保存在内存中。 您可以打包网络并将其制作成具有自己界面的新工具，而无需编写任何代码。在 Houdini 中，这些工具被称为数字资产（HDA Houdini Digital Assets）。   节点和网络 Hou...</div></div></div></a><a class="pagination-related" href="/ghost-recon-wildlands-terrain-technology-and-tools/" title="（译）Ghost Recon Wildlands Terrain Technology And Tools"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/typoraImages_3/202405102201618.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post" loading='lazy'><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">（译）Ghost Recon Wildlands Terrain Technology And Tools</div></div><div class="info-2"><div class="info-item-1">本文是对https://www.gdcvault.com/play/1024029/-Ghost-Recon-Wildlands-Terrain 进行的中文翻译  大纲 《幽灵行动：荒野》是育碧迄今为止制作的最大动作冒险开放世界游戏，32km x 32km 游戏设定在玻利维亚，我们在游戏中有很多多样性，11 个完全不同的生物群落 湖泊、河流和溪流覆盖了 16 平方公里的表面 道路：超过 600 公里的道路，甚至更多的小径 一条贯穿整个游戏世界的完整铁路网络 游戏中有 200 多个特定位置：营地、地标、前哨站和 58 个完全程序生成的村庄  第一个原型 地形工具 地形渲染的所有细节 程序化工具  第一个原型 https://vimeo.com/207479227 《幽灵行动：未来战士》之后，我们开始尝试更大的地形。 使用真实世界数据，我们使用世界机器优化了 DEM 文件。然后使用 Houdini 创建了一些工具来：   自动创建具有 LOD 的tile网格。   定义一种splat mask，根据坡度、海拔、粗糙度和来自 worldMachine 的其他mask（如flowmap）...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/forwardplus-bringing-deferred-lighting-to-the-next-level/" title="（译）Forward Plus Bringing Deferred Lighting to the Next Level"><img class="cover" src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/202401141708626.png!webp" alt="cover" loading='lazy'><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="fas fa-history fa-fw"></i> 2025-02-27</div><div class="info-item-2">（译）Forward Plus Bringing Deferred Lighting to the Next Level</div></div><div class="info-2"><div class="info-item-1">在网上鲜少有能全面，具体介绍Forward+渲染管线的文章，所以抽空翻译下这个2015年的PPT，分享出来 摘要 这篇论文介绍了Forward+，这是一种通过剔除和仅存储对像素有贡献的光源来渲染许多光源的方法。Forward+是对传统的Forward渲染的扩展。利用GPU的计算能力实现的light-culling模块被添加到渲染管线中，用于创建有效light-list；该列表传递给最终的渲染着色器，该着色器可以访问有关光源的所有信息。尽管Forward+增加了最终着色器的工作量，但从理论上讲，它与compute-shader-based的延迟光照相比需要更少的内存带宽。此外，它避免了延迟技术的主要缺点：即对材质和光照模型的限制。 本论文进行了实验以比较Forward+和延迟光照的性能。 PS：参考Forward框架的逆袭：解析Forward+渲染 的内容，TBDR和Forward+内容对比：(注意此处的TBDR不是指移动平台的TBR架构，而是一种渲染流水线方案) TBDR：  生成G-Buffer，这一步和传统deferred shading一样。 把G-Buffer划分成许多1...</div></div></div></a></div></div><hr class="custom-hr"><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">1.</span> <span class="toc-text">Introduction&nbsp;介绍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">2.</span> <span class="toc-text">Definitions&nbsp;定义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Forward-rendering"><span class="toc-number">2.1.</span> <span class="toc-text">Forward rendering</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Deferred-shading"><span class="toc-number">2.2.</span> <span class="toc-text">Deferred shading</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Forward"><span class="toc-number">2.3.</span> <span class="toc-text">Forward+</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Light"><span class="toc-number">2.4.</span> <span class="toc-text">Light</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">3.</span> <span class="toc-text">Foward渲染实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Vertex-Shader-%E9%A1%B6%E7%82%B9%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">3.1.</span> <span class="toc-text">Vertex Shader&nbsp;顶点着色器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pixel-Shader-%E5%83%8F%E7%B4%A0%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">3.2.</span> <span class="toc-text">Pixel Shader&nbsp;像素着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Material-%E6%9D%90%E8%B4%A8"><span class="toc-number">3.2.1.</span> <span class="toc-text">Material&nbsp;材质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Textures-%E7%BA%B9%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">Textures&nbsp;纹理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lights-%E7%81%AF%E5%85%89"><span class="toc-number">3.2.3.</span> <span class="toc-text">Lights&nbsp;灯光</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pixel-Shader-Continued-%E5%83%8F%E7%B4%A0%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">3.3.</span> <span class="toc-text">Pixel Shader Continued&nbsp;像素着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Materials-%E6%9D%90%E8%B4%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">Materials&nbsp;材质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Diffuse-%E6%BC%AB%E5%8F%8D%E5%B0%84"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">Diffuse&nbsp;漫反射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Opacity-%E4%B8%8D%E9%80%8F%E6%98%8E%E5%BA%A6"><span class="toc-number">3.3.1.2.</span> <span class="toc-text">Opacity&nbsp;不透明度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Ambient-and-Emissive-%E7%8E%AF%E5%A2%83%E5%92%8C%E8%87%AA%E5%8F%91%E5%85%89"><span class="toc-number">3.3.1.3.</span> <span class="toc-text">Ambient and Emissive&nbsp;环境和自发光</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Specular-Power-%E5%8F%8D%E5%B0%84%E7%8E%87"><span class="toc-number">3.3.1.4.</span> <span class="toc-text">Specular Power&nbsp;反射率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Normals-%E6%AD%A3%E5%B8%B8"><span class="toc-number">3.3.1.5.</span> <span class="toc-text">Normals&nbsp;正常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Normal-Mapping-%E6%B3%95%E7%BA%BF%E8%B4%B4%E5%9B%BE"><span class="toc-number">3.3.1.6.</span> <span class="toc-text">Normal Mapping&nbsp;法线贴图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bump-Mapping-%E5%87%B9%E5%87%B8%E8%B4%B4%E5%9B%BE"><span class="toc-number">3.3.1.7.</span> <span class="toc-text">Bump Mapping&nbsp;凹凸贴图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lighting-%E7%81%AF%E5%85%89"><span class="toc-number">3.3.2.</span> <span class="toc-text">Lighting&nbsp;灯光</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Diffuse-Lighting-%E6%BC%AB%E5%8F%8D%E5%B0%84%E5%85%89%E7%85%A7"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">Diffuse Lighting&nbsp;漫反射光照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Specular-Lighting-%E9%95%9C%E9%9D%A2%E5%85%89%E7%85%A7"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">Specular Lighting&nbsp;镜面光照</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Attenuation-%E8%A1%B0%E5%87%8F"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">Attenuation&nbsp;衰减</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Point-Lights-%E7%82%B9%E5%85%89%E6%BA%90"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">Point Lights&nbsp;点光源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spot-Lights-%E8%81%9A%E5%85%89%E7%81%AF"><span class="toc-number">3.3.2.5.</span> <span class="toc-text">Spot Lights&nbsp;聚光灯</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Directional-Lights-%E5%AE%9A%E5%90%91%E5%85%89"><span class="toc-number">3.3.2.6.</span> <span class="toc-text">Directional Lights&nbsp;定向光</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Final-Shading-%E6%9C%80%E7%BB%88%E7%9D%80%E8%89%B2"><span class="toc-number">3.3.3.</span> <span class="toc-text">Final Shading&nbsp;最终着色</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">4.</span> <span class="toc-text">Deferred Shading&nbsp;延迟渲染</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#G-Buffer-Pass"><span class="toc-number">4.1.</span> <span class="toc-text">G-Buffer Pass</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#G-Buffer-Layout"><span class="toc-number">4.1.1.</span> <span class="toc-text">G-Buffer Layout</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Depth-Stencil-Buffer-%E6%B7%B1%E5%BA%A6-%E6%A8%A1%E6%9D%BF%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.1.1.1.</span> <span class="toc-text">Depth/Stencil Buffer&nbsp;深度/模板缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Light-Accumulation-Buffer"><span class="toc-number">4.1.1.2.</span> <span class="toc-text">Light Accumulation Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Diffuse-Buffer-%E6%BC%AB%E5%8F%8D%E5%B0%84Buffer"><span class="toc-number">4.1.1.3.</span> <span class="toc-text">Diffuse Buffer&nbsp;漫反射Buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Specular-Buffer-%E9%95%9C%E9%9D%A2%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.1.1.4.</span> <span class="toc-text">Specular Buffer&nbsp;镜面缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Normal-Buffer-%E6%B3%95%E7%BA%BF%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">4.1.1.5.</span> <span class="toc-text">Normal Buffer&nbsp;法线缓冲区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Layout-Summary-%E5%B8%83%E5%B1%80%E6%91%98%E8%A6%81"><span class="toc-number">4.1.1.6.</span> <span class="toc-text">Layout Summary&nbsp;布局摘要</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pixel-Shader-%E5%83%8F%E7%B4%A0%E7%9D%80%E8%89%B2%E5%99%A8-2"><span class="toc-number">4.1.2.</span> <span class="toc-text">Pixel Shader&nbsp;像素着色器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lighting-Pass-Guerrilla"><span class="toc-number">4.2.</span> <span class="toc-text">Lighting Pass (Guerrilla)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Determine-Lit-Pixels-%E7%A1%AE%E5%AE%9A%E7%85%A7%E4%BA%AE%E7%9A%84%E5%83%8F%E7%B4%A0"><span class="toc-number">4.2.1.</span> <span class="toc-text">Determine Lit Pixels&nbsp;确定照亮的像素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Mark-Pixels-%E6%A0%87%E8%AE%B0%E5%83%8F%E7%B4%A0"><span class="toc-number">4.2.1.1.</span> <span class="toc-text">Mark Pixels&nbsp;标记像素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Count-Pixels-%E8%AE%A1%E7%AE%97%E5%83%8F%E7%B4%A0"><span class="toc-number">4.2.1.2.</span> <span class="toc-text">Count Pixels&nbsp;计算像素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shade-Pixels-%E9%98%B4%E5%BD%B1%E5%83%8F%E7%B4%A0"><span class="toc-number">4.2.2.</span> <span class="toc-text">Shade Pixels&nbsp;阴影像素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lighting-Pass-My-Implementation"><span class="toc-number">4.3.</span> <span class="toc-text">Lighting Pass (My Implementation)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Unmark-Pixels-%E5%8F%96%E6%B6%88%E6%A0%87%E8%AE%B0%E5%83%8F%E7%B4%A0"><span class="toc-number">4.3.1.</span> <span class="toc-text">Unmark Pixels&nbsp;取消标记像素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Shade-Pixels-%E9%98%B4%E5%BD%B1%E5%83%8F%E7%B4%A0-2"><span class="toc-number">4.3.2.</span> <span class="toc-text">Shade Pixels&nbsp;阴影像素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pixel-Shader-%E5%83%8F%E7%B4%A0%E7%9D%80%E8%89%B2%E5%99%A8-3"><span class="toc-number">4.3.3.</span> <span class="toc-text">Pixel Shader&nbsp;像素着色器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Transparent-Pass-%E9%80%8F%E6%98%8Epass"><span class="toc-number">4.4.</span> <span class="toc-text">Transparent Pass&nbsp;透明pass</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">5.</span> <span class="toc-text">Forward+</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Grid-Frustums-%E7%BD%91%E6%A0%BC%E8%A7%86%E9%94%A5%E4%BD%93"><span class="toc-number">5.1.</span> <span class="toc-text">Grid Frustums&nbsp;网格视锥体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Grid-Frustums-Compute-Shader-%E7%BD%91%E6%A0%BC%E6%88%AA%E9%94%A5%E4%BD%93%E8%AE%A1%E7%AE%97%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">Grid Frustums Compute Shader 网格截锥体计算着色器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Tile-Corners-in-Screen-Space-%E5%B1%8F%E5%B9%95%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84%E7%93%A6%E7%89%87%E8%A7%92%E7%82%B9"><span class="toc-number">5.2.1.</span> <span class="toc-text">Tile Corners in Screen Space 屏幕空间中的瓦片角点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Tile-Corners-in-View-Space-%E5%9C%A8%E8%A7%86%E5%9B%BE%E7%A9%BA%E9%97%B4%E4%B8%AD%E7%9A%84Tile%E8%A7%92"><span class="toc-number">5.2.2.</span> <span class="toc-text">Tile Corners in View Space 在视图空间中的Tile角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Compute-Frustum-Planes-%E8%AE%A1%E7%AE%97%E8%A7%86%E9%94%A5%E4%BD%93%E5%B9%B3%E9%9D%A2"><span class="toc-number">5.2.3.</span> <span class="toc-text">Compute Frustum Planes&nbsp;计算视锥体平面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Store-Grid-Frustums-%E5%AD%98%E5%82%A8%E7%BD%91%E6%A0%BC%E8%A7%86%E9%94%A5%E4%BD%93"><span class="toc-number">5.2.4.</span> <span class="toc-text">Store Grid Frustums&nbsp;存储网格视锥体</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Light-Culling-%E5%85%89%E7%85%A7%E5%89%94%E9%99%A4"><span class="toc-number">5.3.</span> <span class="toc-text">Light Culling&nbsp;光照剔除</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Compute-Min-Max-Depth-Values-%E8%AE%A1%E7%AE%97%E6%9C%80%E5%B0%8F-%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6%E5%80%BC"><span class="toc-number">5.3.1.</span> <span class="toc-text">Compute Min/Max Depth Values  计算最小/最大深度值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Light-List-Data-Structure-%E5%85%89%E5%88%97%E8%A1%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.2.</span> <span class="toc-text">Light List Data Structure 光列表数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Frustum-Culling-%E8%A7%86%E9%94%A5%E4%BD%93%E8%A3%81%E5%89%AA"><span class="toc-number">5.4.</span> <span class="toc-text">Frustum Culling&nbsp;视锥体裁剪</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Frustum-Sphere-Culling-%E8%A7%86%E9%94%A5-%E7%90%83%E4%BD%93%E8%A3%81%E5%89%AA"><span class="toc-number">5.4.1.</span> <span class="toc-text">Frustum-Sphere Culling&nbsp;视锥-球体裁剪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Frustum-Cone-Culling-%E9%94%A5%E4%BD%93%E6%88%AA%E9%94%A5%E4%BD%93%E8%A3%81%E5%89%AA"><span class="toc-number">5.4.2.</span> <span class="toc-text">Frustum-Cone Culling&nbsp;锥体截锥体裁剪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Light-Culling-Compute-Shader-%E5%85%89%E7%85%A7%E5%89%94%E9%99%A4%E8%AE%A1%E7%AE%97%E7%9D%80%E8%89%B2%E5%99%A8"><span class="toc-number">5.5.</span> <span class="toc-text">Light Culling Compute Shader 光照剔除计算着色器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Final-Shading-%E6%9C%80%E7%BB%88%E7%9D%80%E8%89%B2-2"><span class="toc-number">5.6.</span> <span class="toc-text">Final Shading&nbsp;最终着色</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">6.</span> <span class="toc-text">Experiment Setup and Performance Results  实验设置和性能结果</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Forward-Rendering-Performance-%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD"><span class="toc-number">6.1.</span> <span class="toc-text">Forward Rendering Performance  前向渲染性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Large-Lights-%E5%A4%A7%E7%81%AF"><span class="toc-number">6.1.1.</span> <span class="toc-text">Large Lights&nbsp;大灯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Small-Lights-%E5%B0%8F%E7%81%AF"><span class="toc-number">6.1.2.</span> <span class="toc-text">Small Lights&nbsp;小灯</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Deferred-Rendering-Performance-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93%E6%80%A7%E8%83%BD"><span class="toc-number">6.2.</span> <span class="toc-text">Deferred Rendering Performance  延迟渲染性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Large-Lights-%E5%A4%A7%E7%81%AF-2"><span class="toc-number">6.2.1.</span> <span class="toc-text">Large Lights&nbsp;大灯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Small-Lights-%E5%B0%8F%E7%81%AF-2"><span class="toc-number">6.2.2.</span> <span class="toc-text">Small Lights&nbsp;小灯</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Forward-Plus-Performance-Forward-%E6%80%A7%E8%83%BD"><span class="toc-number">6.3.</span> <span class="toc-text">Forward Plus Performance&nbsp;Forward+性能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Large-Lights-%E5%A4%A7%E7%81%AF-3"><span class="toc-number">6.3.1.</span> <span class="toc-text">Large Lights&nbsp;大灯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Small-Lights-%E5%B0%8F%E7%81%AF-3"><span class="toc-number">6.3.2.</span> <span class="toc-text">Small Lights&nbsp;小灯</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Techniques-Compared-%E6%96%B9%E5%BC%8F%E6%AF%94%E8%BE%83"><span class="toc-number">6.4.</span> <span class="toc-text">Techniques Compared&nbsp;方式比较</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Large-Lights-%E5%A4%A7%E7%81%AF-4"><span class="toc-number">6.4.1.</span> <span class="toc-text">Large Lights&nbsp;大灯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Small-Lights-%E5%B0%8F%E7%81%AF-4"><span class="toc-number">6.4.2.</span> <span class="toc-text">Small Lights&nbsp;小灯</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Future-Considerations-%E6%9C%AA%E6%9D%A5%E8%80%83%E8%99%91"><span class="toc-number">6.5.</span> <span class="toc-text">Future Considerations&nbsp;未来考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#General-Considerations-%E4%B8%80%E8%88%AC%E8%80%83%E8%99%91"><span class="toc-number">6.6.</span> <span class="toc-text">General Considerations&nbsp;一般考虑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Forward-Rendering-%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93"><span class="toc-number">6.7.</span> <span class="toc-text">Forward Rendering&nbsp;前向渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Deferred-Rendering-%E5%BB%B6%E8%BF%9F%E6%B8%B2%E6%9F%93"><span class="toc-number">6.8.</span> <span class="toc-text">Deferred Rendering&nbsp;延迟渲染</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Tiled-Forward-Rendering-%E5%B9%B3%E9%93%BA%E5%BC%8F%E5%89%8D%E5%90%91%E6%B8%B2%E6%9F%93"><span class="toc-number">6.9.</span> <span class="toc-text">Tiled Forward Rendering&nbsp;平铺式前向渲染</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">7.</span> <span class="toc-text">Conclusion&nbsp;结论</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">8.</span> <span class="toc-text">Download the Demo&nbsp;下载演示</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#postchat_postcontent"><span class="toc-number">9.</span> <span class="toc-text">引用</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url(https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/20210912135042.png!webp);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">©&nbsp;2025 - 2026 By 烟雨迷离半世殇</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.0</a></span></div><div class="footer_custom_text">2018-2025 lfzxb.top版权所有<br><span id="realtime_duration"></span><br><a href="https://beian.miit.gov.cn" target="_blank">苏ICP备19003389号-1</a><br><img src="https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/blog2021/20210912135040.png!webp" alt="公网安备字" loading='lazy'><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=32032102000159" target="_blank">苏公网安备 32032102000159号</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="fluid-control-btn" type="button" title="流体模拟控制台"><i class="fas fa-water"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (true) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: '508db6cacf197b7363d1',
      clientSecret: '2882a0b135eaa72b3ab256e37249c50733ce9e91',
      repo: 'wqaetly',
      owner: 'wqaetly',
      admin: ['wqaetly'],
      updateCountCallback: commentCount,
      proxy: "https://strong-caramel-969805.netlify.app/github_access_token",
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '8a8e92fa620042aeba076a20cd64e9ff'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !false) {
    if (false) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="https://cdn.jsdelivr.net/npm/dayjs/dayjs.min.js"></script><script src="https://cdn.jsdelivr.net/npm/dayjs/plugin/duration.min.js"></script><script src="/js/realtime.js"></script><script>window.FLUID_CONFIG={enable:true,mobile:false,z_index:-1,SIM_RESOLUTION:128,DYE_RESOLUTION:1024,DENSITY_DISSIPATION:1,VELOCITY_DISSIPATION:0.2,PRESSURE:0.8,PRESSURE_ITERATIONS:20,CURL:30,SPLAT_RADIUS:0.25,SPLAT_FORCE:6000,SHADING:true,COLORFUL:true,COLOR_UPDATE_SPEED:10,PAUSED:false,BACK_COLOR:{r:0,g:0,b:0},TRANSPARENT:false,BLOOM:true,BLOOM_ITERATIONS:8,BLOOM_RESOLUTION:256,BLOOM_INTENSITY:0.8,BLOOM_THRESHOLD:0.6,BLOOM_SOFT_KNEE:0.7,SUNRAYS:true,SUNRAYS_RESOLUTION:196,SUNRAYS_WEIGHT:1.0,interaction:{enable:true}};</script><script src="/js/fluid-simulation/dat.gui.min.js"></script><script src="/js/fluid-simulation/fluid-core.js"></script><script async="" data-pjax="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="docsearch-wrap"><div id="docsearch" style="display:none"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@docsearch/css/dist/style.min.css"><script src="https://cdn.jsdelivr.net/npm/@docsearch/js/dist/umd/index.min.js"></script><script>(() => {
  docsearch(Object.assign({
    appId: 'D3U85CARGJ',
    apiKey: '3edfc5bada9a140d5a4126085596f99c',
    indexName: 'blogsearch',
    container: '#docsearch',
    placeholder: '搜索文章',
  }, null))

  const handleClick = () => {
    document.querySelector('.DocSearch-Button').click()
  }

  const searchClickFn = () => {
    btf.addEventListenerPjax(document.querySelector('#search-button > .search'), 'click', handleClick)
  }

  searchClickFn()
  window.addEventListener('pjax:complete', searchClickFn)
})()</script></div></div>
    <link rel="stylesheet" href="https://ai.tianli0.top/static/public/postChatUser_summary.min.css">
    <script>
        let tianliGPT_key = 'S-TY6LYYCZMYV6UADE';
        let tianliGPT_postSelector = '#article-container';
        let tianliGPT_Title = '烟雨迷离半世殇（人机版）为您总结文章';
        let tianliGPT_postURL = 'https://www.lfzxb.top/*/';
        let tianliGPT_blacklist = '';
        let tianliGPT_wordLimit = '50000';
        let tianliGPT_typingAnimate = false;
        let tianliGPT_theme = 'menghuan';
        var postChatConfig = {
          backgroundColor: "#3e86f6",
          bottom: "16px",
          left: "16px",
          fill: "#FFFFFF",
          width: "44px",
          frameWidth: "375px",
          frameHeight: "600px",
          defaultInput: false,
          upLoadWeb: true,
          showInviteLink: true,
          userTitle: "烟雨迷离半世殇（人机版）为您服务",
          userDesc: "在下定知无不言",
          addButton: true,
          beginningText: "这篇文章介绍了",
          userIcon: "https://myfirstblog.oss-cn-hangzhou.aliyuncs.com/AvatarAndBGs/33ec68b7fe1bb742.jpg!webp",
          userMode: "magic",
          defaultChatQuestions: ["你好","你是谁"],
          defaultSearchQuestions: ["视频压缩","设计"]
        };
    </script>
    <script data-postchat_key="S-TY6LYYCZMYV6UADE" src="https://ai.tianli0.top/static/public/postChatUser_summary.min.js"></script>
  </body></html>